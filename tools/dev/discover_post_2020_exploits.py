#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Discovery script to identify all post-2020 Ruby exploits in Metasploit Framework
that need to be converted to Python.

This script scans the modules directory for Ruby files, extracts disclosure dates,
and generates an inventory of modules that need conversion.
"""

import os
import re
import json
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Tuple

class ExploitDiscovery:
    """Discover and catalog Ruby exploits for Python conversion."""
    
    def __init__(self, base_path: str = "/workspace"):
        self.base_path = Path(base_path)
        self.modules_path = self.base_path / "modules"
        self.cutoff_date = datetime(2021, 1, 1)  # Post-2020 means 2021 and later
        
        # Patterns to extract metadata from Ruby files
        self.disclosure_date_pattern = re.compile(r"'DisclosureDate'\s*=>\s*'([^']+)'")
        self.name_pattern = re.compile(r"'Name'\s*=>\s*'([^']+)'")
        self.cve_pattern = re.compile(r"\['CVE',\s*'([^']+)'\]")
        self.rank_pattern = re.compile(r"Rank\s*=\s*(\w+)")
        
        self.discovered_modules = []
        
    def parse_ruby_file(self, file_path: Path) -> Optional[Dict]:
        """Parse a Ruby module file to extract metadata."""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                
            # Extract disclosure date
            date_match = self.disclosure_date_pattern.search(content)
            if not date_match:
                return None
                
            date_str = date_match.group(1)
            try:
                # Parse various date formats
                for fmt in ['%Y-%m-%d', '%Y/%m/%d', '%m/%d/%Y', '%d/%m/%Y']:
                    try:
                        disclosure_date = datetime.strptime(date_str, fmt)
                        break
                    except ValueError:
                        continue
                else:
                    # If no format matches, skip this file
                    return None
                    
                # Only include post-2020 modules
                if disclosure_date < self.cutoff_date:
                    return None
                    
            except Exception:
                return None
                
            # Extract other metadata
            name_match = self.name_pattern.search(content)
            name = name_match.group(1) if name_match else "Unknown"
            
            cve_matches = self.cve_pattern.findall(content)
            cves = cve_matches if cve_matches else []
            
            rank_match = self.rank_pattern.search(content)
            rank = rank_match.group(1) if rank_match else "Unknown"
            
            # Determine module type from path
            relative_path = file_path.relative_to(self.modules_path)
            module_type = str(relative_path.parts[0]) if relative_path.parts else "unknown"
            
            return {
                'file_path': str(file_path),
                'relative_path': str(relative_path),
                'name': name,
                'disclosure_date': date_str,
                'parsed_date': disclosure_date.isoformat(),
                'cves': cves,
                'rank': rank,
                'module_type': module_type,
                'size_bytes': file_path.stat().st_size,
                'needs_conversion': True
            }
            
        except Exception as e:
            print(f"Error parsing {file_path}: {e}")
            return None
    
    def scan_directory(self, directory: Path) -> List[Dict]:
        """Recursively scan directory for Ruby module files."""
        modules = []
        
        if not directory.exists():
            print(f"Directory does not exist: {directory}")
            return modules
            
        for ruby_file in directory.rglob("*.rb"):
            # Skip certain directories/files
            if any(skip in str(ruby_file) for skip in ['/spec/', '/test/', 'example']):
                continue
                
            module_data = self.parse_ruby_file(ruby_file)
            if module_data:
                modules.append(module_data)
                
        return modules
    
    def check_existing_python_conversion(self, ruby_path: str) -> bool:
        """Check if a Python conversion already exists for this Ruby file."""
        # Convert .rb to .py and check if it exists
        python_path = ruby_path.replace('.rb', '.py')
        return Path(python_path).exists()
    
    def discover_all_modules(self) -> List[Dict]:
        """Discover all post-2020 Ruby modules that need conversion."""
        print("Scanning for post-2020 Ruby modules...")
        
        # Scan different module types
        module_types = ['exploits', 'auxiliary', 'post', 'encoders', 'evasion']
        
        for module_type in module_types:
            type_path = self.modules_path / module_type
            if type_path.exists():
                print(f"Scanning {module_type}...")
                modules = self.scan_directory(type_path)
                
                # Check for existing Python conversions
                for module in modules:
                    module['has_python_version'] = self.check_existing_python_conversion(
                        module['file_path']
                    )
                    
                self.discovered_modules.extend(modules)
                print(f"Found {len(modules)} post-2020 {module_type} modules")
        
        # Sort by disclosure date (newest first)
        self.discovered_modules.sort(
            key=lambda x: x['parsed_date'], 
            reverse=True
        )
        
        return self.discovered_modules
    
    def generate_reports(self, output_dir: str = "/workspace/tools/dev"):
        """Generate various reports of discovered modules."""
        output_path = Path(output_dir)
        output_path.mkdir(exist_ok=True)
        
        # JSON report
        json_file = output_path / "post_2020_modules_inventory.json"
        with open(json_file, 'w') as f:
            json.dump(self.discovered_modules, f, indent=2)
        print(f"Generated JSON inventory: {json_file}")
        
        # CSV report
        csv_file = output_path / "post_2020_modules_inventory.csv"
        if self.discovered_modules:
            fieldnames = self.discovered_modules[0].keys()
            with open(csv_file, 'w', newline='') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                writer.writeheader()
                writer.writerows(self.discovered_modules)
        print(f"Generated CSV inventory: {csv_file}")
        
        # Summary report
        summary_file = output_path / "post_2020_conversion_summary.txt"
        with open(summary_file, 'w') as f:
            f.write("POST-2020 RUBY TO PYTHON CONVERSION SUMMARY\n")
            f.write("=" * 50 + "\n\n")
            
            total_modules = len(self.discovered_modules)
            f.write(f"Total post-2020 modules found: {total_modules}\n\n")
            
            # By module type
            by_type = {}
            for module in self.discovered_modules:
                module_type = module['module_type']
                by_type[module_type] = by_type.get(module_type, 0) + 1
            
            f.write("Modules by type:\n")
            for module_type, count in sorted(by_type.items()):
                f.write(f"  {module_type}: {count}\n")
            f.write("\n")
            
            # By year
            by_year = {}
            for module in self.discovered_modules:
                year = module['parsed_date'][:4]
                by_year[year] = by_year.get(year, 0) + 1
            
            f.write("Modules by year:\n")
            for year, count in sorted(by_year.items(), reverse=True):
                f.write(f"  {year}: {count}\n")
            f.write("\n")
            
            # Already converted
            already_converted = sum(1 for m in self.discovered_modules if m['has_python_version'])
            f.write(f"Already have Python versions: {already_converted}\n")
            f.write(f"Still need conversion: {total_modules - already_converted}\n\n")
            
            # High priority (2023-2024)
            high_priority = [m for m in self.discovered_modules 
                           if m['parsed_date'].startswith(('2023', '2024')) 
                           and not m['has_python_version']]
            f.write(f"High priority (2023-2024, no Python version): {len(high_priority)}\n\n")
            
            # List high priority modules
            if high_priority:
                f.write("HIGH PRIORITY MODULES FOR CONVERSION:\n")
                f.write("-" * 40 + "\n")
                for module in high_priority[:20]:  # Top 20
                    f.write(f"{module['relative_path']}\n")
                    f.write(f"  Name: {module['name']}\n")
                    f.write(f"  Date: {module['disclosure_date']}\n")
                    f.write(f"  CVEs: {', '.join(module['cves']) if module['cves'] else 'None'}\n")
                    f.write(f"  Rank: {module['rank']}\n\n")
        
        print(f"Generated summary report: {summary_file}")
        
        return {
            'json_file': str(json_file),
            'csv_file': str(csv_file),
            'summary_file': str(summary_file),
            'total_modules': len(self.discovered_modules),
            'needs_conversion': len([m for m in self.discovered_modules if not m['has_python_version']])
        }

def main():
    """Main function to run the discovery process."""
    print("Metasploit Framework Post-2020 Ruby Module Discovery")
    print("=" * 55)
    
    discovery = ExploitDiscovery()
    modules = discovery.discover_all_modules()
    
    print(f"\nDiscovery complete! Found {len(modules)} post-2020 modules")
    
    # Generate reports
    report_info = discovery.generate_reports()
    
    print(f"\nSummary:")
    print(f"  Total modules: {report_info['total_modules']}")
    print(f"  Need conversion: {report_info['needs_conversion']}")
    print(f"\nReports generated in /workspace/tools/dev/")

if __name__ == "__main__":
    main()