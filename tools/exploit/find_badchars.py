#!/usr/bin/env python3
"""
Find Bad Characters Tool

This script assists exploit developers in deducing what "bad characters" exist
for a given input path to a program by comparing expected vs actual memory contents.

Converted from Ruby to Python as part of the post-2020 Python migration.
"""

import sys
import os
import re
import argparse

# Add lib to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../lib'))

try:
    from rex.text import Text
except ImportError:
    # Fallback implementation if rex.text is not available
    class Text:
        @staticmethod
        def dehex(hex_string):
            """Convert hex string to bytes"""
            hex_string = hex_string.replace('\\x', '')
            hex_string = hex_string.replace(' ', '')
            return bytes.fromhex(hex_string)
        
        @staticmethod
        def to_hex(data):
            """Convert bytes to hex string"""
            if isinstance(data, str):
                data = data.encode()
            return ''.join(['\\x%02x' % b for b in data])
        
        @staticmethod
        def hex_to_raw(hex_string):
            """Convert hex string to raw bytes"""
            hex_string = hex_string.replace('\\x', '')
            hex_string = hex_string.replace(' ', '')
            return bytes.fromhex(hex_string)
        
        @staticmethod
        def charset_exclude(badchars):
            """Generate all bytes excluding badchars"""
            if isinstance(badchars, str):
                badchars = badchars.encode()
            return bytes([i for i in range(256) if i not in badchars])
        
        @staticmethod
        def to_hex_dump(data, width=16):
            """Create hex dump of data"""
            if isinstance(data, str):
                data = data.encode()
            
            result = []
            for i in range(0, len(data), width):
                chunk = data[i:i+width]
                hex_part = ' '.join(['%02x' % b for b in chunk])
                ascii_part = ''.join([chr(b) if 32 <= b < 127 else '.' for b in chunk])
                result.append('%08x  %-*s  %s' % (i, width * 3 - 1, hex_part, ascii_part))
            return '\n'.join(result)


OUT_STATUS = "[*] "
OUT_ERROR = "[-] "


def show_format_list():
    """Display supported input formats"""
    print("Supported formats:")
    print("  raw      raw binary data")
    print("  windbg   output from windbg's \"db\" command")
    print("  gdb      output from gdb's \"x/bx\" command")
    print("  hex      hex bytes like \"\\xFF\\x41\" or \"eb fe\"")


def debug_buffer(name, buf):
    """Debug helper to display buffer contents"""
    print(f"\n{len(buf)} bytes of {name}:", file=sys.stderr)
    if len(buf) > 0:
        print("\n" + Text.to_hex_dump(buf), file=sys.stderr)
    print(file=sys.stderr)


def parse_raw_format(data):
    """Parse raw binary data"""
    return data


def parse_windbg_format(data):
    """Parse WinDbg 'db' command output"""
    translated = ''
    for line in data.split('\n'):
        if len(line) > 10:
            # Extract hex bytes from WinDbg format
            # Example: 00000000  41 42 43 44 45 46 47 48-49 4a 4b 4c 4d 4e 4f 50  ABCDEFGHIJKLMNOP
            hex_part = line[10:57].replace('-', '').replace(' ', '')
            translated += hex_part
    
    return Text.hex_to_raw(translated)


def parse_gdb_format(data):
    """Parse GDB 'x/bx' command output"""
    translated = ''
    for line in data.split('\n'):
        if ':' in line:
            # Extract hex bytes from GDB format
            # Example: 0x401000:	0x41	0x42	0x43	0x44
            parts = line.split(':')
            if len(parts) > 1:
                hex_bytes = parts[1].replace('0x', '').replace(' ', '').replace('\t', '')
                translated += hex_bytes
    
    return Text.hex_to_raw(translated)


def parse_hex_format(data):
    """Parse hex format (either \\xNN or space-separated)"""
    translated = ''
    for line in data.split('\n'):
        # Remove spaces and newlines
        hex_line = line.strip().replace(' ', '')
        translated += hex_line
    
    return Text.hex_to_raw(translated)


def find_bad_characters(badchars, input_file=None, fmt='raw', debug=False):
    """
    Find bad characters by comparing expected vs actual memory contents
    
    Args:
        badchars: Known bad characters to exclude
        input_file: File to read memory contents from (None for stdin)
        fmt: Format of input data (raw, windbg, gdb, hex)
        debug: Enable debug output
        
    Returns:
        Tuple of (new_badchars, messages)
    """
    messages = []
    
    # Generate expected charset excluding known badchars
    badchars_bytes = Text.dehex(badchars) if badchars else b''
    from_msf = Text.charset_exclude(badchars_bytes)
    
    # Read memory contents
    if input_file:
        try:
            with open(input_file, 'rb') as f:
                from_dbg = f.read()
        except Exception as e:
            messages.append(f"{OUT_ERROR}Failed to open file {input_file}: {e}")
            return b'', messages
    else:
        messages.append(f"{OUT_STATUS}Please paste the memory contents in \"{fmt}\" format below (end with EOF):")
        try:
            # Read from stdin
            from_dbg = sys.stdin.buffer.read()
        except Exception as e:
            messages.append(f"{OUT_ERROR}Failed to read from stdin: {e}")
            return b'', messages
    
    # Parse based on format
    try:
        if fmt == 'raw':
            from_dbg = parse_raw_format(from_dbg)
        elif fmt == 'windbg':
            from_dbg = parse_windbg_format(from_dbg.decode('latin-1'))
        elif fmt == 'gdb':
            from_dbg = parse_gdb_format(from_dbg.decode('latin-1'))
        elif fmt == 'hex':
            from_dbg = parse_hex_format(from_dbg.decode('latin-1'))
        else:
            messages.append(f"{OUT_ERROR}Invalid format: {fmt}")
            return b'', messages
    except Exception as e:
        messages.append(f"{OUT_ERROR}Failed to parse input: {e}")
        return b'', messages
    
    # Debug output if requested
    if debug:
        debug_buffer("BadChars", badchars_bytes)
        debug_buffer("memory contents", from_dbg)
        debug_buffer("Rex::Text.charset_exclude() output", from_msf)
    
    # Find differences between expected and actual
    new_badchars = bytearray()
    minlen = min(len(from_msf), len(from_dbg))
    
    for idx in range(minlen):
        ch1 = from_msf[idx]
        ch2 = from_dbg[idx]
        
        if ch1 != ch2:
            msg = f"Byte at index 0x{idx:04x} differs (0x{ch1:02x} became 0x{ch2:02x})"
            messages.append(f"{OUT_STATUS}{msg}")
            new_badchars.append(ch1)
    
    # Report results
    if len(new_badchars) < 1:
        messages.append(f"{OUT_STATUS}All characters matched, no new bad characters discovered.")
    else:
        messages.append(f"{OUT_STATUS}Proposed BadChars: \"{Text.to_hex(bytes(new_badchars))}\"")
    
    return bytes(new_badchars), messages


def main():
    """Main function"""
    parser = argparse.ArgumentParser(
        description="Find bad characters in exploit development",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Read from stdin in raw format
  python3 find_badchars.py -b "\\x00\\xff" < memory.bin
  
  # Read from file in WinDbg format
  python3 find_badchars.py -b "\\x00\\xff" -i windbg_output.txt -t windbg
  
  # Read from file in GDB format
  python3 find_badchars.py -b "\\x00\\x0a\\x0d" -i gdb_output.txt -t gdb
        """
    )
    
    parser.add_argument('-b', '--badchars', default='',
                       help='The list of characters to avoid: "\\x00\\xff"')
    parser.add_argument('-i', '--input', dest='input_file',
                       help='Read memory contents from the supplied file path')
    parser.add_argument('-t', '--type', dest='format', default='raw',
                       choices=['raw', 'windbg', 'gdb', 'hex'],
                       help='The format that the memory contents are in')
    parser.add_argument('-d', '--debug', action='store_true',
                       help='Enable debug output')
    parser.add_argument('--list-formats', action='store_true',
                       help='List supported formats and exit')
    
    args = parser.parse_args()
    
    # Handle list formats
    if args.list_formats:
        show_format_list()
        return 0
    
    try:
        # Find bad characters
        new_badchars, messages = find_bad_characters(
            args.badchars,
            args.input_file,
            args.format,
            args.debug
        )
        
        # Print all messages
        for msg in messages:
            print(msg, file=sys.stderr)
        
        return 0
        
    except KeyboardInterrupt:
        print("\nAborted!", file=sys.stderr)
        return 1
    except Exception as e:
        print(f"{OUT_ERROR}Error: {e}", file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
