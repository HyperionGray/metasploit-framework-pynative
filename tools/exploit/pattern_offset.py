#!/usr/bin/env python3
# -*- coding: utf-8 -*-

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

import sys
import os
import argparse
import struct

# Add the lib directory to the path
script_path = os.path.abspath(__file__)
while os.path.islink(script_path):
    script_path = os.path.abspath(os.path.join(os.path.dirname(script_path), os.readlink(script_path)))
lib_path = os.path.join(os.path.dirname(script_path), '..', '..', 'lib')
sys.path.insert(0, os.path.abspath(lib_path))

try:
    from rex.text import Text
except ImportError:
    print("[!] Error: Could not import rex.text module", file=sys.stderr)
    print("[!] Make sure lib/rex/text.py exists", file=sys.stderr)
    sys.exit(1)


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='Find the offset of a pattern',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f'Example: {sys.argv[0]} -q Aa3A\n[*] Exact match at offset 9'
    )
    
    parser.add_argument('-q', '--query',
                        type=str,
                        required=True,
                        help='Query to Locate')
    
    parser.add_argument('-l', '--length',
                        type=int,
                        default=8192,
                        help='The length of the pattern (default: 8192)')
    
    parser.add_argument('-s', '--sets',
                        type=str,
                        help='Custom Pattern Sets (comma-separated)')
    
    return parser.parse_args()


def main():
    """Main function"""
    try:
        args = parse_args()
        
        # Parse query - can be hex (8+ chars), 4-byte string, or other hex
        query = args.query
        
        if len(query) >= 8 and all(c in '0123456789abcdefABCDEF' for c in query):
            # Looks like hex, convert to integer
            try:
                query = int(query, 16)
            except ValueError:
                pass
        elif len(query) == 4:
            # Four-byte string - convert to little-endian integer
            query = struct.unpack('<I', query.encode('latin-1'))[0]
        else:
            # Try to interpret as hex
            try:
                query = int(query, 16)
            except ValueError:
                # Keep as string
                pass
        
        # Parse custom sets if provided
        sets = None
        if args.sets:
            sets = args.sets.split(',')
        
        # Create pattern
        buffer = Text.pattern_create(args.length, sets)
        
        # Find offset
        offset = Text.pattern_offset(buffer, query)
        
        # Print exact matches first
        if offset is not None:
            # Print all exact matches
            temp_offset = offset
            while temp_offset is not None:
                print(f"[*] Exact match at offset {temp_offset}")
                temp_offset = Text.pattern_offset(buffer, query, temp_offset + 1)
        else:
            # Handle cases where there is no match by looking for "close" matches
            found = False
            print("[*] No exact matches, looking for likely candidates...", file=sys.stderr)
            
            # Look for shifts by a single byte
            if isinstance(query, int):
                for idx in range(4):
                    for c in range(256):
                        nvb = bytearray(struct.pack('<I', query))
                        nvb[idx] = c
                        nvi = struct.unpack('<I', bytes(nvb))[0]
                        
                        off = Text.pattern_offset(buffer, nvi)
                        if off is not None:
                            # Calculate adjustments
                            pattern_val = struct.unpack('<I', buffer[off:off+4].encode('latin-1'))[0]
                            mle = query - pattern_val
                            mbe = query - struct.unpack('>I', buffer[off:off+4].encode('latin-1'))[0]
                            print(f"[+] Possible match at offset {off} (adjusted [ little-endian: {mle} | big-endian: {mbe} ] ) byte offset {idx}")
                            found = True
                
                if found:
                    sys.exit(0)
                
                # Look for 16-bit offsets
                for idx in [0, 2]:
                    for c in range(65536):
                        nvb = bytearray(struct.pack('<I', query))
                        nvb[idx:idx+2] = struct.pack('<H', c)
                        nvi = struct.unpack('<I', bytes(nvb))[0]
                        
                        off = Text.pattern_offset(buffer, nvi)
                        if off is not None:
                            pattern_val = struct.unpack('<I', buffer[off:off+4].encode('latin-1'))[0]
                            mle = query - pattern_val
                            mbe = query - struct.unpack('>I', buffer[off:off+4].encode('latin-1'))[0]
                            print(f"[+] Possible match at offset {off} (adjusted [ little-endian: {mle} | big-endian: {mbe} ] )")
                            found = True
        
    except KeyboardInterrupt:
        print("Aborted!", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"[x] {type(e).__name__}: {e}", file=sys.stderr)
        print("[*] If necessary, please refer to framework.log for more details.", file=sys.stderr)
        sys.exit(1)


if __name__ == '__main__':
    main()
