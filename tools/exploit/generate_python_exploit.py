#!/usr/bin/env python3
"""
Generate a Python exploit skeleton using the python_framework base classes.
"""

import argparse
import os
import re
import sys
from textwrap import dedent

TEMPLATE = """#!/usr/bin/env python3
\"\"\"{name}\"\"\"

import os
import sys
CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, "..", ".."))
sys.path.insert(0, os.path.join(PROJECT_ROOT, "python_framework"))

from python_framework.core.exploit import (
    RemoteExploit,
    ExploitInfo,
    ExploitOption,
    ExploitResult,
    ExploitTarget,
    ExploitRank,
    Platform,
    TargetArch,
    PayloadType,
)
from python_framework.helpers.http_client import HttpExploitMixin


class {class_name}(RemoteExploit, HttpExploitMixin):
    \"\"\"Autogenerated exploit stub.\"\"\"

    def __init__(self):
        info = ExploitInfo(
            name="{name}",
            description="{description}",
            author=["{author}"],
            references={references},
            disclosure_date="{date}",
            rank=ExploitRank.NORMAL,
            platform=[Platform.LINUX],
            arch=[TargetArch.CMD],
            privileged=False,
            targets=[ExploitTarget(
                name="Automatic Target",
                platform=[Platform.LINUX],
                arch=[TargetArch.CMD],
                payload_type=PayloadType.UNIX_CMD
            )],
            default_target=0,
            notes={{"Stability": [], "Reliability": [], "SideEffects": []}},
        )
        super().__init__(info)
        self.register_options([
            ExploitOption("TARGETURI", True, "Base URI of the application", "{target_uri}", str),
            ExploitOption("CMD", False, "Command to execute", "id", str),
        ])

    def _path(self, path: str) -> str:
        base = self.get_option("TARGETURI", "/")
        return "/".join([base.rstrip("/"), path.lstrip("/")])

    def check(self) -> ExploitResult:
        try:
            res = self.http_get(self._path("index.php"))
        except Exception as exc:
            return ExploitResult(False, f"HTTP check failed: {{exc}}")
        if res.status_code != 200:
            return ExploitResult(False, f"Unexpected status code: {{res.status_code}}")
        return ExploitResult(True, "Host responded to probe")

    def exploit(self) -> ExploitResult:
        cmd = self.get_option("CMD", "id")
        try:
            res = self.http_post(self._path("command"), data={{"cmd": cmd}})
        except Exception as exc:
            return ExploitResult(False, f"Exploit request failed: {{exc}}")
        success = res.status_code in (200, 202, 204)
        return ExploitResult(success, f"Command submitted ({cmd})", {{"status": res.status_code}})


if __name__ == "__main__":
    exploit = {class_name}()
    result = exploit.run()
    status = "success" if result.success else "failure"
    print(f"[{{status}}] {{result.message}}")
"""


def normalize_class_name(name: str) -> str:
    """Convert a human-readable name into a valid class name."""
    cleaned = re.sub(r"[^A-Za-z0-9]+", " ", name).title().replace(" ", "")
    return cleaned if cleaned else "GeneratedExploit"


def write_template(path: str, content: str, force: bool) -> None:
    if os.path.exists(path) and not force:
        raise FileExistsError(f"{path} already exists (use --force to overwrite)")
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as handle:
        handle.write(content)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate a Python exploit skeleton")
    parser.add_argument("--name", required=True, help="Exploit name")
    parser.add_argument("--author", default="pf-user", help="Author name")
    parser.add_argument("--description", default="Autogenerated exploit skeleton", help="Description")
    parser.add_argument("--output", required=True, help="Output file path for the exploit")
    parser.add_argument("--target-uri", default="/", help="Default TARGETURI value")
    parser.add_argument("--references", default="", help="Comma-separated references")
    parser.add_argument("--date", default="2024-01-01", help="Disclosure date string")
    parser.add_argument("--force", action="store_true", help="Overwrite existing files")
    args = parser.parse_args()

    references = [ref.strip() for ref in args.references.split(",") if ref.strip()]
    class_name = normalize_class_name(args.name)
    content = TEMPLATE.format(
        name=args.name,
        description=args.description.replace('"', '\\"'),
        author=args.author,
        references=references,
        date=args.date,
        target_uri=args.target_uri,
        class_name=class_name,
    )
    write_template(args.output, dedent(content), args.force)
    print(f"[+] Wrote exploit skeleton to {args.output}")


if __name__ == "__main__":
    main()
