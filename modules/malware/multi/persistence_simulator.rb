##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Malware
  include Msf::Post::File
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Multi-Platform Persistence Simulator',
        'Description' => %q{
          This module simulates malware persistence mechanisms across multiple platforms.
          It creates temporary files, registry entries (Windows), and startup scripts
          that automatically clean up after a configurable time period. This is useful
          for penetration testing to demonstrate persistence without leaving permanent
          artifacts on the target system.
        },
        'License' => MSF_LICENSE,
        'Author' => ['Metasploit Framework Team'],
        'Platform' => ['win', 'unix', 'linux', 'osx'],
        'SessionTypes' => ['meterpreter', 'shell'],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options([
      OptBool.new('SIMULATE_STARTUP', [true, 'Simulate startup persistence', true]),
      OptBool.new('SIMULATE_SCHEDULED_TASK', [true, 'Simulate scheduled task creation', true]),
      OptBool.new('CREATE_FAKE_PROCESSES', [true, 'Create fake malware processes', false]),
      OptString.new('PERSISTENCE_NAME', [true, 'Name for persistence mechanism', 'SystemUpdate']),
    ])

    register_advanced_options([
      OptInt.new('ACTIVITY_INTERVAL', [true, 'Seconds between simulated activities', 30]),
      OptBool.new('VERBOSE_SIMULATION', [true, 'Show detailed simulation activities', true]),
    ])
  end

  def run_malware_simulation
    print_status("Starting multi-platform persistence simulation")
    print_status("Target platform: #{session.platform}")
    print_status("Session type: #{session.type}")

    # Platform-specific persistence simulation
    case session.platform
    when 'windows'
      simulate_windows_persistence
    when 'linux'
      simulate_linux_persistence
    when 'osx'
      simulate_osx_persistence
    else
      simulate_generic_persistence
    end

    # Common cross-platform activities
    simulate_common_activities

    print_good("Persistence simulation established - will auto-cleanup in #{time_remaining} seconds")
  end

  private

  def simulate_windows_persistence
    print_status("Simulating Windows-specific persistence mechanisms")

    # Simulate registry run key
    if datastore['SIMULATE_STARTUP']
      reg_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"
      reg_value = datastore['PERSISTENCE_NAME']
      fake_path = "C:\\Windows\\System32\\#{datastore['PERSISTENCE_NAME']}.exe"
      
      simulate_registry_persistence(reg_key, reg_value, fake_path)
    end

    # Simulate scheduled task
    if datastore['SIMULATE_SCHEDULED_TASK']
      simulate_scheduled_task_windows
    end

    # Create fake malware executable
    fake_exe_path = "C:\\temp\\#{datastore['PERSISTENCE_NAME']}.exe"
    simulate_file_drop(fake_exe_path, generate_fake_executable_content)
  end

  def simulate_linux_persistence
    print_status("Simulating Linux-specific persistence mechanisms")

    # Simulate crontab entry
    if datastore['SIMULATE_SCHEDULED_TASK']
      simulate_crontab_entry
    end

    # Simulate init script or systemd service
    if datastore['SIMULATE_STARTUP']
      simulate_linux_startup_script
    end

    # Create fake malware binary
    fake_bin_path = "/tmp/#{datastore['PERSISTENCE_NAME']}"
    simulate_file_drop(fake_bin_path, generate_fake_script_content)
  end

  def simulate_osx_persistence
    print_status("Simulating macOS-specific persistence mechanisms")

    # Simulate LaunchAgent
    if datastore['SIMULATE_STARTUP']
      simulate_launch_agent
    end

    # Create fake malware application
    fake_app_path = "/tmp/#{datastore['PERSISTENCE_NAME']}.app"
    simulate_file_drop(fake_app_path, generate_fake_script_content)
  end

  def simulate_generic_persistence
    print_status("Simulating generic persistence mechanisms")
    
    # Create basic persistence file
    persistence_file = "/tmp/#{datastore['PERSISTENCE_NAME']}_persistence"
    simulate_file_drop(persistence_file, generate_fake_script_content)
  end

  def simulate_scheduled_task_windows
    task_name = datastore['PERSISTENCE_NAME']
    
    if datastore['SIMULATE_ONLY']
      print_status("SIMULATION: Would create scheduled task '#{task_name}'")
      return
    end

    # Create a harmless scheduled task that will be cleaned up
    task_xml = generate_scheduled_task_xml(task_name)
    task_file = "C:\\temp\\#{task_name}_task.xml"
    
    simulate_file_drop(task_file, task_xml)
    
    if session.type == 'meterpreter'
      # Use meterpreter to create scheduled task
      print_status("Creating scheduled task via meterpreter")
    elsif session.type == 'shell'
      cmd = "schtasks /create /tn \"#{task_name}\" /xml \"#{task_file}\""
      session.shell_command_token(cmd)
    end

    register_artifact(task_name, :service)
    print_good("Created scheduled task: #{task_name}")
  end

  def simulate_crontab_entry
    if datastore['SIMULATE_ONLY']
      print_status("SIMULATION: Would add crontab entry")
      return
    end

    # Create a temporary crontab entry
    cron_entry = "*/5 * * * * /tmp/#{datastore['PERSISTENCE_NAME']} >/dev/null 2>&1"
    
    if session.type == 'shell'
      # Add to user's crontab
      session.shell_command_token("(crontab -l 2>/dev/null; echo '#{cron_entry}') | crontab -")
      print_good("Added crontab entry (will be cleaned up)")
      register_artifact("crontab_entry", :service)
    end
  end

  def simulate_linux_startup_script
    if datastore['SIMULATE_ONLY']
      print_status("SIMULATION: Would create startup script")
      return
    end

    # Create a fake init script
    script_path = "/tmp/#{datastore['PERSISTENCE_NAME']}_init"
    script_content = generate_init_script_content
    
    simulate_file_drop(script_path, script_content)
    
    # Make it executable
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{script_path}")
    end
  end

  def simulate_launch_agent
    if datastore['SIMULATE_ONLY']
      print_status("SIMULATION: Would create LaunchAgent")
      return
    end

    # Create a fake LaunchAgent plist
    plist_path = "/tmp/com.#{datastore['PERSISTENCE_NAME']}.plist"
    plist_content = generate_launch_agent_plist
    
    simulate_file_drop(plist_path, plist_content)
    print_good("Created LaunchAgent plist: #{plist_path}")
  end

  def simulate_common_activities
    print_status("Simulating common malware activities")
    
    activity_count = 0
    max_activities = (time_remaining / datastore['ACTIVITY_INTERVAL']).to_i

    while !should_terminate? && activity_count < max_activities
      activity_count += 1
      
      # Simulate various malware activities
      case rand(4)
      when 0
        simulate_network_beacon
      when 1
        simulate_file_enumeration
      when 2
        simulate_process_enumeration
      when 3
        simulate_system_information_gathering
      end

      # Wait for next activity or check for termination
      sleep_with_termination_check(datastore['ACTIVITY_INTERVAL'])
    end
  end

  def simulate_network_beacon
    return unless datastore['VERBOSE_SIMULATION']
    
    fake_c2_server = "#{rand(256)}.#{rand(256)}.#{rand(256)}.#{rand(256)}"
    print_status("SIMULATION: Beaconing to C2 server #{fake_c2_server}")
  end

  def simulate_file_enumeration
    return unless datastore['VERBOSE_SIMULATION']
    
    print_status("SIMULATION: Enumerating files in user directories")
  end

  def simulate_process_enumeration
    return unless datastore['VERBOSE_SIMULATION']
    
    print_status("SIMULATION: Enumerating running processes")
  end

  def simulate_system_information_gathering
    return unless datastore['VERBOSE_SIMULATION']
    
    print_status("SIMULATION: Gathering system information")
  end

  def sleep_with_termination_check(duration)
    start_time = Time.now
    while (Time.now - start_time) < duration
      return if should_terminate?
      sleep(1)
    end
  end

  def generate_fake_executable_content
    # Generate a harmless batch file that looks like malware
    content = <<~EOF
      @echo off
      REM Metasploit Malware Simulation - #{datastore['PERSISTENCE_NAME']}
      REM This is NOT real malware - penetration testing simulation only
      REM Created: #{Time.now}
      REM Will auto-cleanup in: #{time_remaining} seconds
      
      echo Malware simulation: #{datastore['PERSISTENCE_NAME']}
      echo This is a HARMLESS penetration testing simulation
      echo Time remaining: #{time_remaining} seconds
      
      timeout /t 5 /nobreak >nul
      exit /b 0
    EOF
    content
  end

  def generate_fake_script_content
    content = <<~EOF
      #!/bin/bash
      # Metasploit Malware Simulation - #{datastore['PERSISTENCE_NAME']}
      # This is NOT real malware - penetration testing simulation only
      # Created: #{Time.now}
      # Will auto-cleanup in: #{time_remaining} seconds
      
      echo "Malware simulation: #{datastore['PERSISTENCE_NAME']}"
      echo "This is a HARMLESS penetration testing simulation"
      echo "Time remaining: #{time_remaining} seconds"
      
      sleep 5
      exit 0
    EOF
    content
  end

  def generate_scheduled_task_xml(task_name)
    <<~EOF
      <?xml version="1.0" encoding="UTF-16"?>
      <Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
        <RegistrationInfo>
          <Description>Metasploit Malware Simulation - Will Auto-Cleanup</Description>
          <Author>Penetration Test</Author>
        </RegistrationInfo>
        <Triggers>
          <TimeTrigger>
            <StartBoundary>#{(Time.now + 3600).strftime('%Y-%m-%dT%H:%M:%S')}</StartBoundary>
            <Enabled>true</Enabled>
          </TimeTrigger>
        </Triggers>
        <Actions Context="Author">
          <Exec>
            <Command>cmd.exe</Command>
            <Arguments>/c echo "Malware simulation - harmless test"</Arguments>
          </Exec>
        </Actions>
      </Task>
    EOF
  end

  def generate_init_script_content
    <<~EOF
      #!/bin/bash
      # Metasploit Malware Simulation Init Script
      # This is NOT real malware - penetration testing simulation only
      
      case "$1" in
        start)
          echo "Starting malware simulation: #{datastore['PERSISTENCE_NAME']}"
          echo "This is a HARMLESS penetration testing simulation"
          ;;
        stop)
          echo "Stopping malware simulation: #{datastore['PERSISTENCE_NAME']}"
          ;;
        *)
          echo "Usage: $0 {start|stop}"
          exit 1
          ;;
      esac
      
      exit 0
    EOF
  end

  def generate_launch_agent_plist
    <<~EOF
      <?xml version="1.0" encoding="UTF-8"?>
      <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
      <plist version="1.0">
      <dict>
        <key>Label</key>
        <string>com.#{datastore['PERSISTENCE_NAME']}</string>
        <key>ProgramArguments</key>
        <array>
          <string>/bin/bash</string>
          <string>-c</string>
          <string>echo "Malware simulation - harmless test"</string>
        </array>
        <key>RunAtLoad</key>
        <true/>
        <key>StartInterval</key>
        <integer>3600</integer>
      </dict>
      </plist>
    EOF
  end

  # Override cleanup to handle platform-specific artifacts
  def cleanup_artifacts
    print_status("Cleaning up platform-specific persistence mechanisms")
    
    # Clean up scheduled tasks on Windows
    if session.platform == 'windows'
      cleanup_windows_artifacts
    elsif session.platform == 'linux'
      cleanup_linux_artifacts
    end

    # Call parent cleanup for files and other artifacts
    super
  end

  def cleanup_windows_artifacts
    # Remove scheduled task if created
    task_name = datastore['PERSISTENCE_NAME']
    
    if session.type == 'shell'
      session.shell_command_token("schtasks /delete /tn \"#{task_name}\" /f 2>nul")
      print_status("Removed scheduled task: #{task_name}")
    end
  end

  def cleanup_linux_artifacts
    # Remove crontab entry if created
    if session.type == 'shell'
      cron_pattern = datastore['PERSISTENCE_NAME']
      session.shell_command_token("crontab -l 2>/dev/null | grep -v '#{cron_pattern}' | crontab - 2>/dev/null")
      print_status("Removed crontab entries containing: #{cron_pattern}")
    end
  end

end