#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Multi-Platform Persistence Simulator

This module requires Metasploit: https://metasploit.com/download
Current source: https://github.com/rapid7/metasploit-framework

Converted from Ruby to Python as part of the Python migration initiative.
"""

import sys
import os
import time
import random
from typing import Optional

# Add python_framework to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../python_framework'))

from core.malware import Malware, ArtifactType


class PersistenceSimulator(Malware):
    """
    Multi-Platform Persistence Simulator
    
    This module simulates malware persistence mechanisms across multiple platforms.
    It creates temporary files, registry entries (Windows), and startup scripts
    that automatically clean up after a configurable time period. This is useful
    for penetration testing to demonstrate persistence without leaving permanent
    artifacts on the target system.
    """
    
    def __init__(self, session=None):
        super().__init__(session)
        
        # Module metadata
        self.info = {
            'Name': 'Multi-Platform Persistence Simulator',
            'Description': '''
                This module simulates malware persistence mechanisms across multiple platforms.
                It creates temporary files, registry entries (Windows), and startup scripts
                that automatically clean up after a configurable time period. This is useful
                for penetration testing to demonstrate persistence without leaving permanent
                artifacts on the target system.
            ''',
            'License': 'MSF_LICENSE',
            'Author': ['Metasploit Framework Team'],
            'Platform': ['win', 'unix', 'linux', 'osx'],
            'SessionTypes': ['meterpreter', 'shell'],
            'Notes': {
                'Stability': ['CRASH_SAFE'],
                'SideEffects': ['ARTIFACTS_ON_DISK', 'CONFIG_CHANGES'],
                'Reliability': ['REPEATABLE_SESSION']
            }
        }
        
        # Module options
        self.datastore.update({
            'SIMULATE_STARTUP': True,
            'SIMULATE_SCHEDULED_TASK': True,
            'CREATE_FAKE_PROCESSES': False,
            'PERSISTENCE_NAME': 'SystemUpdate',
            'ACTIVITY_INTERVAL': 30,
            'VERBOSE_SIMULATION': True,
        })
    
    def run_malware_simulation(self) -> None:
        """Main malware simulation execution"""
        self.print_status("Starting multi-platform persistence simulation")
        
        if self.session:
            platform = getattr(self.session, 'platform', 'unknown')
            session_type = getattr(self.session, 'type', 'unknown')
            self.print_status(f"Target platform: {platform}")
            self.print_status(f"Session type: {session_type}")
        else:
            platform = 'unknown'
            self.print_warning("No session available - running in standalone mode")
        
        # Platform-specific persistence simulation
        if platform == 'windows':
            self.simulate_windows_persistence()
        elif platform == 'linux':
            self.simulate_linux_persistence()
        elif platform == 'osx':
            self.simulate_osx_persistence()
        else:
            self.simulate_generic_persistence()
        
        # Common cross-platform activities
        self.simulate_common_activities()
        
        self.print_good(f"Persistence simulation established - will auto-cleanup in {self.time_remaining()} seconds")
    
    def simulate_windows_persistence(self) -> None:
        """Simulate Windows-specific persistence mechanisms"""
        self.print_status("Simulating Windows-specific persistence mechanisms")
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Simulate registry run key
        if self.datastore.get('SIMULATE_STARTUP', True):
            reg_key = r"HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run"
            reg_value = persistence_name
            fake_path = f"C:\\Windows\\System32\\{persistence_name}.exe"
            
            self.simulate_registry_persistence(reg_key, reg_value, fake_path)
        
        # Simulate scheduled task
        if self.datastore.get('SIMULATE_SCHEDULED_TASK', True):
            self.simulate_scheduled_task_windows()
        
        # Create fake malware executable
        fake_exe_path = f"C:\\temp\\{persistence_name}.exe"
        fake_content = self.generate_fake_executable_content()
        self.simulate_file_drop(fake_exe_path, fake_content)
    
    def simulate_linux_persistence(self) -> None:
        """Simulate Linux-specific persistence mechanisms"""
        self.print_status("Simulating Linux-specific persistence mechanisms")
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Simulate crontab entry
        if self.datastore.get('SIMULATE_SCHEDULED_TASK', True):
            self.simulate_crontab_entry()
        
        # Simulate init script or systemd service
        if self.datastore.get('SIMULATE_STARTUP', True):
            self.simulate_linux_startup_script()
        
        # Create fake malware binary
        fake_bin_path = f"/tmp/{persistence_name}"
        fake_content = self.generate_fake_script_content()
        self.simulate_file_drop(fake_bin_path, fake_content)
    
    def simulate_osx_persistence(self) -> None:
        """Simulate macOS-specific persistence mechanisms"""
        self.print_status("Simulating macOS-specific persistence mechanisms")
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Simulate LaunchAgent
        if self.datastore.get('SIMULATE_STARTUP', True):
            self.simulate_launch_agent()
        
        # Create fake malware application
        fake_app_path = f"/tmp/{persistence_name}.app"
        fake_content = self.generate_fake_script_content()
        self.simulate_file_drop(fake_app_path, fake_content)
    
    def simulate_generic_persistence(self) -> None:
        """Simulate generic persistence mechanisms"""
        self.print_status("Simulating generic persistence mechanisms")
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Create basic persistence file
        persistence_file = f"/tmp/{persistence_name}_persistence"
        fake_content = self.generate_fake_script_content()
        self.simulate_file_drop(persistence_file, fake_content)
    
    def simulate_scheduled_task_windows(self) -> None:
        """Simulate Windows scheduled task creation"""
        task_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status(f"SIMULATION: Would create scheduled task '{task_name}'")
            return
        
        # Create a harmless scheduled task that will be cleaned up
        task_xml = self.generate_scheduled_task_xml(task_name)
        task_file = f"C:\\temp\\{task_name}_task.xml"
        
        self.simulate_file_drop(task_file, task_xml)
        
        if self.session:
            session_type = getattr(self.session, 'type', None)
            
            if session_type == 'meterpreter':
                # Use meterpreter to create scheduled task
                self.print_status("Creating scheduled task via meterpreter")
            elif session_type == 'shell':
                cmd = f'schtasks /create /tn "{task_name}" /xml "{task_file}"'
                self.session.shell_command_token(cmd)
        
        self.register_artifact(task_name, ArtifactType.SERVICE)
        self.print_good(f"Created scheduled task: {task_name}")
    
    def simulate_crontab_entry(self) -> None:
        """Simulate crontab entry creation"""
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status("SIMULATION: Would add crontab entry")
            return
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Create a temporary crontab entry
        cron_entry = f"*/5 * * * * /tmp/{persistence_name} >/dev/null 2>&1"
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            # Add to user's crontab
            cmd = f"(crontab -l 2>/dev/null; echo '{cron_entry}') | crontab -"
            self.session.shell_command_token(cmd)
            self.print_good("Added crontab entry (will be cleaned up)")
            self.register_artifact("crontab_entry", ArtifactType.SERVICE)
    
    def simulate_linux_startup_script(self) -> None:
        """Simulate Linux startup script creation"""
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status("SIMULATION: Would create startup script")
            return
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Create a fake init script
        script_path = f"/tmp/{persistence_name}_init"
        script_content = self.generate_init_script_content()
        
        self.simulate_file_drop(script_path, script_content)
        
        # Make it executable
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {script_path}")
    
    def simulate_launch_agent(self) -> None:
        """Simulate macOS LaunchAgent creation"""
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status("SIMULATION: Would create LaunchAgent")
            return
        
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        # Create a fake LaunchAgent plist
        plist_path = f"/tmp/com.{persistence_name}.plist"
        plist_content = self.generate_launch_agent_plist()
        
        self.simulate_file_drop(plist_path, plist_content)
        self.print_good(f"Created LaunchAgent plist: {plist_path}")
    
    def simulate_common_activities(self) -> None:
        """Simulate common malware activities"""
        self.print_status("Simulating common malware activities")
        
        activity_count = 0
        activity_interval = self.datastore.get('ACTIVITY_INTERVAL', 30)
        max_activities = self.time_remaining() // activity_interval
        
        while not self.should_terminate() and activity_count < max_activities:
            activity_count += 1
            
            # Simulate various malware activities
            activity_type = random.randint(0, 3)
            if activity_type == 0:
                self.simulate_network_beacon()
            elif activity_type == 1:
                self.simulate_file_enumeration()
            elif activity_type == 2:
                self.simulate_process_enumeration()
            elif activity_type == 3:
                self.simulate_system_information_gathering()
            
            # Wait for next activity or check for termination
            self.sleep_with_termination_check(activity_interval)
    
    def simulate_network_beacon(self) -> None:
        """Simulate network beacon to C2 server"""
        if not self.datastore.get('VERBOSE_SIMULATION', True):
            return
        
        fake_c2_server = f"{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        self.print_status(f"SIMULATION: Beaconing to C2 server {fake_c2_server}")
    
    def simulate_file_enumeration(self) -> None:
        """Simulate file enumeration"""
        if not self.datastore.get('VERBOSE_SIMULATION', True):
            return
        
        self.print_status("SIMULATION: Enumerating files in user directories")
    
    def simulate_process_enumeration(self) -> None:
        """Simulate process enumeration"""
        if not self.datastore.get('VERBOSE_SIMULATION', True):
            return
        
        self.print_status("SIMULATION: Enumerating running processes")
    
    def simulate_system_information_gathering(self) -> None:
        """Simulate system information gathering"""
        if not self.datastore.get('VERBOSE_SIMULATION', True):
            return
        
        self.print_status("SIMULATION: Gathering system information")
    
    def sleep_with_termination_check(self, duration: int) -> None:
        """Sleep while checking for termination"""
        start_time = time.time()
        while (time.time() - start_time) < duration:
            if self.should_terminate():
                return
            time.sleep(1)
    
    def generate_fake_executable_content(self) -> str:
        """Generate fake executable content (batch file)"""
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        content = f"""@echo off
REM Metasploit Malware Simulation - {persistence_name}
REM This is NOT real malware - penetration testing simulation only
REM Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
REM Will auto-cleanup in: {self.time_remaining()} seconds

echo Malware simulation: {persistence_name}
echo This is a HARMLESS penetration testing simulation
echo Time remaining: {self.time_remaining()} seconds

timeout /t 5 /nobreak >nul
exit /b 0
"""
        return content
    
    def generate_fake_script_content(self) -> str:
        """Generate fake script content (bash)"""
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        content = f"""#!/bin/bash
# Metasploit Malware Simulation - {persistence_name}
# This is NOT real malware - penetration testing simulation only
# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
# Will auto-cleanup in: {self.time_remaining()} seconds

echo "Malware simulation: {persistence_name}"
echo "This is a HARMLESS penetration testing simulation"
echo "Time remaining: {self.time_remaining()} seconds"

sleep 5
exit 0
"""
        return content
    
    def generate_scheduled_task_xml(self, task_name: str) -> str:
        """Generate Windows scheduled task XML"""
        import datetime
        start_time = (datetime.datetime.now() + datetime.timedelta(hours=1)).strftime('%Y-%m-%dT%H:%M:%S')
        
        xml = f"""<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <RegistrationInfo>
    <Description>Metasploit Malware Simulation - Will Auto-Cleanup</Description>
    <Author>Penetration Test</Author>
  </RegistrationInfo>
  <Triggers>
    <TimeTrigger>
      <StartBoundary>{start_time}</StartBoundary>
      <Enabled>true</Enabled>
    </TimeTrigger>
  </Triggers>
  <Actions Context="Author">
    <Exec>
      <Command>cmd.exe</Command>
      <Arguments>/c echo "Malware simulation - harmless test"</Arguments>
    </Exec>
  </Actions>
</Task>
"""
        return xml
    
    def generate_init_script_content(self) -> str:
        """Generate init script content"""
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        content = f"""#!/bin/bash
# Metasploit Malware Simulation Init Script
# This is NOT real malware - penetration testing simulation only

case "$1" in
  start)
    echo "Starting malware simulation: {persistence_name}"
    echo "This is a HARMLESS penetration testing simulation"
    ;;
  stop)
    echo "Stopping malware simulation: {persistence_name}"
    ;;
  *)
    echo "Usage: $0 {{start|stop}}"
    exit 1
    ;;
esac

exit 0
"""
        return content
    
    def generate_launch_agent_plist(self) -> str:
        """Generate macOS LaunchAgent plist"""
        persistence_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        plist = f"""<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key>
  <string>com.{persistence_name}</string>
  <key>ProgramArguments</key>
  <array>
    <string>/bin/bash</string>
    <string>-c</string>
    <string>echo "Malware simulation - harmless test"</string>
  </array>
  <key>RunAtLoad</key>
  <true/>
  <key>StartInterval</key>
  <integer>3600</integer>
</dict>
</plist>
"""
        return plist
    
    def cleanup_artifacts(self) -> None:
        """Override cleanup to handle platform-specific artifacts"""
        self.print_status("Cleaning up platform-specific persistence mechanisms")
        
        if self.session:
            platform = getattr(self.session, 'platform', 'unknown')
            
            # Clean up scheduled tasks on Windows
            if platform == 'windows':
                self.cleanup_windows_artifacts()
            elif platform == 'linux':
                self.cleanup_linux_artifacts()
        
        # Call parent cleanup for files and other artifacts
        super().cleanup_artifacts()
    
    def cleanup_windows_artifacts(self) -> None:
        """Clean up Windows-specific artifacts"""
        # Remove scheduled task if created
        task_name = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f'schtasks /delete /tn "{task_name}" /f 2>nul')
            self.print_status(f"Removed scheduled task: {task_name}")
    
    def cleanup_linux_artifacts(self) -> None:
        """Clean up Linux-specific artifacts"""
        # Remove crontab entry if created
        if self.session and getattr(self.session, 'type', None) == 'shell':
            cron_pattern = self.datastore.get('PERSISTENCE_NAME', 'SystemUpdate')
            cmd = f"crontab -l 2>/dev/null | grep -v '{cron_pattern}' | crontab - 2>/dev/null"
            self.session.shell_command_token(cmd)
            self.print_status(f"Removed crontab entries containing: {cron_pattern}")


def main():
    """Standalone execution for testing"""
    import logging
    logging.basicConfig(level=logging.INFO)
    
    # Create simulator without session for testing
    simulator = PersistenceSimulator(session=None)
    
    # Run simulation
    try:
        simulator.run()
    except KeyboardInterrupt:
        print("\n[!] Simulation interrupted by user")
        simulator.cleanup_artifacts()


if __name__ == '__main__':
    main()
