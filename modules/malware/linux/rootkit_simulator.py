#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Linux Rootkit Simulator

This module requires Metasploit: https://metasploit.com/download
Current source: https://github.com/rapid7/metasploit-framework

Converted from Ruby to Python as part of the Python migration initiative.
"""

import sys
import os
import time
import random
from typing import List, Dict, Any

# Add python_framework to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../python_framework'))

from core.malware import Malware, ArtifactType


class RootkitSimulator(Malware):
    """
    Linux Rootkit Simulator
    
    This module simulates common Linux rootkit techniques including
    process hiding, file hiding, network connection hiding, and
    system call hooking simulation. It demonstrates how malware
    achieves persistence and stealth on Linux systems while
    maintaining complete safety through time bomb functionality.
    """
    
    def __init__(self, session=None):
        super().__init__(session)
        
        # Module metadata
        self.info = {
            'Name': 'Linux Rootkit Simulator',
            'Description': '''
                This module simulates common Linux rootkit techniques including
                process hiding, file hiding, network connection hiding, and
                system call hooking simulation. It demonstrates how malware
                achieves persistence and stealth on Linux systems while
                maintaining complete safety through time bomb functionality.
            ''',
            'License': 'MSF_LICENSE',
            'Author': ['Metasploit Framework Team'],
            'Platform': ['linux'],
            'SessionTypes': ['meterpreter', 'shell'],
            'Notes': {
                'Stability': ['CRASH_SAFE'],
                'SideEffects': ['ARTIFACTS_ON_DISK', 'CONFIG_CHANGES'],
                'Reliability': ['REPEATABLE_SESSION']
            }
        }
        
        # Module options
        self.datastore.update({
            'SIMULATE_PROCESS_HIDING': True,
            'SIMULATE_FILE_HIDING': True,
            'SIMULATE_NETWORK_HIDING': True,
            'SIMULATE_LOG_EVASION': True,
            'SIMULATE_KERNEL_MODULE': False,
            'HIDDEN_PROCESS_NAME': 'kworker_sim',
            'CREATE_FAKE_BINARIES': True,
            'ROOTKIT_DIR': '/tmp/.hidden_rk',
        })
    
    def run_malware_simulation(self) -> None:
        """Main malware simulation execution"""
        self.print_status("Starting Linux rootkit simulation")
        
        # Verify we're on Linux
        if self.session:
            platform = getattr(self.session, 'platform', 'unknown')
            if platform != 'linux':
                self.print_error("This module only works on Linux platforms")
                return
        else:
            self.print_warning("No session available - running in standalone mode")
        
        # Create hidden rootkit directory
        self.setup_rootkit_environment()
        
        # Perform various rootkit simulations
        if self.datastore.get('SIMULATE_PROCESS_HIDING', True):
            self.simulate_process_hiding()
        
        if self.datastore.get('SIMULATE_FILE_HIDING', True):
            self.simulate_file_hiding()
        
        if self.datastore.get('SIMULATE_NETWORK_HIDING', True):
            self.simulate_network_hiding()
        
        if self.datastore.get('SIMULATE_LOG_EVASION', True):
            self.simulate_log_evasion()
        
        if self.datastore.get('SIMULATE_KERNEL_MODULE', False):
            self.simulate_kernel_module_loading()
        
        # Maintain rootkit simulation
        self.maintain_rootkit_simulation()
        
        self.print_good(f"Rootkit simulation active - will auto-cleanup in {self.time_remaining()} seconds")
    
    def setup_rootkit_environment(self) -> None:
        """Setup rootkit simulation environment"""
        self.print_status("Setting up rootkit simulation environment")
        
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        
        # Create hidden directory
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"mkdir -p {rootkit_dir}")
            self.session.shell_command_token(f"chmod 700 {rootkit_dir}")
        
        self.register_artifact(rootkit_dir, ArtifactType.DIRECTORY)
        
        # Create fake rootkit components
        if self.datastore.get('CREATE_FAKE_BINARIES', True):
            self.create_fake_rootkit_binaries(rootkit_dir)
        
        self.print_good(f"Rootkit environment created at: {rootkit_dir}")
    
    def create_fake_rootkit_binaries(self, rootkit_dir: str) -> None:
        """Create fake rootkit binaries"""
        self.print_status("Creating fake rootkit binaries")
        
        # Create fake kernel module
        fake_ko_path = f"{rootkit_dir}/rootkit_sim.ko"
        fake_ko_content = self.generate_fake_kernel_module_content()
        self.simulate_file_drop(fake_ko_path, fake_ko_content)
        
        # Create fake system binary replacements
        fake_binaries = ['ps', 'netstat', 'ls', 'lsof']
        
        for binary in fake_binaries:
            fake_binary_path = f"{rootkit_dir}/{binary}"
            fake_binary_content = self.generate_fake_binary_content(binary)
            self.simulate_file_drop(fake_binary_path, fake_binary_content)
            
            # Make executable
            if self.session and getattr(self.session, 'type', None) == 'shell':
                self.session.shell_command_token(f"chmod +x {fake_binary_path}")
    
    def simulate_process_hiding(self) -> None:
        """Simulate process hiding techniques"""
        self.print_status("Simulating process hiding techniques")
        
        hidden_process = self.datastore.get('HIDDEN_PROCESS_NAME', 'kworker_sim')
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        
        # Create fake hidden process script
        hidden_process_path = f"{rootkit_dir}/{hidden_process}"
        process_content = self.generate_hidden_process_content(hidden_process)
        self.simulate_file_drop(hidden_process_path, process_content)
        
        # Make executable and start background process
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {hidden_process_path}")
            self.session.shell_command_token(f"nohup {hidden_process_path} >/dev/null 2>&1 &")
        
        self.register_artifact(hidden_process, ArtifactType.PROCESS)
        self.print_good(f"Simulated hidden process: {hidden_process}")
        
        # Simulate process hiding by creating fake ps replacement
        self.simulate_ps_replacement(rootkit_dir, hidden_process)
    
    def simulate_file_hiding(self) -> None:
        """Simulate file hiding techniques"""
        self.print_status("Simulating file hiding techniques")
        
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        
        # Create files that would be hidden by rootkit
        hidden_files = ['.rootkit_config', '.malware_data', '.stolen_creds']
        
        for filename in hidden_files:
            hidden_file_path = f"{rootkit_dir}/{filename}"
            hidden_content = self.generate_hidden_file_content(filename)
            self.simulate_file_drop(hidden_file_path, hidden_content)
        
        # Simulate ls replacement that hides files
        self.simulate_ls_replacement(rootkit_dir)
        
        self.print_good(f"Simulated file hiding for {len(hidden_files)} files")
    
    def simulate_network_hiding(self) -> None:
        """Simulate network connection hiding"""
        self.print_status("Simulating network connection hiding")
        
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        
        # Simulate hidden network connections
        hidden_connections = [
            {'ip': '192.168.1.100', 'port': '4444', 'type': 'C2'},
            {'ip': '10.0.0.50', 'port': '8080', 'type': 'Data Exfil'},
            {'ip': '172.16.0.10', 'port': '443', 'type': 'Backdoor'}
        ]
        
        for conn in hidden_connections:
            self.print_status(f"SIMULATION: Hidden {conn['type']} connection to {conn['ip']}:{conn['port']}")
        
        # Create fake netstat replacement
        self.simulate_netstat_replacement(rootkit_dir, hidden_connections)
        
        self.print_good("Simulated network connection hiding")
    
    def simulate_log_evasion(self) -> None:
        """Simulate log evasion techniques"""
        self.print_status("Simulating log evasion techniques")
        
        # Simulate log file manipulation
        log_files = ['/var/log/auth.log', '/var/log/syslog', '/var/log/messages']
        
        for log_file in log_files:
            self.print_status(f"SIMULATION: Would manipulate {log_file}")
            self.print_status("SIMULATION: Removing traces of malicious activity")
        
        # Create fake log cleaning script
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        log_cleaner_path = f"{rootkit_dir}/log_cleaner.sh"
        log_cleaner_content = self.generate_log_cleaner_content()
        self.simulate_file_drop(log_cleaner_path, log_cleaner_content)
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {log_cleaner_path}")
        
        self.print_good("Simulated log evasion techniques")
    
    def simulate_kernel_module_loading(self) -> None:
        """Simulate kernel module loading"""
        self.print_status("Simulating kernel module loading")
        
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status("SIMULATION: Would load malicious kernel module")
            self.print_warning("SIMULATION: Kernel module would provide ring-0 access")
            return
        
        rootkit_dir = self.datastore.get('ROOTKIT_DIR', '/tmp/.hidden_rk')
        fake_module_path = f"{rootkit_dir}/rootkit_sim.ko"
        
        # Simulate insmod command (but don't actually load anything)
        self.print_status(f"SIMULATION: insmod {fake_module_path}")
        self.print_status("SIMULATION: Kernel module would hook system calls")
        self.print_status("SIMULATION: Would hide processes, files, and network connections")
        
        self.print_good("Simulated kernel module loading")
    
    def simulate_ps_replacement(self, rootkit_dir: str, hidden_process: str) -> None:
        """Create fake ps binary that hides processes"""
        fake_ps_path = f"{rootkit_dir}/ps"
        ps_content = self.generate_fake_ps_content(hidden_process)
        self.simulate_file_drop(fake_ps_path, ps_content)
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {fake_ps_path}")
        
        self.print_status(f"Created fake ps binary that hides: {hidden_process}")
    
    def simulate_ls_replacement(self, rootkit_dir: str) -> None:
        """Create fake ls binary that hides files"""
        fake_ls_path = f"{rootkit_dir}/ls"
        ls_content = self.generate_fake_ls_content()
        self.simulate_file_drop(fake_ls_path, ls_content)
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {fake_ls_path}")
        
        self.print_status("Created fake ls binary that hides rootkit files")
    
    def simulate_netstat_replacement(self, rootkit_dir: str, hidden_connections: List[Dict[str, str]]) -> None:
        """Create fake netstat binary that hides connections"""
        fake_netstat_path = f"{rootkit_dir}/netstat"
        netstat_content = self.generate_fake_netstat_content(hidden_connections)
        self.simulate_file_drop(fake_netstat_path, netstat_content)
        
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"chmod +x {fake_netstat_path}")
        
        self.print_status("Created fake netstat binary that hides connections")
    
    def maintain_rootkit_simulation(self) -> None:
        """Maintain rootkit simulation"""
        self.print_status("Maintaining rootkit simulation")
        
        activity_count = 0
        
        while not self.should_terminate():
            activity_count += 1
            
            # Simulate periodic rootkit activities
            activity_type = activity_count % 5
            if activity_type == 0:
                self.simulate_stealth_check()
            elif activity_type == 1:
                self.simulate_data_collection()
            elif activity_type == 2:
                self.simulate_c2_communication()
            elif activity_type == 3:
                self.simulate_privilege_escalation_attempt()
            elif activity_type == 4:
                self.simulate_lateral_movement_scan()
            
            # Check for termination every 15 seconds
            self.sleep_with_termination_check(15)
    
    def simulate_stealth_check(self) -> None:
        """Simulate stealth check"""
        self.print_status("SIMULATION: Performing stealth check")
        self.print_status("SIMULATION: Verifying process hiding is active")
        self.print_status("SIMULATION: Checking for security tools")
    
    def simulate_data_collection(self) -> None:
        """Simulate data collection"""
        self.print_status("SIMULATION: Collecting sensitive data")
        self.print_status("SIMULATION: Scanning for SSH keys")
        self.print_status("SIMULATION: Looking for configuration files")
        self.print_status("SIMULATION: Harvesting user credentials")
    
    def simulate_c2_communication(self) -> None:
        """Simulate C2 communication"""
        self.print_status("SIMULATION: Communicating with C2 server")
        fake_c2 = f"{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}.{random.randint(0, 255)}"
        self.print_status(f"SIMULATION: Beaconing to {fake_c2}:443")
        self.print_status("SIMULATION: Uploading collected data")
    
    def simulate_privilege_escalation_attempt(self) -> None:
        """Simulate privilege escalation attempt"""
        self.print_status("SIMULATION: Attempting privilege escalation")
        self.print_status("SIMULATION: Checking for SUID binaries")
        self.print_status("SIMULATION: Looking for kernel exploits")
        self.print_status("SIMULATION: Attempting sudo abuse")
    
    def simulate_lateral_movement_scan(self) -> None:
        """Simulate lateral movement scan"""
        self.print_status("SIMULATION: Scanning for lateral movement opportunities")
        self.print_status("SIMULATION: Enumerating network hosts")
        self.print_status("SIMULATION: Checking for shared credentials")
        self.print_status("SIMULATION: Looking for accessible services")
    
    def sleep_with_termination_check(self, duration: int) -> None:
        """Sleep while checking for termination"""
        start_time = time.time()
        while (time.time() - start_time) < duration:
            if self.should_terminate():
                return
            time.sleep(1)
    
    # Content generation methods
    def generate_fake_kernel_module_content(self) -> str:
        """Generate fake kernel module content"""
        content = f"""// Fake Kernel Module - Metasploit Malware Simulation
// This is NOT a real kernel module - it's a harmless text file
// Created for penetration testing simulation only
// Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
// Will auto-cleanup in: {self.time_remaining()} seconds

// In a real rootkit, this would be compiled kernel code
// that hooks system calls to hide processes, files, etc.

#include <linux/module.h>
#include <linux/kernel.h>

static int __init rootkit_init(void) {{
    printk(KERN_INFO "Rootkit simulation loaded\\n");
    return 0;
}}

static void __exit rootkit_exit(void) {{
    printk(KERN_INFO "Rootkit simulation unloaded\\n");
}}

module_init(rootkit_init);
module_exit(rootkit_exit);
MODULE_LICENSE("GPL");
MODULE_DESCRIPTION("Metasploit Rootkit Simulation");
"""
        return content
    
    def generate_fake_binary_content(self, binary_name: str) -> str:
        """Generate fake binary content"""
        content = f"""#!/bin/bash
# Fake {binary_name} - Metasploit Malware Simulation
# This is NOT the real {binary_name} - it's a simulation
# Created for penetration testing demonstration only
# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
# Will auto-cleanup in: {self.time_remaining()} seconds

echo "Rootkit simulation: fake {binary_name} called"
echo "This would hide malicious activity in a real attack"
echo "Arguments: $@"

# Call the real binary but filter out hidden items
/bin/{binary_name} "$@" 2>/dev/null || /usr/bin/{binary_name} "$@" 2>/dev/null

exit 0
"""
        return content
    
    def generate_hidden_process_content(self, process_name: str) -> str:
        """Generate hidden process content"""
        content = f"""#!/bin/bash
# Hidden Process - Metasploit Malware Simulation
# This simulates a hidden malware process
# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
# Will auto-cleanup in: {self.time_remaining()} seconds

echo "Hidden process {process_name} started (PID: $$)"
echo "This is a HARMLESS penetration testing simulation"

# Simulate malware process behavior
while true; do
    sleep 30
    echo "$(date): Hidden process {process_name} heartbeat"
done
"""
        return content
    
    def generate_hidden_file_content(self, filename: str) -> str:
        """Generate hidden file content"""
        content = f"""# Hidden File: {filename}
# Metasploit Malware Simulation
# This file would be hidden by rootkit in a real attack
# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
# Will auto-cleanup in: {self.time_remaining()} seconds

[SIMULATION DATA]
This file contains simulated malware data
In a real attack, this might contain:
- Stolen credentials
- Configuration data
- Collected system information
- C2 server details

Time remaining: {self.time_remaining()} seconds
"""
        return content
    
    def generate_fake_ps_content(self, hidden_process: str) -> str:
        """Generate fake ps content"""
        content = f"""#!/bin/bash
# Fake ps command that hides specific processes
# Metasploit Malware Simulation

# Call real ps and filter out hidden process
/bin/ps "$@" | grep -v "{hidden_process}" | grep -v "rootkit_sim"
"""
        return content
    
    def generate_fake_ls_content(self) -> str:
        """Generate fake ls content"""
        content = """#!/bin/bash
# Fake ls command that hides rootkit files
# Metasploit Malware Simulation

# Call real ls and filter out hidden files
/bin/ls "$@" | grep -v "rootkit" | grep -v "malware" | grep -v ".hidden"
"""
        return content
    
    def generate_fake_netstat_content(self, hidden_connections: List[Dict[str, str]]) -> str:
        """Generate fake netstat content"""
        hidden_ports = '|'.join([conn['port'] for conn in hidden_connections])
        
        content = f"""#!/bin/bash
# Fake netstat command that hides malicious connections
# Metasploit Malware Simulation

# Call real netstat and filter out hidden connections
/bin/netstat "$@" | grep -vE ":({hidden_ports})\\b"
"""
        return content
    
    def generate_log_cleaner_content(self) -> str:
        """Generate log cleaner content"""
        content = f"""#!/bin/bash
# Log Cleaner - Metasploit Malware Simulation
# This simulates log cleaning techniques used by malware
# Created: {time.strftime('%Y-%m-%d %H:%M:%S')}

echo "Log cleaner simulation started"
echo "This would remove traces of malicious activity"
echo "Target log files: /var/log/auth.log, /var/log/syslog"
echo "SIMULATION ONLY - no actual log modification"

# In a real attack, this would:
# - Remove specific log entries
# - Clear command history
# - Modify timestamps
# - Disable logging temporarily

echo "Log cleaning simulation complete"
"""
        return content
    
    def cleanup_artifacts(self) -> None:
        """Override cleanup to handle Linux-specific artifacts"""
        self.print_status("Cleaning up Linux rootkit simulation artifacts")
        
        # Kill hidden processes
        hidden_process = self.datastore.get('HIDDEN_PROCESS_NAME', 'kworker_sim')
        if self.session and getattr(self.session, 'type', None) == 'shell':
            self.session.shell_command_token(f"pkill -f {hidden_process} 2>/dev/null")
            self.print_status(f"Terminated hidden processes: {hidden_process}")
        
        # Call parent cleanup for files and directories
        super().cleanup_artifacts()


def main():
    """Standalone execution for testing"""
    import logging
    logging.basicConfig(level=logging.INFO)
    
    # Create simulator without session for testing
    simulator = RootkitSimulator(session=None)
    
    # Run simulation
    try:
        simulator.run()
    except KeyboardInterrupt:
        print("\n[!] Simulation interrupted by user")
        simulator.cleanup_artifacts()


if __name__ == '__main__':
    main()
