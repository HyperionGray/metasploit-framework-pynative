##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Malware
  include Msf::Post::File
  include Msf::Post::Linux::System
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Linux Rootkit Simulator',
        'Description' => %q{
          This module simulates common Linux rootkit techniques including
          process hiding, file hiding, network connection hiding, and
          system call hooking simulation. It demonstrates how malware
          achieves persistence and stealth on Linux systems while
          maintaining complete safety through time bomb functionality.
        },
        'License' => MSF_LICENSE,
        'Author' => ['Metasploit Framework Team'],
        'Platform' => ['linux'],
        'SessionTypes' => ['meterpreter', 'shell'],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options([
      OptBool.new('SIMULATE_PROCESS_HIDING', [true, 'Simulate process hiding techniques', true]),
      OptBool.new('SIMULATE_FILE_HIDING', [true, 'Simulate file hiding techniques', true]),
      OptBool.new('SIMULATE_NETWORK_HIDING', [true, 'Simulate network connection hiding', true]),
      OptBool.new('SIMULATE_LOG_EVASION', [true, 'Simulate log evasion techniques', true]),
      OptBool.new('SIMULATE_KERNEL_MODULE', [true, 'Simulate kernel module loading', false]),
      OptString.new('HIDDEN_PROCESS_NAME', [true, 'Name for hidden process simulation', 'kworker_sim']),
    ])

    register_advanced_options([
      OptBool.new('CREATE_FAKE_BINARIES', [true, 'Create fake system binaries', true]),
      OptString.new('ROOTKIT_DIR', [true, 'Directory for rootkit files', '/tmp/.hidden_rk']),
    ])
  end

  def run_malware_simulation
    print_status("Starting Linux rootkit simulation")
    
    # Verify we're on Linux
    unless session.platform == 'linux'
      print_error("This module only works on Linux platforms")
      return
    end

    # Create hidden rootkit directory
    setup_rootkit_environment

    # Perform various rootkit simulations
    simulate_process_hiding if datastore['SIMULATE_PROCESS_HIDING']
    simulate_file_hiding if datastore['SIMULATE_FILE_HIDING']
    simulate_network_hiding if datastore['SIMULATE_NETWORK_HIDING']
    simulate_log_evasion if datastore['SIMULATE_LOG_EVASION']
    simulate_kernel_module_loading if datastore['SIMULATE_KERNEL_MODULE']

    # Maintain rootkit simulation
    maintain_rootkit_simulation

    print_good("Rootkit simulation active - will auto-cleanup in #{time_remaining} seconds")
  end

  private

  def setup_rootkit_environment
    print_status("Setting up rootkit simulation environment")
    
    rootkit_dir = datastore['ROOTKIT_DIR']
    
    # Create hidden directory
    if session.type == 'shell'
      session.shell_command_token("mkdir -p #{rootkit_dir}")
      session.shell_command_token("chmod 700 #{rootkit_dir}")
    end
    
    register_artifact(rootkit_dir, :directory)
    
    # Create fake rootkit components
    if datastore['CREATE_FAKE_BINARIES']
      create_fake_rootkit_binaries(rootkit_dir)
    end
    
    print_good("Rootkit environment created at: #{rootkit_dir}")
  end

  def create_fake_rootkit_binaries(rootkit_dir)
    print_status("Creating fake rootkit binaries")
    
    # Create fake kernel module
    fake_ko_path = "#{rootkit_dir}/rootkit_sim.ko"
    fake_ko_content = generate_fake_kernel_module_content
    simulate_file_drop(fake_ko_path, fake_ko_content)
    
    # Create fake system binary replacements
    fake_binaries = ['ps', 'netstat', 'ls', 'lsof']
    
    fake_binaries.each do |binary|
      fake_binary_path = "#{rootkit_dir}/#{binary}"
      fake_binary_content = generate_fake_binary_content(binary)
      simulate_file_drop(fake_binary_path, fake_binary_content)
      
      # Make executable
      if session.type == 'shell'
        session.shell_command_token("chmod +x #{fake_binary_path}")
      end
    end
  end

  def simulate_process_hiding
    print_status("Simulating process hiding techniques")
    
    hidden_process = datastore['HIDDEN_PROCESS_NAME']
    rootkit_dir = datastore['ROOTKIT_DIR']
    
    # Create fake hidden process script
    hidden_process_path = "#{rootkit_dir}/#{hidden_process}"
    process_content = generate_hidden_process_content(hidden_process)
    simulate_file_drop(hidden_process_path, process_content)
    
    # Make executable and start background process
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{hidden_process_path}")
      session.shell_command_token("nohup #{hidden_process_path} >/dev/null 2>&1 &")
    end
    
    register_artifact(hidden_process, :process)
    print_good("Simulated hidden process: #{hidden_process}")
    
    # Simulate process hiding by creating fake ps replacement
    simulate_ps_replacement(rootkit_dir, hidden_process)
  end

  def simulate_file_hiding
    print_status("Simulating file hiding techniques")
    
    rootkit_dir = datastore['ROOTKIT_DIR']
    
    # Create files that would be hidden by rootkit
    hidden_files = ['.rootkit_config', '.malware_data', '.stolen_creds']
    
    hidden_files.each do |filename|
      hidden_file_path = "#{rootkit_dir}/#{filename}"
      hidden_content = generate_hidden_file_content(filename)
      simulate_file_drop(hidden_file_path, hidden_content)
    end
    
    # Simulate ls replacement that hides files
    simulate_ls_replacement(rootkit_dir)
    
    print_good("Simulated file hiding for #{hidden_files.length} files")
  end

  def simulate_network_hiding
    print_status("Simulating network connection hiding")
    
    rootkit_dir = datastore['ROOTKIT_DIR']
    
    # Simulate hidden network connections
    hidden_connections = [
      { ip: "192.168.1.100", port: "4444", type: "C2" },
      { ip: "10.0.0.50", port: "8080", type: "Data Exfil" },
      { ip: "172.16.0.10", port: "443", type: "Backdoor" }
    ]
    
    hidden_connections.each do |conn|
      print_status("SIMULATION: Hidden #{conn[:type]} connection to #{conn[:ip]}:#{conn[:port]}")
    end
    
    # Create fake netstat replacement
    simulate_netstat_replacement(rootkit_dir, hidden_connections)
    
    print_good("Simulated network connection hiding")
  end

  def simulate_log_evasion
    print_status("Simulating log evasion techniques")
    
    # Simulate log file manipulation
    log_files = ['/var/log/auth.log', '/var/log/syslog', '/var/log/messages']
    
    log_files.each do |log_file|
      print_status("SIMULATION: Would manipulate #{log_file}")
      print_status("SIMULATION: Removing traces of malicious activity")
    end
    
    # Create fake log cleaning script
    rootkit_dir = datastore['ROOTKIT_DIR']
    log_cleaner_path = "#{rootkit_dir}/log_cleaner.sh"
    log_cleaner_content = generate_log_cleaner_content
    simulate_file_drop(log_cleaner_path, log_cleaner_content)
    
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{log_cleaner_path}")
    end
    
    print_good("Simulated log evasion techniques")
  end

  def simulate_kernel_module_loading
    print_status("Simulating kernel module loading")
    
    if datastore['SIMULATE_ONLY']
      print_status("SIMULATION: Would load malicious kernel module")
      print_warning("SIMULATION: Kernel module would provide ring-0 access")
      return
    end
    
    rootkit_dir = datastore['ROOTKIT_DIR']
    fake_module_path = "#{rootkit_dir}/rootkit_sim.ko"
    
    # Simulate insmod command (but don't actually load anything)
    print_status("SIMULATION: insmod #{fake_module_path}")
    print_status("SIMULATION: Kernel module would hook system calls")
    print_status("SIMULATION: Would hide processes, files, and network connections")
    
    print_good("Simulated kernel module loading")
  end

  def simulate_ps_replacement(rootkit_dir, hidden_process)
    fake_ps_path = "#{rootkit_dir}/ps"
    ps_content = generate_fake_ps_content(hidden_process)
    simulate_file_drop(fake_ps_path, ps_content)
    
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{fake_ps_path}")
    end
    
    print_status("Created fake ps binary that hides: #{hidden_process}")
  end

  def simulate_ls_replacement(rootkit_dir)
    fake_ls_path = "#{rootkit_dir}/ls"
    ls_content = generate_fake_ls_content
    simulate_file_drop(fake_ls_path, ls_content)
    
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{fake_ls_path}")
    end
    
    print_status("Created fake ls binary that hides rootkit files")
  end

  def simulate_netstat_replacement(rootkit_dir, hidden_connections)
    fake_netstat_path = "#{rootkit_dir}/netstat"
    netstat_content = generate_fake_netstat_content(hidden_connections)
    simulate_file_drop(fake_netstat_path, netstat_content)
    
    if session.type == 'shell'
      session.shell_command_token("chmod +x #{fake_netstat_path}")
    end
    
    print_status("Created fake netstat binary that hides connections")
  end

  def maintain_rootkit_simulation
    print_status("Maintaining rootkit simulation")
    
    activity_count = 0
    
    while !should_terminate?
      activity_count += 1
      
      # Simulate periodic rootkit activities
      case activity_count % 5
      when 0
        simulate_stealth_check
      when 1
        simulate_data_collection
      when 2
        simulate_c2_communication
      when 3
        simulate_privilege_escalation_attempt
      when 4
        simulate_lateral_movement_scan
      end
      
      # Check for termination every 15 seconds
      sleep_with_termination_check(15)
    end
  end

  def simulate_stealth_check
    print_status("SIMULATION: Performing stealth check")
    print_status("SIMULATION: Verifying process hiding is active")
    print_status("SIMULATION: Checking for security tools")
  end

  def simulate_data_collection
    print_status("SIMULATION: Collecting sensitive data")
    print_status("SIMULATION: Scanning for SSH keys")
    print_status("SIMULATION: Looking for configuration files")
    print_status("SIMULATION: Harvesting user credentials")
  end

  def simulate_c2_communication
    print_status("SIMULATION: Communicating with C2 server")
    fake_c2 = "#{rand(256)}.#{rand(256)}.#{rand(256)}.#{rand(256)}"
    print_status("SIMULATION: Beaconing to #{fake_c2}:443")
    print_status("SIMULATION: Uploading collected data")
  end

  def simulate_privilege_escalation_attempt
    print_status("SIMULATION: Attempting privilege escalation")
    print_status("SIMULATION: Checking for SUID binaries")
    print_status("SIMULATION: Looking for kernel exploits")
    print_status("SIMULATION: Attempting sudo abuse")
  end

  def simulate_lateral_movement_scan
    print_status("SIMULATION: Scanning for lateral movement opportunities")
    print_status("SIMULATION: Enumerating network hosts")
    print_status("SIMULATION: Checking for shared credentials")
    print_status("SIMULATION: Looking for accessible services")
  end

  def sleep_with_termination_check(duration)
    start_time = Time.now
    while (Time.now - start_time) < duration
      return if should_terminate?
      sleep(1)
    end
  end

  # Content generation methods
  def generate_fake_kernel_module_content
    <<~EOF
      // Fake Kernel Module - Metasploit Malware Simulation
      // This is NOT a real kernel module - it's a harmless text file
      // Created for penetration testing simulation only
      // Created: #{Time.now}
      // Will auto-cleanup in: #{time_remaining} seconds
      
      // In a real rootkit, this would be compiled kernel code
      // that hooks system calls to hide processes, files, etc.
      
      #include <linux/module.h>
      #include <linux/kernel.h>
      
      static int __init rootkit_init(void) {
          printk(KERN_INFO "Rootkit simulation loaded\\n");
          return 0;
      }
      
      static void __exit rootkit_exit(void) {
          printk(KERN_INFO "Rootkit simulation unloaded\\n");
      }
      
      module_init(rootkit_init);
      module_exit(rootkit_exit);
      MODULE_LICENSE("GPL");
      MODULE_DESCRIPTION("Metasploit Rootkit Simulation");
    EOF
  end

  def generate_fake_binary_content(binary_name)
    <<~EOF
      #!/bin/bash
      # Fake #{binary_name} - Metasploit Malware Simulation
      # This is NOT the real #{binary_name} - it's a simulation
      # Created for penetration testing demonstration only
      # Created: #{Time.now}
      # Will auto-cleanup in: #{time_remaining} seconds
      
      echo "Rootkit simulation: fake #{binary_name} called"
      echo "This would hide malicious activity in a real attack"
      echo "Arguments: $@"
      
      # Call the real binary but filter out hidden items
      /bin/#{binary_name} "$@" 2>/dev/null || /usr/bin/#{binary_name} "$@" 2>/dev/null
      
      exit 0
    EOF
  end

  def generate_hidden_process_content(process_name)
    <<~EOF
      #!/bin/bash
      # Hidden Process - Metasploit Malware Simulation
      # This simulates a hidden malware process
      # Created: #{Time.now}
      # Will auto-cleanup in: #{time_remaining} seconds
      
      echo "Hidden process #{process_name} started (PID: $$)"
      echo "This is a HARMLESS penetration testing simulation"
      
      # Simulate malware process behavior
      while true; do
          sleep 30
          echo "$(date): Hidden process #{process_name} heartbeat"
      done
    EOF
  end

  def generate_hidden_file_content(filename)
    <<~EOF
      # Hidden File: #{filename}
      # Metasploit Malware Simulation
      # This file would be hidden by rootkit in a real attack
      # Created: #{Time.now}
      # Will auto-cleanup in: #{time_remaining} seconds
      
      [SIMULATION DATA]
      This file contains simulated malware data
      In a real attack, this might contain:
      - Stolen credentials
      - Configuration data
      - Collected system information
      - C2 server details
      
      Time remaining: #{time_remaining} seconds
    EOF
  end

  def generate_fake_ps_content(hidden_process)
    <<~EOF
      #!/bin/bash
      # Fake ps command that hides specific processes
      # Metasploit Malware Simulation
      
      # Call real ps and filter out hidden process
      /bin/ps "$@" | grep -v "#{hidden_process}" | grep -v "rootkit_sim"
    EOF
  end

  def generate_fake_ls_content
    <<~EOF
      #!/bin/bash
      # Fake ls command that hides rootkit files
      # Metasploit Malware Simulation
      
      # Call real ls and filter out hidden files
      /bin/ls "$@" | grep -v "rootkit" | grep -v "malware" | grep -v ".hidden"
    EOF
  end

  def generate_fake_netstat_content(hidden_connections)
    hidden_ports = hidden_connections.map { |c| c[:port] }.join('|')
    
    <<~EOF
      #!/bin/bash
      # Fake netstat command that hides malicious connections
      # Metasploit Malware Simulation
      
      # Call real netstat and filter out hidden connections
      /bin/netstat "$@" | grep -vE ":(#{hidden_ports})\\b"
    EOF
  end

  def generate_log_cleaner_content
    <<~EOF
      #!/bin/bash
      # Log Cleaner - Metasploit Malware Simulation
      # This simulates log cleaning techniques used by malware
      # Created: #{Time.now}
      
      echo "Log cleaner simulation started"
      echo "This would remove traces of malicious activity"
      echo "Target log files: /var/log/auth.log, /var/log/syslog"
      echo "SIMULATION ONLY - no actual log modification"
      
      # In a real attack, this would:
      # - Remove specific log entries
      # - Clear command history
      # - Modify timestamps
      # - Disable logging temporarily
      
      echo "Log cleaning simulation complete"
    EOF
  end

  # Override cleanup to handle Linux-specific artifacts
  def cleanup_artifacts
    print_status("Cleaning up Linux rootkit simulation artifacts")
    
    # Kill hidden processes
    hidden_process = datastore['HIDDEN_PROCESS_NAME']
    if session.type == 'shell'
      session.shell_command_token("pkill -f #{hidden_process} 2>/dev/null")
      print_status("Terminated hidden processes: #{hidden_process}")
    end
    
    # Call parent cleanup for files and directories
    super
  end

end

