##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Malware
  include Msf::Post::File
  include Msf::Post::Windows::Registry
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Windows Registry Hijack Simulator',
        'Description' => %q{
          This module simulates advanced Windows registry hijacking techniques
          commonly used by malware for persistence and privilege escalation.
          It demonstrates COM hijacking, DLL hijacking via registry, and
          other registry-based persistence methods. All changes are temporary
          and automatically cleaned up after the specified time period.
        },
        'License' => MSF_LICENSE,
        'Author' => ['Metasploit Framework Team'],
        'Platform' => ['win'],
        'SessionTypes' => ['meterpreter', 'shell'],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES],
          'Reliability' => [REPEATABLE_SESSION]
        }
      )
    )

    register_options([
      OptBool.new('SIMULATE_COM_HIJACK', [true, 'Simulate COM object hijacking', true]),
      OptBool.new('SIMULATE_DLL_HIJACK', [true, 'Simulate DLL hijacking via registry', true]),
      OptBool.new('SIMULATE_WINLOGON_HIJACK', [true, 'Simulate Winlogon helper hijacking', true]),
      OptBool.new('SIMULATE_IFEO_HIJACK', [true, 'Simulate Image File Execution Options hijacking', false]),
      OptString.new('TARGET_PROCESS', [true, 'Target process for IFEO hijacking', 'notepad.exe']),
    ])

    register_advanced_options([
      OptBool.new('CREATE_FAKE_DLLS', [true, 'Create fake DLL files for hijacking simulation', true]),
      OptString.new('HIJACK_DLL_NAME', [true, 'Name for hijacked DLL', 'malware_sim.dll']),
    ])
  end

  def run_malware_simulation
    print_status("Starting Windows registry hijacking simulation")
    
    # Verify we're on Windows
    unless session.platform == 'windows'
      print_error("This module only works on Windows platforms")
      return
    end

    # Perform various registry hijacking simulations
    simulate_com_hijacking if datastore['SIMULATE_COM_HIJACK']
    simulate_dll_hijacking if datastore['SIMULATE_DLL_HIJACK'] 
    simulate_winlogon_hijacking if datastore['SIMULATE_WINLOGON_HIJACK']
    simulate_ifeo_hijacking if datastore['SIMULATE_IFEO_HIJACK']

    # Monitor and maintain persistence simulation
    maintain_persistence_simulation

    print_good("Registry hijacking simulation active - will auto-cleanup in #{time_remaining} seconds")
  end

  private

  def simulate_com_hijacking
    print_status("Simulating COM object hijacking")
    
    # Target a common COM object (Windows Script Host)
    com_clsid = "{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}"
    hijack_key = "HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\#{com_clsid}\\InprocServer32"
    
    # Create fake DLL for COM hijacking
    fake_dll_path = "C:\\temp\\#{datastore['HIJACK_DLL_NAME']}"
    
    if datastore['CREATE_FAKE_DLLS']
      create_fake_dll(fake_dll_path)
    end

    # Simulate registry hijacking
    simulate_registry_persistence(hijack_key, "", fake_dll_path)
    simulate_registry_persistence(hijack_key, "ThreadingModel", "Apartment")
    
    print_good("Simulated COM hijacking for CLSID: #{com_clsid}")
  end

  def simulate_dll_hijacking
    print_status("Simulating DLL hijacking via registry")
    
    # Simulate App Paths hijacking
    target_exe = "explorer.exe"
    app_paths_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\#{target_exe}"
    fake_path = "C:\\temp\\fake_#{target_exe}"
    
    simulate_registry_persistence(app_paths_key, "", fake_path)
    simulate_registry_persistence(app_paths_key, "Path", "C:\\temp")
    
    # Create fake executable
    if datastore['CREATE_FAKE_DLLS']
      create_fake_executable(fake_path)
    end
    
    print_good("Simulated App Paths hijacking for: #{target_exe}")
  end

  def simulate_winlogon_hijacking
    print_status("Simulating Winlogon helper hijacking")
    
    # Simulate Winlogon Notify hijacking (legacy but still demonstrative)
    notify_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\MalwareSim"
    fake_dll_path = "C:\\temp\\winlogon_#{datastore['HIJACK_DLL_NAME']}"
    
    if datastore['CREATE_FAKE_DLLS']
      create_fake_dll(fake_dll_path)
    end

    simulate_registry_persistence(notify_key, "DllName", fake_dll_path)
    simulate_registry_persistence(notify_key, "Logon", "LogonFunction")
    simulate_registry_persistence(notify_key, "Logoff", "LogoffFunction")
    
    print_good("Simulated Winlogon Notify hijacking")
  end

  def simulate_ifeo_hijacking
    print_status("Simulating Image File Execution Options hijacking")
    
    target_process = datastore['TARGET_PROCESS']
    ifeo_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\#{target_process}"
    fake_debugger = "C:\\temp\\fake_debugger.exe"
    
    # Create fake debugger executable
    if datastore['CREATE_FAKE_DLLS']
      create_fake_executable(fake_debugger)
    end

    simulate_registry_persistence(ifeo_key, "Debugger", fake_debugger)
    
    print_warning("IFEO hijacking simulated for #{target_process} - this could affect system stability")
    print_good("Simulated IFEO hijacking for: #{target_process}")
  end

  def create_fake_dll(dll_path)
    print_status("Creating fake DLL: #{dll_path}")
    
    # Generate fake DLL content (actually a text file with DLL-like header)
    dll_content = generate_fake_dll_content
    simulate_file_drop(dll_path, dll_content)
  end

  def create_fake_executable(exe_path)
    print_status("Creating fake executable: #{exe_path}")
    
    # Generate fake executable content
    exe_content = generate_fake_executable_content
    simulate_file_drop(exe_path, exe_content)
  end

  def generate_fake_dll_content
    # Create a fake DLL that's actually a harmless text file
    content = <<~EOF
      REM Fake DLL - Metasploit Malware Simulation
      REM This is NOT a real DLL - it's a harmless text file
      REM Created for penetration testing simulation only
      REM Created: #{Time.now}
      REM Will auto-cleanup in: #{time_remaining} seconds
      
      REM In a real attack, this would be a malicious DLL
      REM This simulation demonstrates the technique safely
      
      echo "Fake DLL loaded - this is a penetration testing simulation"
      echo "Real malware would execute malicious code here"
      echo "Time remaining: #{time_remaining} seconds"
    EOF
    content
  end

  def generate_fake_executable_content
    # Create a fake executable (batch file)
    content = <<~EOF
      @echo off
      REM Fake Executable - Metasploit Malware Simulation
      REM This is NOT real malware - penetration testing simulation only
      REM Created: #{Time.now}
      REM Will auto-cleanup in: #{time_remaining} seconds
      
      echo ========================================
      echo MALWARE SIMULATION - PENETRATION TEST
      echo ========================================
      echo This is a HARMLESS simulation
      echo Real malware would execute malicious payload here
      echo Time remaining: #{time_remaining} seconds
      echo ========================================
      
      REM Simulate some malware-like behavior
      echo Simulating malware initialization...
      timeout /t 2 /nobreak >nul
      
      echo Simulating C2 communication...
      timeout /t 2 /nobreak >nul
      
      echo Simulating data collection...
      timeout /t 2 /nobreak >nul
      
      echo Malware simulation complete
      exit /b 0
    EOF
    content
  end

  def maintain_persistence_simulation
    print_status("Maintaining registry hijacking simulation")
    
    activity_count = 0
    
    while !should_terminate?
      activity_count += 1
      
      # Simulate periodic malware activities
      case activity_count % 4
      when 0
        simulate_registry_monitoring
      when 1
        simulate_process_injection_attempt
      when 2
        simulate_credential_harvesting
      when 3
        simulate_lateral_movement_prep
      end
      
      # Check for termination every 10 seconds
      sleep_with_termination_check(10)
    end
  end

  def simulate_registry_monitoring
    print_status("SIMULATION: Monitoring registry for security software")
    
    # Simulate checking for AV/EDR registry keys
    security_keys = [
      "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender",
      "HKEY_LOCAL_MACHINE\\SOFTWARE\\Symantec",
      "HKEY_LOCAL_MACHINE\\SOFTWARE\\McAfee"
    ]
    
    security_keys.each do |key|
      print_status("SIMULATION: Checking for security software at #{key}")
    end
  end

  def simulate_process_injection_attempt
    print_status("SIMULATION: Attempting process injection")
    print_status("SIMULATION: Target processes: explorer.exe, winlogon.exe, lsass.exe")
    print_status("SIMULATION: This would inject malicious code in a real attack")
  end

  def simulate_credential_harvesting
    print_status("SIMULATION: Attempting credential harvesting")
    print_status("SIMULATION: Searching for stored credentials")
    print_status("SIMULATION: Checking browser saved passwords")
    print_status("SIMULATION: Looking for cached domain credentials")
  end

  def simulate_lateral_movement_prep
    print_status("SIMULATION: Preparing for lateral movement")
    print_status("SIMULATION: Enumerating network shares")
    print_status("SIMULATION: Scanning for accessible systems")
    print_status("SIMULATION: Collecting network topology information")
  end

  def sleep_with_termination_check(duration)
    start_time = Time.now
    while (Time.now - start_time) < duration
      return if should_terminate?
      sleep(1)
    end
  end

  # Override cleanup to handle Windows-specific registry cleanup
  def cleanup_artifacts
    print_status("Cleaning up Windows registry hijacking artifacts")
    
    # Clean up COM hijacking
    if datastore['SIMULATE_COM_HIJACK']
      cleanup_com_hijacking
    end
    
    # Clean up IFEO hijacking
    if datastore['SIMULATE_IFEO_HIJACK']
      cleanup_ifeo_hijacking
    end
    
    # Call parent cleanup for files and other artifacts
    super
  end

  def cleanup_com_hijacking
    com_clsid = "{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}"
    hijack_key = "HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\#{com_clsid}"
    
    begin
      if session.type == 'meterpreter'
        session.sys.registry.delete_key(hijack_key)
      elsif session.type == 'shell'
        session.shell_command_token("reg delete \"#{hijack_key}\" /f 2>nul")
      end
      print_status("Cleaned up COM hijacking registry entries")
    rescue => e
      print_warning("Could not clean up COM hijacking: #{e.message}")
    end
  end

  def cleanup_ifeo_hijacking
    target_process = datastore['TARGET_PROCESS']
    ifeo_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\#{target_process}"
    
    begin
      if session.type == 'meterpreter'
        session.sys.registry.delete_key(ifeo_key)
      elsif session.type == 'shell'
        session.shell_command_token("reg delete \"#{ifeo_key}\" /f 2>nul")
      end
      print_status("Cleaned up IFEO hijacking registry entries")
    rescue => e
      print_warning("Could not clean up IFEO hijacking: #{e.message}")
    end
  end

end