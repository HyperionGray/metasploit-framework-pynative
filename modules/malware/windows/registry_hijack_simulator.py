#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Windows Registry Hijack Simulator

This module requires Metasploit: https://metasploit.com/download
Current source: https://github.com/rapid7/metasploit-framework

Converted from Ruby to Python as part of the Python migration initiative.
"""

import sys
import os
import time
from typing import Optional

# Add python_framework to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../python_framework'))

from core.malware import Malware, ArtifactType


class RegistryHijackSimulator(Malware):
    """
    Windows Registry Hijack Simulator
    
    This module simulates advanced Windows registry hijacking techniques
    commonly used by malware for persistence and privilege escalation.
    It demonstrates COM hijacking, DLL hijacking via registry, and
    other registry-based persistence methods. All changes are temporary
    and automatically cleaned up after the specified time period.
    """
    
    def __init__(self, session=None):
        super().__init__(session)
        
        # Module metadata
        self.info = {
            'Name': 'Windows Registry Hijack Simulator',
            'Description': '''
                This module simulates advanced Windows registry hijacking techniques
                commonly used by malware for persistence and privilege escalation.
                It demonstrates COM hijacking, DLL hijacking via registry, and
                other registry-based persistence methods. All changes are temporary
                and automatically cleaned up after the specified time period.
            ''',
            'License': 'MSF_LICENSE',
            'Author': ['Metasploit Framework Team'],
            'Platform': ['win'],
            'SessionTypes': ['meterpreter', 'shell'],
            'Notes': {
                'Stability': ['CRASH_SAFE'],
                'SideEffects': ['ARTIFACTS_ON_DISK', 'CONFIG_CHANGES'],
                'Reliability': ['REPEATABLE_SESSION']
            }
        }
        
        # Module options
        self.datastore.update({
            'SIMULATE_COM_HIJACK': True,
            'SIMULATE_DLL_HIJACK': True,
            'SIMULATE_WINLOGON_HIJACK': True,
            'SIMULATE_IFEO_HIJACK': False,
            'TARGET_PROCESS': 'notepad.exe',
            'CREATE_FAKE_DLLS': True,
            'HIJACK_DLL_NAME': 'malware_sim.dll',
        })
    
    def run_malware_simulation(self) -> None:
        """Main malware simulation execution"""
        self.print_status("Starting Windows registry hijacking simulation")
        
        # Verify we're on Windows
        if self.session:
            platform = getattr(self.session, 'platform', 'unknown')
            if platform != 'windows':
                self.print_error("This module only works on Windows platforms")
                return
        else:
            self.print_warning("No session available - running in standalone mode")
        
        # Perform various registry hijacking simulations
        if self.datastore.get('SIMULATE_COM_HIJACK', True):
            self.simulate_com_hijacking()
        
        if self.datastore.get('SIMULATE_DLL_HIJACK', True):
            self.simulate_dll_hijacking()
        
        if self.datastore.get('SIMULATE_WINLOGON_HIJACK', True):
            self.simulate_winlogon_hijacking()
        
        if self.datastore.get('SIMULATE_IFEO_HIJACK', False):
            self.simulate_ifeo_hijacking()
        
        # Monitor and maintain persistence simulation
        self.maintain_persistence_simulation()
        
        self.print_good(f"Registry hijacking simulation active - will auto-cleanup in {self.time_remaining()} seconds")
    
    def simulate_com_hijacking(self) -> None:
        """Simulate COM object hijacking"""
        self.print_status("Simulating COM object hijacking")
        
        # Target a common COM object (Windows Script Host)
        com_clsid = "{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}"
        hijack_key = f"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{com_clsid}\\InprocServer32"
        
        hijack_dll_name = self.datastore.get('HIJACK_DLL_NAME', 'malware_sim.dll')
        
        # Create fake DLL for COM hijacking
        fake_dll_path = f"C:\\temp\\{hijack_dll_name}"
        
        if self.datastore.get('CREATE_FAKE_DLLS', True):
            self.create_fake_dll(fake_dll_path)
        
        # Simulate registry hijacking
        self.simulate_registry_persistence(hijack_key, "", fake_dll_path)
        self.simulate_registry_persistence(hijack_key, "ThreadingModel", "Apartment")
        
        self.print_good(f"Simulated COM hijacking for CLSID: {com_clsid}")
    
    def simulate_dll_hijacking(self) -> None:
        """Simulate DLL hijacking via registry"""
        self.print_status("Simulating DLL hijacking via registry")
        
        # Simulate App Paths hijacking
        target_exe = "explorer.exe"
        app_paths_key = f"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\{target_exe}"
        fake_path = f"C:\\temp\\fake_{target_exe}"
        
        self.simulate_registry_persistence(app_paths_key, "", fake_path)
        self.simulate_registry_persistence(app_paths_key, "Path", "C:\\temp")
        
        # Create fake executable
        if self.datastore.get('CREATE_FAKE_DLLS', True):
            self.create_fake_executable(fake_path)
        
        self.print_good(f"Simulated App Paths hijacking for: {target_exe}")
    
    def simulate_winlogon_hijacking(self) -> None:
        """Simulate Winlogon helper hijacking"""
        self.print_status("Simulating Winlogon helper hijacking")
        
        hijack_dll_name = self.datastore.get('HIJACK_DLL_NAME', 'malware_sim.dll')
        
        # Simulate Winlogon Notify hijacking (legacy but still demonstrative)
        notify_key = "HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\Notify\\MalwareSim"
        fake_dll_path = f"C:\\temp\\winlogon_{hijack_dll_name}"
        
        if self.datastore.get('CREATE_FAKE_DLLS', True):
            self.create_fake_dll(fake_dll_path)
        
        self.simulate_registry_persistence(notify_key, "DllName", fake_dll_path)
        self.simulate_registry_persistence(notify_key, "Logon", "LogonFunction")
        self.simulate_registry_persistence(notify_key, "Logoff", "LogoffFunction")
        
        self.print_good("Simulated Winlogon Notify hijacking")
    
    def simulate_ifeo_hijacking(self) -> None:
        """Simulate Image File Execution Options hijacking"""
        self.print_status("Simulating Image File Execution Options hijacking")
        
        target_process = self.datastore.get('TARGET_PROCESS', 'notepad.exe')
        ifeo_key = f"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\{target_process}"
        fake_debugger = "C:\\temp\\fake_debugger.exe"
        
        # Create fake debugger executable
        if self.datastore.get('CREATE_FAKE_DLLS', True):
            self.create_fake_executable(fake_debugger)
        
        self.simulate_registry_persistence(ifeo_key, "Debugger", fake_debugger)
        
        self.print_warning(f"IFEO hijacking simulated for {target_process} - this could affect system stability")
        self.print_good(f"Simulated IFEO hijacking for: {target_process}")
    
    def create_fake_dll(self, dll_path: str) -> None:
        """Create a fake DLL file"""
        self.print_status(f"Creating fake DLL: {dll_path}")
        
        # Generate fake DLL content (actually a text file with DLL-like header)
        dll_content = self.generate_fake_dll_content()
        self.simulate_file_drop(dll_path, dll_content)
    
    def create_fake_executable(self, exe_path: str) -> None:
        """Create a fake executable file"""
        self.print_status(f"Creating fake executable: {exe_path}")
        
        # Generate fake executable content
        exe_content = self.generate_fake_executable_content()
        self.simulate_file_drop(exe_path, exe_content)
    
    def generate_fake_dll_content(self) -> str:
        """Generate fake DLL content (text file)"""
        content = f"""REM Fake DLL - Metasploit Malware Simulation
REM This is NOT a real DLL - it's a harmless text file
REM Created for penetration testing simulation only
REM Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
REM Will auto-cleanup in: {self.time_remaining()} seconds

REM In a real attack, this would be a malicious DLL
REM This simulation demonstrates the technique safely

echo "Fake DLL loaded - this is a penetration testing simulation"
echo "Real malware would execute malicious code here"
echo "Time remaining: {self.time_remaining()} seconds"
"""
        return content
    
    def generate_fake_executable_content(self) -> str:
        """Generate fake executable content (batch file)"""
        content = f"""@echo off
REM Fake Executable - Metasploit Malware Simulation
REM This is NOT real malware - penetration testing simulation only
REM Created: {time.strftime('%Y-%m-%d %H:%M:%S')}
REM Will auto-cleanup in: {self.time_remaining()} seconds

echo ========================================
echo MALWARE SIMULATION - PENETRATION TEST
echo ========================================
echo This is a HARMLESS simulation
echo Real malware would execute malicious payload here
echo Time remaining: {self.time_remaining()} seconds
echo ========================================

REM Simulate some malware-like behavior
echo Simulating malware initialization...
timeout /t 2 /nobreak >nul

echo Simulating C2 communication...
timeout /t 2 /nobreak >nul

echo Simulating data collection...
timeout /t 2 /nobreak >nul

echo Malware simulation complete
exit /b 0
"""
        return content
    
    def maintain_persistence_simulation(self) -> None:
        """Maintain registry hijacking simulation"""
        self.print_status("Maintaining registry hijacking simulation")
        
        activity_count = 0
        
        while not self.should_terminate():
            activity_count += 1
            
            # Simulate periodic malware activities
            activity_type = activity_count % 4
            if activity_type == 0:
                self.simulate_registry_monitoring()
            elif activity_type == 1:
                self.simulate_process_injection_attempt()
            elif activity_type == 2:
                self.simulate_credential_harvesting()
            elif activity_type == 3:
                self.simulate_lateral_movement_prep()
            
            # Check for termination every 10 seconds
            self.sleep_with_termination_check(10)
    
    def simulate_registry_monitoring(self) -> None:
        """Simulate registry monitoring for security software"""
        self.print_status("SIMULATION: Monitoring registry for security software")
        
        # Simulate checking for AV/EDR registry keys
        security_keys = [
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows Defender",
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\Symantec",
            "HKEY_LOCAL_MACHINE\\SOFTWARE\\McAfee"
        ]
        
        for key in security_keys:
            self.print_status(f"SIMULATION: Checking for security software at {key}")
    
    def simulate_process_injection_attempt(self) -> None:
        """Simulate process injection attempt"""
        self.print_status("SIMULATION: Attempting process injection")
        self.print_status("SIMULATION: Target processes: explorer.exe, winlogon.exe, lsass.exe")
        self.print_status("SIMULATION: This would inject malicious code in a real attack")
    
    def simulate_credential_harvesting(self) -> None:
        """Simulate credential harvesting"""
        self.print_status("SIMULATION: Attempting credential harvesting")
        self.print_status("SIMULATION: Searching for stored credentials")
        self.print_status("SIMULATION: Checking browser saved passwords")
        self.print_status("SIMULATION: Looking for cached domain credentials")
    
    def simulate_lateral_movement_prep(self) -> None:
        """Simulate lateral movement preparation"""
        self.print_status("SIMULATION: Preparing for lateral movement")
        self.print_status("SIMULATION: Enumerating network shares")
        self.print_status("SIMULATION: Scanning for accessible systems")
        self.print_status("SIMULATION: Collecting network topology information")
    
    def sleep_with_termination_check(self, duration: int) -> None:
        """Sleep while checking for termination"""
        start_time = time.time()
        while (time.time() - start_time) < duration:
            if self.should_terminate():
                return
            time.sleep(1)
    
    def cleanup_artifacts(self) -> None:
        """Override cleanup to handle Windows-specific registry cleanup"""
        self.print_status("Cleaning up Windows registry hijacking artifacts")
        
        # Clean up COM hijacking
        if self.datastore.get('SIMULATE_COM_HIJACK', True):
            self.cleanup_com_hijacking()
        
        # Clean up IFEO hijacking
        if self.datastore.get('SIMULATE_IFEO_HIJACK', False):
            self.cleanup_ifeo_hijacking()
        
        # Call parent cleanup for files and other artifacts
        super().cleanup_artifacts()
    
    def cleanup_com_hijacking(self) -> None:
        """Clean up COM hijacking registry entries"""
        com_clsid = "{F935DC22-1CF0-11D0-ADB9-00C04FD58A0B}"
        hijack_key = f"HKEY_CURRENT_USER\\Software\\Classes\\CLSID\\{com_clsid}"
        
        try:
            if self.session:
                session_type = getattr(self.session, 'type', None)
                
                if session_type == 'meterpreter':
                    self.session.sys.registry.delete_key(hijack_key)
                elif session_type == 'shell':
                    self.session.shell_command_token(f'reg delete "{hijack_key}" /f 2>nul')
                
                self.print_status("Cleaned up COM hijacking registry entries")
        except Exception as e:
            self.print_warning(f"Could not clean up COM hijacking: {e}")
    
    def cleanup_ifeo_hijacking(self) -> None:
        """Clean up IFEO hijacking registry entries"""
        target_process = self.datastore.get('TARGET_PROCESS', 'notepad.exe')
        ifeo_key = f"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\{target_process}"
        
        try:
            if self.session:
                session_type = getattr(self.session, 'type', None)
                
                if session_type == 'meterpreter':
                    self.session.sys.registry.delete_key(ifeo_key)
                elif session_type == 'shell':
                    self.session.shell_command_token(f'reg delete "{ifeo_key}" /f 2>nul')
                
                self.print_status("Cleaned up IFEO hijacking registry entries")
        except Exception as e:
            self.print_warning(f"Could not clean up IFEO hijacking: {e}")


def main():
    """Standalone execution for testing"""
    import logging
    logging.basicConfig(level=logging.INFO)
    
    # Create simulator without session for testing
    simulator = RegistryHijackSimulator(session=None)
    
    # Run simulation
    try:
        simulator.run()
    except KeyboardInterrupt:
        print("\n[!] Simulation interrupted by user")
        simulator.cleanup_artifacts()


if __name__ == '__main__':
    main()
