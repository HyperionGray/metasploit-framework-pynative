#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Gogs Git Hooks Remote Code Execution

This module leverages an insecure setting to get remote code
execution on the target OS in the context of the user running Gogs.
This is possible when the current user is allowed to create `git
hooks`, which is the default for administrative users. For
non-administrative users, the permission needs to be specifically
granted by an administrator.

To achieve code execution, the module authenticates to the Gogs web
interface, creates a temporary repository, sets a `post-receive` git
hook with the payload and creates a dummy file in the repository.
This last action will trigger the git hook and execute the payload.
Everything is done through the web interface.

No mitigation has been implemented so far (latest stable version is
0.12.3).

This module has been tested successfully against version 0.12.3 on
docker. Windows version could not be tested since the git hook feature
seems to be broken.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Gogs Git Hooks Remote Code Execution',
    'description': '''
        This module leverages an insecure setting to get remote code
        execution on the target OS in the context of the user running Gogs.
        This is possible when the current user is allowed to create `git
        hooks`, which is the default for administrative users. For
        non-administrative users, the permission needs to be specifically
        granted by an administrator.
        
        To achieve code execution, the module authenticates to the Gogs web
        interface, creates a temporary repository, sets a `post-receive` git
        hook with the payload and creates a dummy file in the repository.
        This last action will trigger the git hook and execute the payload.
        Everything is done through the web interface.
        
        No mitigation has been implemented so far (latest stable version is
        0.12.3).
        
        This module has been tested successfully against version 0.12.3 on
        docker. Windows version could not be tested since the git hook feature
        seems to be broken.
    ''',
    'authors': [
        'Podalirius',
        'Christophe De La Fuente',
    ],
    'date': '2020-10-07',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Unix Command'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
