#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Gitea Git Hooks Remote Code Execution

This module leverages an insecure setting to get remote code
execution on the target OS in the context of the user running Gitea.
This is possible when the current user is allowed to create `git
hooks`, which is the default for administrative users. For
non-administrative users, the permission needs to be specifically
granted by an administrator.

To achieve code execution, the module authenticates to the Gitea web
interface, creates a temporary repository, sets a `post-receive` git
hook with the payload and creates a dummy file in the repository.
This last action will trigger the git hook and execute the payload.
Everything is done through the web interface.

It has been mitigated in version 1.13.0 by setting the Gitea
`DISABLE_GIT_HOOKS` configuration setting to `true` by default. This
disables this feature and prevents all users (including admin) from
creating custom git hooks.

This module has been tested successfully against docker versions 1.12.5,
1.12.6 and 1.13.6 with `DISABLE_GIT_HOOKS` set to `false`, and on
version 1.12.6 on Windows.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Gitea Git Hooks Remote Code Execution',
    'description': '''
        This module leverages an insecure setting to get remote code
        execution on the target OS in the context of the user running Gitea.
        This is possible when the current user is allowed to create `git
        hooks`, which is the default for administrative users. For
        non-administrative users, the permission needs to be specifically
        granted by an administrator.
        
        To achieve code execution, the module authenticates to the Gitea web
        interface, creates a temporary repository, sets a `post-receive` git
        hook with the payload and creates a dummy file in the repository.
        This last action will trigger the git hook and execute the payload.
        Everything is done through the web interface.
        
        It has been mitigated in version 1.13.0 by setting the Gitea
        `DISABLE_GIT_HOOKS` configuration setting to `true` by default. This
        disables this feature and prevents all users (including admin) from
        creating custom git hooks.
        
        This module has been tested successfully against docker versions 1.12.5,
        1.12.6 and 1.13.6 with `DISABLE_GIT_HOOKS` set to `false`, and on
        version 1.12.6 on Windows.
    ''',
    'authors': [
        'Podalirius',
        'Christophe De La Fuente',
    ],
    'date': '2020-10-07',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Unix Command'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
