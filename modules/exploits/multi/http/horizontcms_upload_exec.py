#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
HorizontCMS Arbitrary PHP File Upload

This module exploits an arbitrary file upload vulnerability in
HorizontCMS 1.0.0-beta in order to execute arbitrary commands.

The module first attempts to authenticate to HorizontCMS. It then tries
to upload a malicious PHP file via an HTTP POST request to
`/admin/file-manager/fileupload`. The server will rename this file to a
random string. The module will therefore attempt to change the filename
back to the original name via an HTTP POST request to
`/admin/file-manager/rename`. For the `php` target, the payload is
embedded in the uploaded file and the module attempts to execute the
payload via an HTTP GET request to `/storage/file_name`. For the `linux`
and `windows` targets, the module uploads a simple PHP web shell
similar to `<?php system($_GET["cmd"]); ?>`. Subsequently, it leverages
the CmdStager mixin to deliver the final payload via a series of HTTP
GET requests to the PHP web shell.

Valid credentials for a HorizontCMS user with permissions to use the
FileManager are required. This would be all users in the Admin, Manager
and Editor groups if HorizontCMS is configured with the default group
settings.This module has been successfully tested against HorizontCMS
1.0.0-beta running on Ubuntu 18.04.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'HorizontCMS Arbitrary PHP File Upload',
    'description': '''
        This module exploits an arbitrary file upload vulnerability in
        HorizontCMS 1.0.0-beta in order to execute arbitrary commands.
        
        The module first attempts to authenticate to HorizontCMS. It then tries
        to upload a malicious PHP file via an HTTP POST request to
        `/admin/file-manager/fileupload`. The server will rename this file to a
        random string. The module will therefore attempt to change the filename
        back to the original name via an HTTP POST request to
        `/admin/file-manager/rename`. For the `php` target, the payload is
        embedded in the uploaded file and the module attempts to execute the
        payload via an HTTP GET request to `/storage/file_name`. For the `linux`
        and `windows` targets, the module uploads a simple PHP web shell
        similar to `<?php system($_GET["cmd"]); ?>`. Subsequently, it leverages
        the CmdStager mixin to deliver the final payload via a series of HTTP
        GET requests to the PHP web shell.
        
        Valid credentials for a HorizontCMS user with permissions to use the
        FileManager are required. This would be all users in the Admin, Manager
        and Editor groups if HorizontCMS is configured with the default group
        settings.This module has been successfully tested against HorizontCMS
        1.0.0-beta running on Ubuntu 18.04.
    ''',
    'authors': [
        'Erik Wynter',
    ],
    'date': '2020-09-24',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'PHP'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
