#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE

This module exploits LFI and log poisoning vulnerabilities
(CVE-2020-16152) in Aerohive NetConfig, version 10.0r8a
build-242466 and older in order to achieve unauthenticated remote
code execution as the root user. NetConfig is the Aerohive/Extreme
Networks HiveOS administrative webinterface. Vulnerable versions
allow for LFI because they rely on a version of PHP 5 that is
vulnerable to string truncation attacks. This module leverages this
issue in conjunction with log poisoning to gain RCE as root.

Upon successful exploitation, the Aerohive NetConfig application
may hang for as long as the spawned shell remains open. For the
Linux target, the MeterpreterTryToFork option (enabled by default)
will likely prevent this. If the app hangs, closing the session
should render it responsive again.

The module provides an automatic cleanup option to clean the log.
However, this option is disabled by default because any modifications
to the /tmp/messages log, even via sed, may render the target
(temporarily) unexploitable. This state can last over an hour.

This module has been successfully tested against Aerohive NetConfig
versions 8.2r4 and 10.0r7a.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Aerohive NetConfig 10.0r8a LFI and log poisoning to RCE',
    'description': '''
        This module exploits LFI and log poisoning vulnerabilities
        (CVE-2020-16152) in Aerohive NetConfig, version 10.0r8a
        build-242466 and older in order to achieve unauthenticated remote
        code execution as the root user. NetConfig is the Aerohive/Extreme
        Networks HiveOS administrative webinterface. Vulnerable versions
        allow for LFI because they rely on a version of PHP 5 that is
        vulnerable to string truncation attacks. This module leverages this
        issue in conjunction with log poisoning to gain RCE as root.
        
        Upon successful exploitation, the Aerohive NetConfig application
        may hang for as long as the spawned shell remains open. For the
        Linux target, the MeterpreterTryToFork option (enabled by default)
        will likely prevent this. If the app hangs, closing the session
        should render it responsive again.
        
        The module provides an automatic cleanup option to clean the log.
        However, this option is disabled by default because any modifications
        to the /tmp/messages log, even via sed, may render the target
        (temporarily) unexploitable. This state can last over an hour.
        
        This module has been successfully tested against Aerohive NetConfig
        versions 8.2r4 and 10.0r7a.
    ''',
    'authors': [
        'Erik de Jong',
        'Erik Wynter',
    ],
    'date': '2020-02-17',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Linux'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
