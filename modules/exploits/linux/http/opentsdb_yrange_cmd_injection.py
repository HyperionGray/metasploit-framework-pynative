#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
OpenTSDB 2.4.0 unauthenticated command injection

This module exploits an unauthenticated command injection
vulnerability in the yrange parameter in OpenTSDB through
2.4.0 (CVE-2020-35476) in order to achieve unauthenticated
remote code execution as the root user.

The module first attempts to obtain the OpenTSDB version via
the api. If the version is 2.4.0 or lower, the module
performs additional checks to obtain the configured metrics
and aggregators. It then randomly selects one metric and one
aggregator and uses those to instruct the target server to
plot a graph. As part of this request, the yrange parameter is
set to the payload, which will then be executed by the target
if the latter is vulnerable.

This module has been successfully tested against OpenTSDB
version 2.3.0.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'OpenTSDB 2.4.0 unauthenticated command injection',
    'description': '''
        This module exploits an unauthenticated command injection
        vulnerability in the yrange parameter in OpenTSDB through
        2.4.0 (CVE-2020-35476) in order to achieve unauthenticated
        remote code execution as the root user.
        
        The module first attempts to obtain the OpenTSDB version via
        the api. If the version is 2.4.0 or lower, the module
        performs additional checks to obtain the configured metrics
        and aggregators. It then randomly selects one metric and one
        aggregator and uses those to instruct the target server to
        plot a graph. As part of this request, the yrange parameter is
        set to the payload, which will then be executed by the target
        if the latter is vulnerable.
        
        This module has been successfully tested against OpenTSDB
        version 2.3.0.
    ''',
    'authors': [
        'Shai rod',
        'Erik Wynter',
    ],
    'date': '2020-11-18',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Automatic (Unix In-Memory)'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
