#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
TP-Link Cloud Cameras NCXXX Bonjour Command Injection

TP-Link cloud cameras NCXXX series (NC200, NC210, NC220, NC230,
NC250, NC260, NC450) are vulnerable to an authenticated command
injection. In all devices except NC210, despite a check on the name length in
swSystemSetProductAliasCheck, no other checks are in place in order
to prevent shell metacharacters from being introduced. The system name
would then be used in swBonjourStartHTTP as part of a shell command
where arbitrary commands could be injected and executed as root. NC210 devices
cannot be exploited directly via /setsysname.cgi due to proper input
validation. NC210 devices are still vulnerable since swBonjourStartHTTP
did not perform any validation when reading the alias name from the
configuration file. The configuration file can be written, and code
execution can be achieved by combining this issue with CVE-2020-12110.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'TP-Link Cloud Cameras NCXXX Bonjour Command Injection',
    'description': '''
        TP-Link cloud cameras NCXXX series (NC200, NC210, NC220, NC230,
        NC250, NC260, NC450) are vulnerable to an authenticated command
        injection. In all devices except NC210, despite a check on the name length in
        swSystemSetProductAliasCheck, no other checks are in place in order
        to prevent shell metacharacters from being introduced. The system name
        would then be used in swBonjourStartHTTP as part of a shell command
        where arbitrary commands could be injected and executed as root. NC210 devices
        cannot be exploited directly via /setsysname.cgi due to proper input
        validation. NC210 devices are still vulnerable since swBonjourStartHTTP
        did not perform any validation when reading the alias name from the
        configuration file. The configuration file can be written, and code
        execution can be achieved by combining this issue with CVE-2020-12110.
    ''',
    'date': '2020-04-29',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'TP-Link NC200, NC220, NC230, NC250'},  # TODO: Add platform/arch
        {'name': 'wget'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
