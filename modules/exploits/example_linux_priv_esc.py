#!/usr/bin/env python3
"""
Python port of the sample Linux privilege escalation module.
"""

import os
import platform
import secrets
import stat
import subprocess
import sys
from typing import Tuple

CURRENT_DIR = os.path.dirname(__file__)
PROJECT_ROOT = os.path.abspath(os.path.join(CURRENT_DIR, "..", ".."))
sys.path.insert(0, os.path.join(PROJECT_ROOT, "python_framework"))

from python_framework.core.exploit import (
    LocalExploit,
    ExploitInfo,
    ExploitOption,
    ExploitResult,
    ExploitTarget,
    ExploitRank,
    Platform,
    TargetArch,
    PayloadType,
)


class LinuxPrivEscExploit(LocalExploit):
    """Sample privilege escalation module for Linux systems."""

    def __init__(self):
        info = ExploitInfo(
            name="Sample Linux Priv Esc",
            description=(
                "This exploit module illustrates how a vulnerability could be "
                "exploited in a Linux command for privilege escalation."
            ),
            author=["h00die <mike@stcyrsecurity.com>", "researcher"],
            references=[
                "OSVDB-12345",
                "EDB-12345",
                "http://www.example.com",
                "CVE-1978-1234",
            ],
            disclosure_date="2023-11-29",
            rank=ExploitRank.NORMAL,
            platform=[Platform.LINUX],
            arch=[TargetArch.X86, TargetArch.X64],
            privileged=True,
            targets=[
                ExploitTarget(
                    name="Local shell",
                    platform=[Platform.LINUX],
                    arch=[TargetArch.X64],
                    payload_type=PayloadType.UNIX_CMD,
                )
            ],
            default_target=0,
            notes={"Stability": [], "Reliability": [], "SideEffects": []},
        )

        super().__init__(info)

        self.register_options(
            [
                ExploitOption("WRITABLE_DIR", True, "Directory where files can be written", "/tmp", str),
                ExploitOption("FORCE_EXPLOIT", False, "Run even if already privileged", False, bool),
                ExploitOption("PAYLOAD_CMD", False, "Command to execute with elevated privileges", "id", str),
            ]
        )

    def _parse_kernel_version(self) -> Tuple[int, int, int]:
        release = platform.release().split("-")[0]
        parts = release.split(".")
        try:
            major, minor, patch = (int(parts[0]), int(parts[1]), int(parts[2] if len(parts) > 2 else 0))
            return major, minor, patch
        except (ValueError, IndexError):
            raise ValueError(f"Unable to parse kernel release: {platform.release()}")

    def check(self) -> ExploitResult:
        try:
            version = self._parse_kernel_version()
        except ValueError as exc:
            return ExploitResult(False, str(exc))

        vulnerable = (4, 0, 0) <= version <= (4, 14, 11)
        if not vulnerable:
            return ExploitResult(False, f"Kernel version {platform.release()} is not in vulnerable range")

        # Best-effort package check (non-fatal)
        try:
            result = subprocess.run(
                ["dpkg", "-l", "example"], capture_output=True, text=True, timeout=5
            )
            if "ii" in result.stdout and "1:2015.3.14AR.1-1build1" in result.stdout:
                return ExploitResult(True, "Vulnerable app version detected")
        except (FileNotFoundError, subprocess.SubprocessError):
            pass

        return ExploitResult(True, "Kernel appears vulnerable; package check inconclusive")

    def exploit(self) -> ExploitResult:
        if not self.get_option("FORCE_EXPLOIT", False) and os.geteuid() == 0:
            return ExploitResult(False, "Session already has root privileges. Set FORCE_EXPLOIT to override.")

        writable_dir = self.get_option("WRITABLE_DIR", "/tmp")
        if not os.path.isdir(writable_dir) or not os.access(writable_dir, os.W_OK | os.X_OK):
            return ExploitResult(False, f"{writable_dir} is not writable")

        payload_name = f".priv_{secrets.token_hex(4)}"
        payload_path = os.path.join(writable_dir, payload_name)
        payload_cmd = self.get_option("PAYLOAD_CMD", "id")

        try:
            with open(payload_path, "w", encoding="utf-8") as handle:
                handle.write("#!/bin/sh\n")
                handle.write(f"{payload_cmd}\n")
            os.chmod(payload_path, stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR)
        except OSError as exc:
            return ExploitResult(False, f"Failed to write payload: {exc}")

        try:
            completed = subprocess.run(
                [payload_path],
                capture_output=True,
                text=True,
                timeout=30,
                env={"PATH": os.environ.get("PATH", ""), **os.environ},
            )
            output = completed.stdout.strip() or completed.stderr.strip()
        except subprocess.SubprocessError as exc:
            return ExploitResult(False, f"Execution failed: {exc}")

        message = f"Payload executed with exit code {completed.returncode}"
        data = {"payload_path": payload_path, "output": output}
        success = completed.returncode == 0
        return ExploitResult(success, message, data)


if __name__ == "__main__":
    exploit = LinuxPrivEscExploit()
    result = exploit.run()
    status = "success" if result.success else "failure"
    print(f"[{status}] {result.message}")
