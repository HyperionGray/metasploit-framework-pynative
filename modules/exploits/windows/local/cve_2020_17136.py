#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
CVE-2020-1170 Cloud Filter Arbitrary File Creation EOP

The Cloud Filter driver, cldflt.sys, on Windows 10 v1803 and later, prior to the December
2020 updates, did not set the IO_FORCE_ACCESS_CHECK or OBJ_FORCE_ACCESS_CHECK flags when
calling FltCreateFileEx() and FltCreateFileEx2() within its HsmpOpCreatePlaceholders()
function with attacker controlled input. This meant that files were created with
KernelMode permissions, thereby bypassing any security checks that would otherwise
prevent a normal user from being able to create files in directories
they don't have permissions to create files in.

This module abuses this vulnerability to perform a DLL hijacking attack against the
Microsoft Storage Spaces SMP service, which grants the attacker code execution as the
NETWORK SERVICE user. Users are strongly encouraged to set the PAYLOAD option to one
of the Meterpreter payloads, as doing so will allow them to subsequently escalate their
new session from NETWORK SERVICE to SYSTEM by using Meterpreter's "getsystem" command
to perform RPCSS Named Pipe Impersonation and impersonate the SYSTEM user.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'CVE-2020-1170 Cloud Filter Arbitrary File Creation EOP',
    'description': '''
        The Cloud Filter driver, cldflt.sys, on Windows 10 v1803 and later, prior to the December
        2020 updates, did not set the IO_FORCE_ACCESS_CHECK or OBJ_FORCE_ACCESS_CHECK flags when
        calling FltCreateFileEx() and FltCreateFileEx2() within its HsmpOpCreatePlaceholders()
        function with attacker controlled input. This meant that files were created with
        KernelMode permissions, thereby bypassing any security checks that would otherwise
        prevent a normal user from being able to create files in directories
        they don't have permissions to create files in.
        
        This module abuses this vulnerability to perform a DLL hijacking attack against the
        Microsoft Storage Spaces SMP service, which grants the attacker code execution as the
        NETWORK SERVICE user. Users are strongly encouraged to set the PAYLOAD option to one
        of the Meterpreter payloads, as doing so will allow them to subsequently escalate their
        new session from NETWORK SERVICE to SYSTEM by using Meterpreter's "getsystem" command
        to perform RPCSS Named Pipe Impersonation and impersonate the SYSTEM user.
    ''',
    'authors': [
        'James Foreshaw',
        'Grant Willcox',
    ],
    'date': '2020-03-10',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Windows DLL Dropper'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
