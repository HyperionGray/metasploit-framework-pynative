#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Java 7 Applet Remote Code Execution

The exploit takes advantage of two issues in JDK 7: The ClassFinder and
MethodFinder.findMethod().  Both were newly introduced in JDK 7.  ClassFinder is a
replacement for classForName back in JDK 6. It allows untrusted code to obtain a
reference and have access to a restricted package in JDK 7, which can be used to
abuse sun.awt.SunToolkit (a restricted package).  With sun.awt.SunToolkit, we can
actually invoke getField() by abusing findMethod() in Statement.invokeInternal()
(but getField() must be public, and that's not always the case in JDK 6) in order
to access Statement.acc's private field, modify AccessControlContext, and then
disable Security Manager. Once Security Manager is disabled, we can execute
arbitrary Java code.

Our exploit has been tested successfully against multiple platforms, including:
IE, Firefox, Safari, Chrome; Windows, Ubuntu, OS X, Solaris, etc.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Java 7 Applet Remote Code Execution',
    'description': '''
        The exploit takes advantage of two issues in JDK 7: The ClassFinder and
        MethodFinder.findMethod().  Both were newly introduced in JDK 7.  ClassFinder is a
        replacement for classForName back in JDK 6. It allows untrusted code to obtain a
        reference and have access to a restricted package in JDK 7, which can be used to
        abuse sun.awt.SunToolkit (a restricted package).  With sun.awt.SunToolkit, we can
        actually invoke getField() by abusing findMethod() in Statement.invokeInternal()
        (but getField() must be public, and that's not always the case in JDK 6) in order
        to access Statement.acc's private field, modify AccessControlContext, and then
        disable Security Manager. Once Security Manager is disabled, we can execute
        arbitrary Java code.
        
        Our exploit has been tested successfully against multiple platforms, including:
        IE, Firefox, Safari, Chrome; Windows, Ubuntu, OS X, Solaris, etc.
    ''',
    'authors': [
        'Adam Gowdiak',
        's advisory
          ',
        ', # Vulnerability discovery according to Oracle',
        'jduck',
        'sinn3r',
        'juan vazquez',
    ],
    'date': '2012-08-26',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Generic (Java Payload)'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
