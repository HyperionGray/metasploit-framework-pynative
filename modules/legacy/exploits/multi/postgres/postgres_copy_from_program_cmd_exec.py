#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
PostgreSQL COPY FROM PROGRAM Command Execution

Installations running Postgres 9.3 and above have functionality which allows for the superuser
and users with 'pg_execute_server_program' to pipe to and from an external program using COPY.
This allows arbitrary command execution as though you have console access.

This module attempts to create a new table, then execute system commands in the context of
copying the command output into the table.

This module should work on all Postgres systems running version 9.3 and above.

For Linux & OSX systems, target 1 is used with cmd payloads such as: cmd/unix/reverse_perl

For Windows Systems, target 2 is used with powershell payloads such as: cmd/windows/powershell_reverse_tcp
Alternativly target 3 can be used to execute generic commands, such as a web_delivery meterpreter powershell payload
or other customised command.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'PostgreSQL COPY FROM PROGRAM Command Execution',
    'description': '''
        Installations running Postgres 9.3 and above have functionality which allows for the superuser
        and users with 'pg_execute_server_program' to pipe to and from an external program using COPY.
        This allows arbitrary command execution as though you have console access.
        
        This module attempts to create a new table, then execute system commands in the context of
        copying the command output into the table.
        
        This module should work on all Postgres systems running version 9.3 and above.
        
        For Linux & OSX systems, target 1 is used with cmd payloads such as: cmd/unix/reverse_perl
        
        For Windows Systems, target 2 is used with powershell payloads such as: cmd/windows/powershell_reverse_tcp
        Alternativly target 3 can be used to execute generic commands, such as a web_delivery meterpreter powershell payload
        or other customised command.
    ''',
    'authors': [
        'Jacob Wilkin',
    ],
    'date': '2019-03-20',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Unix/OSX/Linux'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
