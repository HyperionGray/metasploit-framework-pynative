#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
ATutor 2.2.4 - Directory Traversal / Remote Code Execution, 

This module exploits an arbitrary file upload vulnerability together with
a directory traversal flaw in ATutor versions 2.2.4, 2.2.2 and 2.2.1 in
order to execute arbitrary commands.

It first creates a zip archive containing a malicious PHP file. The zip
archive takes advantage of a directory traversal vulnerability that will
cause the PHP file to be dropped in the root server directory (`htdocs`
for Windows and `html` for Linux targets). The PHP file contains an
encoded payload that allows for remote command execution on the
target server. The zip archive can be uploaded via two vectors, the
`Import New Language` function and the `Patcher` function. The module
first uploads the archive via `Import New Language` and then attempts to
execute the payload via an HTTP GET request to the PHP file  in the root
server directory. If no session is obtained, the module creates another
zip archive and attempts exploitation via `Patcher`.

Valid credentials for an ATutor admin account are required. This module
has been successfully tested against ATutor 2.2.4 running on Windows 10
(XAMPP server).
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'ATutor 2.2.4 - Directory Traversal / Remote Code Execution, ',
    'description': '''
        This module exploits an arbitrary file upload vulnerability together with
        a directory traversal flaw in ATutor versions 2.2.4, 2.2.2 and 2.2.1 in
        order to execute arbitrary commands.
        
        It first creates a zip archive containing a malicious PHP file. The zip
        archive takes advantage of a directory traversal vulnerability that will
        cause the PHP file to be dropped in the root server directory (`htdocs`
        for Windows and `html` for Linux targets). The PHP file contains an
        encoded payload that allows for remote command execution on the
        target server. The zip archive can be uploaded via two vectors, the
        `Import New Language` function and the `Patcher` function. The module
        first uploads the archive via `Import New Language` and then attempts to
        execute the payload via an HTTP GET request to the PHP file  in the root
        server directory. If no session is obtained, the module creates another
        zip archive and attempts exploitation via `Patcher`.
        
        Valid credentials for an ATutor admin account are required. This module
        has been successfully tested against ATutor 2.2.4 running on Windows 10
        (XAMPP server).
    ''',
    'authors': [
        'liquidsky (JMcPeters)',
        'Erik Wynter',
    ],
    'date': '2019-05-17',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Auto'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
