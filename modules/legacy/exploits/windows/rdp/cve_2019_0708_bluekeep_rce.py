#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
CVE-2019-0708 BlueKeep RDP Remote Windows Kernel Use After Free

The RDP termdd.sys driver improperly handles binds to internal-only channel MS_T120,
allowing a malformed Disconnect Provider Indication message to cause use-after-free.
With a controllable data/size remote nonpaged pool spray, an indirect call gadget of
the freed channel is used to achieve arbitrary code execution.

Windows 7 SP1 and Windows Server 2008 R2 are the only currently supported targets.

Windows 7 SP1 should be exploitable in its default configuration, assuming your target
selection is correctly matched to the system's memory layout.

HKLM\SYSTEM\CurrentControlSet\Control\TerminalServer\Winstations\RDP-Tcp\fDisableCam
*needs* to be set to 0 for exploitation to succeed against Windows Server 2008 R2.
This is a non-standard configuration for normal servers, and the target will crash if
the aforementioned Registry key is not set!

If the target is crashing regardless, you will likely need to determine the non-paged
pool base in kernel memory and set it as the GROOMBASE option.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'CVE-2019-0708 BlueKeep RDP Remote Windows Kernel Use After Free',
    'description': '''
        The RDP termdd.sys driver improperly handles binds to internal-only channel MS_T120,
        allowing a malformed Disconnect Provider Indication message to cause use-after-free.
        With a controllable data/size remote nonpaged pool spray, an indirect call gadget of
        the freed channel is used to achieve arbitrary code execution.
        
        Windows 7 SP1 and Windows Server 2008 R2 are the only currently supported targets.
        
        Windows 7 SP1 should be exploitable in its default configuration, assuming your target
        selection is correctly matched to the system's memory layout.
        
        HKLM\SYSTEM\CurrentControlSet\Control\TerminalServer\Winstations\RDP-Tcp\fDisableCam
        *needs* to be set to 0 for exploitation to succeed against Windows Server 2008 R2.
        This is a non-standard configuration for normal servers, and the target will crash if
        the aforementioned Registry key is not set!
        
        If the target is crashing regardless, you will likely need to determine the non-paged
        pool base in kernel memory and set it as the GROOMBASE option.
    ''',
    'authors': [
        'Sean Dillon <sean.dillon@risksense.com>',
        'Ryan Hanson',
        'OJ Reeves <oj@beyondbinary.io>',
        'Brent Cook <bcook@rapid7.com>',
    ],
    'date': '2019-05-14',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Automatic targeting via fingerprinting'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
