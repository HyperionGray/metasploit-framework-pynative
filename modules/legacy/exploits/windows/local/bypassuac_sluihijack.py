#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Windows UAC Protection Bypass (Via Slui File Handler Hijack)

This module will bypass UAC on Windows 8-10 by hijacking a special key in the Registry under
the Current User hive, and inserting a custom command that will get invoked when any binary
(.exe) application is launched. But slui.exe is an auto-elevated binary that is vulnerable
to file handler hijacking. When we run slui.exe with changed Registry key
(HKCU:\Software\Classes\exefile\shell\open\command), it will run our custom command as Admin
instead of slui.exe.

The module modifies the registry in order for this exploit to work. The modification is
reverted once the exploitation attempt has finished.

The module does not require the architecture of the payload to match the OS. If
specifying EXE::Custom your DLL should call ExitProcess() after starting the
payload in a different process.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Windows UAC Protection Bypass (Via Slui File Handler Hijack)',
    'description': '''
        This module will bypass UAC on Windows 8-10 by hijacking a special key in the Registry under
        the Current User hive, and inserting a custom command that will get invoked when any binary
        (.exe) application is launched. But slui.exe is an auto-elevated binary that is vulnerable
        to file handler hijacking. When we run slui.exe with changed Registry key
        (HKCU:\Software\Classes\exefile\shell\open\command), it will run our custom command as Admin
        instead of slui.exe.
        
        The module modifies the registry in order for this exploit to work. The modification is
        reverted once the exploitation attempt has finished.
        
        The module does not require the architecture of the payload to match the OS. If
        specifying EXE::Custom your DLL should call ExitProcess() after starting the
        payload in a different process.
    ''',
    'authors': [
        'bytecode-77',
        'gushmazuko',
    ],
    'date': '2018-01-15',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Windows x86'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
