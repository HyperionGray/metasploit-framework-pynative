#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
SYSTEM token impersonation through NTLM bits authentication on missing WinRM Service.

This module exploit BITS behavior which tries to connect to the
local Windows Remote Management server (WinRM) every times it
starts. The module launches a fake WinRM server which listen on
port 5985 and triggers BITS. When BITS starts, it tries to
authenticate to the Rogue WinRM server, which allows to steal a
SYSTEM token. This token is then used to launch a new process
as SYSTEM user. In the case of this exploit, notepad.exe is launched
as SYSTEM. Then, it write shellcode in its previous memory space
and trigger its execution. As this exploit uses reflective dll
injection, it does not write any file on the disk. See
/documentation/modules/exploit/windows/local/bits_ntlm_token_impersonation.md
for complementary words of information.

Vulnerable operating systems are Windows 10 and Windows servers where WinRM is not running.
Lab experiments has shown that Windows 7 does not exhibit the vulnerable behavior.

WARNING:

- As this exploit runs a service on the target (Fake WinRM on port
5985), a firewall popup may appear on target screen. Thus, this exploit
may not be completely silent.

- This exploit has been successfully tested on :
Windows 10 (10.0 Build 19041) 32 bits
Windows 10 Pro, Version 1903 (10.0 Build 18362) 64 bits

- This exploit failed because of no BITS authentication attempt on:
Windows 7 (6.1 Build 7601, Service Pack 1) 32 bits

- Windows servers are not vulnerable because a genuine WinRM
service is already running, except if the user has disabled it
(Or if this exploit succeed to terminate it).

- SE_IMPERSONATE_NAME or SE_ASSIGNPRIMARYTOKEN_NAME privs are
required.

- BITS must not be running.

- This exploit automatically perform above quoted checks.
run "check" command to run checklist.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'SYSTEM token impersonation through NTLM bits authentication on missing WinRM Service.',
    'description': '''
        This module exploit BITS behavior which tries to connect to the
        local Windows Remote Management server (WinRM) every times it
        starts. The module launches a fake WinRM server which listen on
        port 5985 and triggers BITS. When BITS starts, it tries to
        authenticate to the Rogue WinRM server, which allows to steal a
        SYSTEM token. This token is then used to launch a new process
        as SYSTEM user. In the case of this exploit, notepad.exe is launched
        as SYSTEM. Then, it write shellcode in its previous memory space
        and trigger its execution. As this exploit uses reflective dll
        injection, it does not write any file on the disk. See
        /documentation/modules/exploit/windows/local/bits_ntlm_token_impersonation.md
        for complementary words of information.
        
        Vulnerable operating systems are Windows 10 and Windows servers where WinRM is not running.
        Lab experiments has shown that Windows 7 does not exhibit the vulnerable behavior.
        
        WARNING:
        
        - As this exploit runs a service on the target (Fake WinRM on port
        5985), a firewall popup may appear on target screen. Thus, this exploit
        may not be completely silent.
        
        - This exploit has been successfully tested on :
        Windows 10 (10.0 Build 19041) 32 bits
        Windows 10 Pro, Version 1903 (10.0 Build 18362) 64 bits
        
        - This exploit failed because of no BITS authentication attempt on:
        Windows 7 (6.1 Build 7601, Service Pack 1) 32 bits
        
        - Windows servers are not vulnerable because a genuine WinRM
        service is already running, except if the user has disabled it
        (Or if this exploit succeed to terminate it).
        
        - SE_IMPERSONATE_NAME or SE_ASSIGNPRIMARYTOKEN_NAME privs are
        required.
        
        - BITS must not be running.
        
        - This exploit automatically perform above quoted checks.
        run "check" command to run checklist.
    ''',
    'authors': [
        'Cassandre',
        's POC for metasploit
            ',
        ', # Lonely / Juicy Potato. Has written the POC
            ',
        ',
            ',
    ],
    'date': '2019-12-06',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Automatic'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
