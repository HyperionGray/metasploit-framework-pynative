#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Safari Webkit Proxy Object Type Confusion

This module exploits a type confusion bug in the Javascript Proxy object in
WebKit. The DFG JIT does not take into account that, through the use of a Proxy,
it is possible to run arbitrary JS code during the execution of a CreateThis
operation. This makes it possible to change the structure of e.g. an argument
without causing a bailout, leading to a type confusion (CVE-2018-4233).

The type confusion leads to the ability to allocate fake Javascript objects,
as well as the ability to find the address in memory of a Javascript object.
This allows us to construct a fake JSCell object that can be used to read
and write arbitrary memory from Javascript.  The module then uses a ROP chain
to write the first stage shellcode into executable memory within the Safari
process and kick off its execution.

The first stage maps the second stage macho (containing CVE-2017-13861) into
executable memory, and jumps to its entrypoint. The CVE-2017-13861 async_wake
exploit leads to a kernel task port (TFP0) that can read and write arbitrary
kernel memory. The processes credential and sandbox structure in the kernel
is overwritten and the meterpreter payloads code signature hash is added to
the kernels trust cache, allowing Safari to load and execute the (self-signed)
meterpreter payload.
"""

import logging
import sys
import os

# Add lib path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../../lib'))

from metasploit import module
from msf.http_client import HTTPClient, CheckCode

metadata = {
    'name': 'Safari Webkit Proxy Object Type Confusion',
    'description': '''
        This module exploits a type confusion bug in the Javascript Proxy object in
        WebKit. The DFG JIT does not take into account that, through the use of a Proxy,
        it is possible to run arbitrary JS code during the execution of a CreateThis
        operation. This makes it possible to change the structure of e.g. an argument
        without causing a bailout, leading to a type confusion (CVE-2018-4233).
        
        The type confusion leads to the ability to allocate fake Javascript objects,
        as well as the ability to find the address in memory of a Javascript object.
        This allows us to construct a fake JSCell object that can be used to read
        and write arbitrary memory from Javascript.  The module then uses a ROP chain
        to write the first stage shellcode into executable memory within the Safari
        process and kick off its execution.
        
        The first stage maps the second stage macho (containing CVE-2017-13861) into
        executable memory, and jumps to its entrypoint. The CVE-2017-13861 async_wake
        exploit leads to a kernel task port (TFP0) that can read and write arbitrary
        kernel memory. The processes credential and sandbox structure in the kernel
        is overwritten and the meterpreter payloads code signature hash is added to
        the kernels trust cache, allowing Safari to load and execute the (self-signed)
        meterpreter payload.
    ''',
    'authors': [
        'saelo',
        'niklasb',
        'Ian Beer',
        'siguza',
    ],
    'date': '2018-03-15',
    'license': 'MSF_LICENSE',
    'type': 'remote_exploit',  # TODO: Adjust type
    'targets': [
        {'name': 'Automatic'},  # TODO: Add platform/arch
    ],
    'options': {
        'rhost': {'type': 'address', 'description': 'Target address', 'required': True},
        'rport': {'type': 'port', 'description': 'Target port', 'required': True, 'default': 80},
        # TODO: Add module-specific options
    },
    'notes': {
        'stability': ['CRASH_SAFE'],  # TODO: Adjust
        'reliability': ['REPEATABLE_SESSION'],  # TODO: Adjust
        'side_effects': ['IOC_IN_LOGS']  # TODO: Adjust
    }
}


def run(args):
    '''Module entry point.'''
    module.LogHandler.setup(msg_prefix=f"{args['rhost']}:{args['rport']} - ")
    
    rhost = args['rhost']
    rport = args['rport']
    
    logging.info('Starting module execution...')
    
    # TODO: Implement module logic
    # 1. Create HTTP client or TCP socket
    # 2. Check if target is vulnerable
    # 3. Exploit the vulnerability
    # 4. Handle success/failure
    
    try:
        client = HTTPClient(rhost=rhost, rport=rport)
        
        # Your exploit code here
        response = client.get('/')
        if response:
            logging.info(f'Response status: {response.status_code}')
        
        client.close()
        
    except Exception as e:
        logging.error(f'Exploitation failed: {e}')
        return
    
    logging.info('Module execution complete')


if __name__ == '__main__':
    module.run(metadata, run)
