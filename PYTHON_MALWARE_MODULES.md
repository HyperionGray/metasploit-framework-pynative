# Python Malware Simulation Modules

This document describes the Python-native malware simulation modules added as part of the "Python round 2" migration.

## Overview

Three malware simulator modules have been converted from Ruby to Python, demonstrating safe penetration testing techniques with automatic cleanup:

1. **Multi-Platform Persistence Simulator** - Cross-platform persistence simulation
2. **Windows Registry Hijack Simulator** - Windows registry-based persistence
3. **Linux Rootkit Simulator** - Linux rootkit stealth techniques

## Base Class: `Malware`

Located in `python_framework/core/malware.py`, this base class provides:

### Features
- **Time Bomb Functionality**: Automatic expiration after configurable duration
- **Artifact Tracking**: All created files, registry keys, and processes are tracked
- **Automatic Cleanup**: Artifacts are automatically removed when time expires
- **Safe Simulation Mode**: By default, only simulates behavior without persistence
- **Session Integration**: Works with Metasploit sessions (meterpreter/shell)

### Configuration Options
```python
datastore = {
    'DURATION': 300,           # Time bomb duration in seconds (default: 5 minutes)
    'AUTO_CLEANUP': True,      # Automatically cleanup artifacts
    'SIMULATE_ONLY': True,     # Only simulate, don't actually persist
    'CLEANUP_SIGNAL': '',      # Optional signal file to trigger cleanup
    'VERBOSE_SIMULATION': True # Show detailed simulation activities
}
```

## Module 1: Multi-Platform Persistence Simulator

**File**: `modules/malware/multi/persistence_simulator.py`

### Description
Simulates malware persistence mechanisms across Windows, Linux, and macOS platforms. Creates temporary files, registry entries (Windows), and startup scripts that automatically clean up.

### Supported Platforms
- Windows
- Linux
- macOS
- Unix

### Simulation Techniques
- **Windows**: Registry run keys, scheduled tasks, fake executables
- **Linux**: Crontab entries, init scripts, systemd services
- **macOS**: LaunchAgents, application bundles
- **Cross-platform**: Network beaconing, file enumeration, process enumeration

### Options
```python
{
    'SIMULATE_STARTUP': True,           # Simulate startup persistence
    'SIMULATE_SCHEDULED_TASK': True,    # Simulate scheduled tasks/cron
    'CREATE_FAKE_PROCESSES': False,     # Create fake malware processes
    'PERSISTENCE_NAME': 'SystemUpdate', # Name for persistence mechanism
    'ACTIVITY_INTERVAL': 30,            # Seconds between simulated activities
}
```

### Usage Example
```python
from modules.malware.multi.persistence_simulator import PersistenceSimulator

# Create simulator
sim = PersistenceSimulator(session=None)

# Configure
sim.datastore['DURATION'] = 300  # 5 minutes
sim.datastore['PERSISTENCE_NAME'] = 'WindowsUpdate'
sim.datastore['SIMULATE_ONLY'] = True

# Run simulation
sim.run()
```

### Simulated Activities
- Creating persistence mechanisms (startup scripts, registry keys)
- Network beaconing to fake C2 servers
- File and process enumeration
- System information gathering

## Module 2: Windows Registry Hijack Simulator

**File**: `modules/malware/windows/registry_hijack_simulator.py`

### Description
Simulates advanced Windows registry hijacking techniques commonly used by malware for persistence and privilege escalation. All registry changes are temporary and automatically cleaned up.

### Supported Platform
- Windows only

### Simulation Techniques
- **COM Object Hijacking**: Hijacking COM CLSID InprocServer32 entries
- **DLL Hijacking**: App Paths registry manipulation
- **Winlogon Hijacking**: Winlogon Notify DLL injection simulation
- **IFEO Hijacking**: Image File Execution Options debugger attachment

### Options
```python
{
    'SIMULATE_COM_HIJACK': True,        # Simulate COM object hijacking
    'SIMULATE_DLL_HIJACK': True,        # Simulate DLL hijacking
    'SIMULATE_WINLOGON_HIJACK': True,   # Simulate Winlogon hijacking
    'SIMULATE_IFEO_HIJACK': False,      # Simulate IFEO hijacking (dangerous)
    'TARGET_PROCESS': 'notepad.exe',    # Target for IFEO hijacking
    'CREATE_FAKE_DLLS': True,           # Create fake DLL files
    'HIJACK_DLL_NAME': 'malware_sim.dll' # Name for hijacked DLL
}
```

### Usage Example
```python
from modules.malware.windows.registry_hijack_simulator import RegistryHijackSimulator

# Create simulator
sim = RegistryHijackSimulator(session=None)

# Configure
sim.datastore['DURATION'] = 300
sim.datastore['SIMULATE_IFEO_HIJACK'] = False  # Too dangerous for most tests
sim.datastore['SIMULATE_ONLY'] = True

# Run simulation
sim.run()
```

### Simulated Activities
- Registry monitoring for security software
- Process injection attempts (simulated)
- Credential harvesting (simulated)
- Lateral movement preparation (simulated)

### Warning
⚠️ **IFEO hijacking is disabled by default** as it can affect system stability. Only enable in isolated test environments.

## Module 3: Linux Rootkit Simulator

**File**: `modules/malware/linux/rootkit_simulator.py`

### Description
Simulates common Linux rootkit techniques including process hiding, file hiding, network connection hiding, and system call hooking. Demonstrates stealth techniques while maintaining complete safety through time bomb functionality.

### Supported Platform
- Linux only

### Simulation Techniques
- **Process Hiding**: Fake `ps` command that filters processes
- **File Hiding**: Fake `ls` command that hides rootkit files
- **Network Hiding**: Fake `netstat` command that hides connections
- **Log Evasion**: Simulates log cleaning techniques
- **Kernel Module**: Simulates kernel module loading (safe simulation)

### Options
```python
{
    'SIMULATE_PROCESS_HIDING': True,     # Simulate process hiding
    'SIMULATE_FILE_HIDING': True,        # Simulate file hiding
    'SIMULATE_NETWORK_HIDING': True,     # Simulate network hiding
    'SIMULATE_LOG_EVASION': True,        # Simulate log evasion
    'SIMULATE_KERNEL_MODULE': False,     # Simulate kernel module (advanced)
    'HIDDEN_PROCESS_NAME': 'kworker_sim', # Name for hidden process
    'CREATE_FAKE_BINARIES': True,        # Create fake system binaries
    'ROOTKIT_DIR': '/tmp/.hidden_rk'     # Directory for rootkit files
}
```

### Usage Example
```python
from modules.malware.linux.rootkit_simulator import RootkitSimulator

# Create simulator
sim = RootkitSimulator(session=None)

# Configure
sim.datastore['DURATION'] = 300
sim.datastore['ROOTKIT_DIR'] = '/tmp/.rootkit_test'
sim.datastore['SIMULATE_ONLY'] = True

# Run simulation
sim.run()
```

### Simulated Activities
- Stealth checks and monitoring
- Data collection (SSH keys, configs, credentials)
- C2 communication beaconing
- Privilege escalation attempts
- Lateral movement scanning

### Created Artifacts
- Fake system binaries (`ps`, `ls`, `netstat`, `lsof`)
- Fake kernel module (`.ko` file)
- Hidden process scripts
- Hidden data files
- Log cleaning scripts

## Safety Features

### Automatic Cleanup
All modules include automatic cleanup that:
- Tracks all created files, directories, and registry keys
- Monitors time bomb expiration
- Removes all artifacts when time expires
- Handles cleanup signal files for manual triggering

### Simulation Mode
By default, all modules run in `SIMULATE_ONLY` mode which:
- Logs what would be done without actually doing it
- Creates harmless text files instead of binaries
- Doesn't modify system configurations
- Perfect for demonstrations and training

### Time Bomb
The time bomb feature ensures:
- Simulations have a maximum duration
- Automatic cleanup after expiration
- Warning messages before expiration
- Cannot be disabled (safety first)

## Testing

All modules have been tested for:
- ✅ Syntax validation
- ✅ Module instantiation
- ✅ Configuration options
- ✅ Time bomb functionality
- ✅ Artifact tracking
- ✅ Code review compliance
- ✅ Security vulnerabilities (CodeQL: 0 alerts)

## Integration with Metasploit

These modules can be integrated with Metasploit sessions:

```python
# With an active Metasploit session
sim = PersistenceSimulator(session=my_session)

# Session platform detection
platform = session.platform  # 'windows', 'linux', 'osx', etc.

# Session type support
session_type = session.type  # 'meterpreter' or 'shell'

# Execute commands through session
session.shell_command_token("whoami")
```

## Development Guidelines

### Creating New Malware Modules

1. **Inherit from Malware base class**:
```python
from python_framework.core.malware import Malware

class MyMalwareSimulator(Malware):
    def __init__(self, session=None):
        super().__init__(session)
        # Setup module info and options
    
    def run_malware_simulation(self):
        # Implement simulation logic
        pass
```

2. **Register artifacts for cleanup**:
```python
self.register_artifact('/path/to/file', ArtifactType.FILE)
self.register_artifact('/path/to/dir', ArtifactType.DIRECTORY)
self.register_artifact('HKEY_...', ArtifactType.REGISTRY)
```

3. **Check for termination**:
```python
while not self.should_terminate():
    # Simulation activities
    time.sleep(interval)
```

4. **Use simulation helpers**:
```python
self.simulate_file_drop('/path/to/file', content)
self.simulate_registry_persistence(key, value, data)
```

## Security Considerations

### For Penetration Testers
- Always use `SIMULATE_ONLY=True` in production environments
- Set appropriate `DURATION` values to prevent orphaned artifacts
- Test cleanup functionality before deployment
- Document all simulation activities in reports

### For Developers
- Never disable time bomb functionality
- Always track artifacts for cleanup
- Use safe defaults (simulation mode on)
- Validate all user inputs
- Escape regex patterns in user-provided data

## Troubleshooting

### Module fails to instantiate
```python
# Ensure python_framework is in path
import sys
sys.path.insert(0, 'python_framework')
```

### Artifacts not cleaned up
- Check `AUTO_CLEANUP` is set to `True`
- Verify time bomb expired (`time_bomb_expired()`)
- Ensure cleanup signal file is accessible if configured

### Session-based operations fail
- Verify session is active: `session.type`
- Check session platform: `session.platform`
- Ensure proper session permissions

## Future Enhancements

Potential additions for "Python round 3":
- Post-exploitation modules
- Auxiliary scanner modules
- Encoder/decoder modules
- Payload generation modules
- Additional protocol handlers

## License

These modules maintain compatibility with the Metasploit Framework License (MSF_LICENSE).

## Contributing

When contributing new malware simulation modules:
1. Follow the established patterns in existing modules
2. Include comprehensive documentation
3. Add safety features (time bomb, cleanup)
4. Test thoroughly with different configurations
5. Submit code for security review
6. Update this documentation

---

**Generated for**: Python Round 2 Migration  
**Date**: 2025-12-14  
**Status**: Complete ✓
