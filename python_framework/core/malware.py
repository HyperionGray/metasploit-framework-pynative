"""
Malware simulation module with time bomb functionality for Python-native Metasploit Framework

This module provides the foundation for safe malware simulations with automatic cleanup.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Union
from enum import Enum
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import time
import logging
import base64


class ArtifactType(Enum):
    """Types of artifacts that can be created and tracked"""
    FILE = "file"
    DIRECTORY = "directory"
    REGISTRY = "registry"
    SERVICE = "service"
    PROCESS = "process"


@dataclass
class Artifact:
    """Represents a tracked artifact for cleanup"""
    path: str
    artifact_type: ArtifactType
    created_at: datetime = field(default_factory=datetime.now)


class MalwareException(Exception):
    """Base exception for malware simulation"""
    pass


class MalwareComplete(MalwareException):
    """Malware simulation completed successfully"""
    pass


class MalwareFailed(MalwareException):
    """Malware simulation failed"""
    pass


class TimeBombExpired(MalwareException):
    """Time bomb has expired"""
    pass


class Malware(ABC):
    """
    Base class for malware simulation modules with time bomb functionality.
    
    This class provides:
    - Time bomb functionality with automatic cleanup
    - Artifact tracking and cleanup
    - Safe simulation modes
    - Session integration
    """
    
    def __init__(self, session: Any = None):
        """
        Initialize malware simulation module.
        
        Args:
            session: The Metasploit session to run against
        """
        self.session = session
        self.logger = logging.getLogger(f"malware.{self.__class__.__name__}")
        
        # Time bomb configuration
        self.start_time: Optional[datetime] = None
        self.duration_seconds: int = 300  # Default 5 minutes
        self.needs_cleanup: bool = True
        
        # Artifact tracking
        self.cleanup_artifacts: List[Artifact] = []
        
        # Configuration options
        self.datastore: Dict[str, Any] = {
            'DURATION': 300,
            'AUTO_CLEANUP': True,
            'SIMULATE_ONLY': True,
            'CLEANUP_SIGNAL': '',
            'VERBOSE_SIMULATION': True,
        }
    
    def setup(self) -> None:
        """Initialize malware simulation and time bomb"""
        self.start_time = datetime.now()
        self.duration_seconds = self.datastore.get('DURATION', 300)
        self.needs_cleanup = self.datastore.get('AUTO_CLEANUP', True)
        
        self.print_status(f"Malware simulation started at {self.start_time}")
        self.print_status(f"Time bomb set for {self.duration_seconds} seconds")
        warning_msg = "Auto-cleanup ENABLED" if self.needs_cleanup else "Auto-cleanup DISABLED"
        self.print_warning(warning_msg)
    
    def print_status(self, message: str) -> None:
        """Print a status message"""
        self.logger.info(f"[*] {message}")
        print(f"[*] {message}")
    
    def print_good(self, message: str) -> None:
        """Print a success message"""
        self.logger.info(f"[+] {message}")
        print(f"[+] {message}")
    
    def print_error(self, message: str) -> None:
        """Print an error message"""
        self.logger.error(f"[-] {message}")
        print(f"[-] {message}")
    
    def print_warning(self, message: str) -> None:
        """Print a warning message"""
        self.logger.warning(f"[!] {message}")
        print(f"[!] {message}")
    
    def time_bomb_expired(self) -> bool:
        """Check if the time bomb has expired"""
        if not self.start_time or not self.duration_seconds:
            return False
        
        elapsed = (datetime.now() - self.start_time).total_seconds()
        return elapsed >= self.duration_seconds
    
    def time_remaining(self) -> int:
        """Get remaining time in seconds"""
        if not self.start_time or not self.duration_seconds:
            return 0
        
        elapsed = (datetime.now() - self.start_time).total_seconds()
        remaining = self.duration_seconds - elapsed
        return max(int(remaining), 0)
    
    def cleanup_signal_present(self) -> bool:
        """Check if cleanup signal file exists"""
        signal_file = self.datastore.get('CLEANUP_SIGNAL', '')
        if not signal_file:
            return False
        
        try:
            if not self.session:
                return False
                
            session_type = getattr(self.session, 'type', None)
            
            if session_type == 'meterpreter':
                # Check using meterpreter file system
                return self.session.fs.file.stat(signal_file) is not None
            elif session_type == 'shell':
                # Check using shell command
                result = self.session.shell_command_token(f"test -f {signal_file} && echo exists")
                return 'exists' in result
        except Exception:
            return False
        
        return False
    
    def should_terminate(self) -> bool:
        """Check if module should terminate (time bomb or signal)"""
        return self.time_bomb_expired() or self.cleanup_signal_present()
    
    def register_artifact(self, path: str, artifact_type: ArtifactType = ArtifactType.FILE) -> None:
        """
        Register an artifact for cleanup tracking.
        
        Args:
            path: Path to the artifact
            artifact_type: Type of artifact
        """
        artifact = Artifact(path=path, artifact_type=artifact_type)
        self.cleanup_artifacts.append(artifact)
        self.print_good(f"Registered artifact for cleanup: {path}")
    
    def cleanup_file(self, path: str) -> None:
        """Clean up a file"""
        if not self.session:
            self.print_warning(f"No session available to cleanup file: {path}")
            return
        
        try:
            session_type = getattr(self.session, 'type', None)
            platform = getattr(self.session, 'platform', 'unknown')
            
            if session_type == 'meterpreter':
                self.session.fs.file.rm(path)
            elif session_type == 'shell':
                if platform == 'windows':
                    self.session.shell_command_token(f'del /f /q "{path}"')
                else:
                    self.session.shell_command_token(f'rm -f "{path}"')
            
            self.print_status(f"Removed file: {path}")
        except Exception as e:
            self.print_error(f"Failed to cleanup file {path}: {e}")
    
    def cleanup_directory(self, path: str) -> None:
        """Clean up a directory"""
        if not self.session:
            self.print_warning(f"No session available to cleanup directory: {path}")
            return
        
        try:
            session_type = getattr(self.session, 'type', None)
            platform = getattr(self.session, 'platform', 'unknown')
            
            if session_type == 'meterpreter':
                self.session.fs.dir.rmdir(path)
            elif session_type == 'shell':
                if platform == 'windows':
                    self.session.shell_command_token(f'rmdir /s /q "{path}"')
                else:
                    self.session.shell_command_token(f'rm -rf "{path}"')
            
            self.print_status(f"Removed directory: {path}")
        except Exception as e:
            self.print_error(f"Failed to cleanup directory {path}: {e}")
    
    def cleanup_registry(self, path: str) -> None:
        """Clean up a registry entry (Windows only)"""
        if not self.session:
            self.print_warning(f"No session available to cleanup registry: {path}")
            return
        
        platform = getattr(self.session, 'platform', 'unknown')
        if platform != 'windows':
            return
        
        try:
            session_type = getattr(self.session, 'type', None)
            
            if session_type == 'meterpreter':
                self.session.sys.registry.delete_key(path)
            elif session_type == 'shell':
                self.session.shell_command_token(f'reg delete "{path}" /f')
            
            self.print_status(f"Removed registry key: {path}")
        except Exception as e:
            self.print_error(f"Failed to cleanup registry {path}: {e}")
    
    def cleanup_service(self, name: str) -> None:
        """Clean up a service"""
        self.print_status(f"Stopping and removing service: {name}")
        # Implementation depends on platform and service type
    
    def cleanup_process(self, pid_or_name: str) -> None:
        """Clean up a process"""
        self.print_status(f"Terminating process: {pid_or_name}")
        # Implementation depends on platform
    
    def cleanup_artifacts(self) -> None:
        """Clean up all registered artifacts"""
        if not self.cleanup_artifacts:
            return
        
        self.print_status(f"Time bomb expired! Cleaning up {len(self.cleanup_artifacts)} artifacts...")
        
        for artifact in self.cleanup_artifacts:
            try:
                if artifact.artifact_type == ArtifactType.FILE:
                    self.cleanup_file(artifact.path)
                elif artifact.artifact_type == ArtifactType.DIRECTORY:
                    self.cleanup_directory(artifact.path)
                elif artifact.artifact_type == ArtifactType.REGISTRY:
                    self.cleanup_registry(artifact.path)
                elif artifact.artifact_type == ArtifactType.SERVICE:
                    self.cleanup_service(artifact.path)
                elif artifact.artifact_type == ArtifactType.PROCESS:
                    self.cleanup_process(artifact.path)
                else:
                    self.print_warning(f"Unknown artifact type: {artifact.artifact_type}")
            except Exception as e:
                self.print_error(f"Failed to cleanup {artifact.path}: {e}")
        
        self.cleanup_artifacts.clear()
        self.print_good("Malware simulation cleanup completed")
    
    def simulate_file_drop(self, path: str, content: Optional[str] = None) -> bool:
        """
        Simulate file creation with automatic cleanup registration.
        
        Args:
            path: Path where file should be created
            content: File content (optional)
            
        Returns:
            True if successful
        """
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status(f"SIMULATION: Would create file at {path}")
            return True
        
        if not self.session:
            self.print_error("No session available for file operations")
            return False
        
        content = content or self.generate_fake_malware_content()
        
        try:
            session_type = getattr(self.session, 'type', None)
            platform = getattr(self.session, 'platform', 'unknown')
            
            if session_type == 'meterpreter':
                self.session.fs.file.upload_file(path, content)
            elif session_type == 'shell':
                encoded_content = base64.b64encode(content.encode()).decode()
                if platform == 'windows':
                    self.session.shell_command_token(f'echo {encoded_content} | certutil -decode - "{path}"')
                else:
                    self.session.shell_command_token(f'echo "{encoded_content}" | base64 -d > "{path}"')
            
            self.register_artifact(path, ArtifactType.FILE)
            self.print_good(f"Created malware file: {path}")
            return True
        except Exception as e:
            self.print_error(f"Failed to create file {path}: {e}")
            return False
    
    def simulate_registry_persistence(self, key: str, value: str, data: str) -> bool:
        """
        Simulate registry persistence (Windows only).
        
        Args:
            key: Registry key path
            value: Registry value name
            data: Registry data
            
        Returns:
            True if successful
        """
        if self.datastore.get('SIMULATE_ONLY', True):
            self.print_status(f"SIMULATION: Would create registry entry {key}\\{value}")
            return True
        
        if not self.session:
            self.print_error("No session available for registry operations")
            return False
        
        platform = getattr(self.session, 'platform', 'unknown')
        if platform != 'windows':
            return False
        
        try:
            session_type = getattr(self.session, 'type', None)
            
            if session_type == 'meterpreter':
                self.session.sys.registry.set_value(key, value, data)
            elif session_type == 'shell':
                self.session.shell_command_token(f'reg add "{key}" /v "{value}" /d "{data}" /f')
            
            self.register_artifact(f"{key}\\{value}", ArtifactType.REGISTRY)
            self.print_good(f"Created registry persistence: {key}\\{value}")
            return True
        except Exception as e:
            self.print_error(f"Failed to create registry entry: {e}")
            return False
    
    def generate_fake_malware_content(self) -> str:
        """Generate fake malware content for simulation"""
        platform = 'unknown'
        if self.session:
            platform = getattr(self.session, 'platform', 'unknown')
        
        if platform == 'windows':
            content = "@echo off\n"
        else:
            content = "#!/bin/bash\n"
        
        content += f"""REM Metasploit Malware Simulation
REM This is a HARMLESS simulation for penetration testing
REM Created: {datetime.now()}
REM Duration: {self.duration_seconds} seconds
REM Auto-cleanup: {self.needs_cleanup}

echo "Malware simulation running..."
echo "This is NOT real malware - it's a penetration testing simulation"
echo "Time remaining: {self.time_remaining()} seconds"
"""
        return content
    
    def run_with_time_bomb(self) -> None:
        """Main execution wrapper with time bomb checking"""
        try:
            # Start the malware simulation
            self.run_malware_simulation()
            
            # Monitor for time bomb expiration
            while not self.should_terminate():
                time.sleep(5)  # Check every 5 seconds
                
                remaining = self.time_remaining()
                if 25 < remaining <= 30:
                    self.print_warning(f"Time bomb warning: {remaining} seconds remaining")
            
            if self.time_bomb_expired():
                self.print_error("Time bomb expired!")
                raise TimeBombExpired("Malware simulation time limit reached")
            elif self.cleanup_signal_present():
                self.print_status("Cleanup signal detected")
        
        except TimeBombExpired as e:
            self.print_error(f"Time bomb detonated: {e}")
        except Exception as e:
            self.print_error(f"Malware simulation error: {e}")
            self.logger.exception("Exception during malware simulation")
        finally:
            if self.needs_cleanup:
                self.cleanup_artifacts()
    
    @abstractmethod
    def run_malware_simulation(self) -> None:
        """
        Override this method in specific malware modules.
        
        This is where the actual malware simulation logic should be implemented.
        """
        pass
    
    def run(self) -> None:
        """Main run method - calls the time bomb wrapper"""
        self.print_status("Starting malware simulation with time bomb functionality")
        self.setup()
        self.run_with_time_bomb()
