"""
Base Exploit class for Python-native Metasploit Framework

This module provides the foundation for all exploit modules in the Python framework.
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any, Union
from enum import Enum
import logging
from dataclasses import dataclass, field
from datetime import datetime


class ExploitRank(Enum):
    """Exploit reliability rankings"""
    MANUAL = "Manual"
    LOW = "Low"
    AVERAGE = "Average"
    NORMAL = "Normal"
    GOOD = "Good"
    GREAT = "Great"
    EXCELLENT = "Excellent"


class TargetArch(Enum):
    """Target architectures"""
    X86 = "x86"
    X64 = "x64"
    ARM = "arm"
    AARCH64 = "aarch64"
    MIPS = "mips"
    PPC = "ppc"
    SPARC = "sparc"
    CMD = "cmd"


class Platform(Enum):
    """Target platforms"""
    WINDOWS = "windows"
    LINUX = "linux"
    UNIX = "unix"
    OSX = "osx"
    BSD = "bsd"
    ANDROID = "android"
    IOS = "ios"


class PayloadType(Enum):
    """Payload types"""
    BIND_TCP = "bind_tcp"
    REVERSE_TCP = "reverse_tcp"
    REVERSE_HTTP = "reverse_http"
    REVERSE_HTTPS = "reverse_https"
    SSH_INTERACT = "ssh_interact"
    UNIX_CMD = "unix_cmd"
    WINDOWS_CMD = "windows_cmd"


@dataclass
class ExploitTarget:
    """Represents an exploit target configuration"""
    name: str
    platform: List[Platform]
    arch: List[TargetArch]
    payload_type: PayloadType
    default_options: Dict[str, Any] = field(default_factory=dict)


@dataclass
class ExploitOption:
    """Represents a configurable exploit option"""
    name: str
    required: bool
    description: str
    default_value: Any = None
    data_type: type = str


@dataclass
class ExploitInfo:
    """Exploit metadata and configuration"""
    name: str
    description: str
    author: List[str]
    references: List[str] = field(default_factory=list)
    disclosure_date: Optional[str] = None
    rank: ExploitRank = ExploitRank.NORMAL
    targets: List[ExploitTarget] = field(default_factory=list)
    default_target: int = 0
    platform: List[Platform] = field(default_factory=list)
    arch: List[TargetArch] = field(default_factory=list)
    privileged: bool = False
    license: str = "MSF_LICENSE"
    notes: Dict[str, List[str]] = field(default_factory=dict)


class ExploitResult:
    """Result of an exploit attempt"""
    def __init__(self, success: bool, message: str = "", data: Dict[str, Any] = None):
        self.success = success
        self.message = message
        self.data = data or {}
        self.timestamp = datetime.now()


class Exploit(ABC):
    """
    Base class for all exploit modules in the Python framework.
    
    This class provides the foundation for exploit development with:
    - Standardized interface for exploit execution
    - Configuration management
    - Target selection
    - Payload integration
    - Logging and error handling
    """
    
    def __init__(self, info: ExploitInfo):
        self.info = info
        self.options: Dict[str, ExploitOption] = {}
        self.datastore: Dict[str, Any] = {}
        self.logger = logging.getLogger(f"exploit.{self.__class__.__name__}")
        self.current_target: Optional[ExploitTarget] = None
        
        # Set default target
        if self.info.targets:
            self.current_target = self.info.targets[self.info.default_target]
    
    def register_option(self, option: ExploitOption) -> None:
        """Register a configurable option for this exploit"""
        self.options[option.name] = option
        if option.default_value is not None:
            self.datastore[option.name] = option.default_value
    
    def register_options(self, options: List[ExploitOption]) -> None:
        """Register multiple options at once"""
        for option in options:
            self.register_option(option)
    
    def set_option(self, name: str, value: Any) -> None:
        """Set the value of an option"""
        if name in self.options:
            self.datastore[name] = value
        else:
            raise ValueError(f"Unknown option: {name}")
    
    def get_option(self, name: str, default: Any = None) -> Any:
        """Get the value of an option"""
        return self.datastore.get(name, default)
    
    def set_target(self, target_index: int) -> None:
        """Set the current target"""
        if 0 <= target_index < len(self.info.targets):
            self.current_target = self.info.targets[target_index]
        else:
            raise ValueError(f"Invalid target index: {target_index}")
    
    def print_status(self, message: str) -> None:
        """Print a status message"""
        self.logger.info(f"[*] {message}")
        print(f"[*] {message}")
    
    def print_good(self, message: str) -> None:
        """Print a success message"""
        self.logger.info(f"[+] {message}")
        print(f"[+] {message}")
    
    def print_error(self, message: str) -> None:
        """Print an error message"""
        self.logger.error(f"[-] {message}")
        print(f"[-] {message}")
    
    def print_warning(self, message: str) -> None:
        """Print a warning message"""
        self.logger.warning(f"[!] {message}")
        print(f"[!] {message}")
    
    def vprint_status(self, message: str) -> None:
        """Print a verbose status message"""
        if self.get_option('VERBOSE', False):
            self.print_status(message)
    
    def vprint_good(self, message: str) -> None:
        """Print a verbose success message"""
        if self.get_option('VERBOSE', False):
            self.print_good(message)
    
    def vprint_error(self, message: str) -> None:
        """Print a verbose error message"""
        if self.get_option('VERBOSE', False):
            self.print_error(message)
    
    @abstractmethod
    def check(self) -> ExploitResult:
        """
        Check if the target is vulnerable.
        
        Returns:
            ExploitResult indicating if the target appears vulnerable
        """
        pass
    
    @abstractmethod
    def exploit(self) -> ExploitResult:
        """
        Execute the exploit against the target.
        
        Returns:
            ExploitResult indicating success/failure and any relevant data
        """
        pass
    
    def run(self) -> ExploitResult:
        """
        Main entry point for exploit execution.
        
        This method handles the complete exploit workflow:
        1. Validate configuration
        2. Check target (if auto-check enabled)
        3. Execute exploit
        4. Handle results
        """
        try:
            # Validate required options
            for name, option in self.options.items():
                if option.required and name not in self.datastore:
                    return ExploitResult(False, f"Required option {name} not set")
            
            # Auto-check if enabled
            if self.get_option('AUTO_CHECK', True):
                self.print_status("Checking if target is vulnerable...")
                check_result = self.check()
                if not check_result.success:
                    self.print_error(f"Target does not appear vulnerable: {check_result.message}")
                    return check_result
                else:
                    self.print_good("Target appears vulnerable")
            
            # Execute exploit
            self.print_status("Executing exploit...")
            result = self.exploit()
            
            if result.success:
                self.print_good(f"Exploit completed successfully: {result.message}")
            else:
                self.print_error(f"Exploit failed: {result.message}")
            
            return result
            
        except Exception as e:
            error_msg = f"Exploit execution failed with exception: {str(e)}"
            self.logger.exception(error_msg)
            self.print_error(error_msg)
            return ExploitResult(False, error_msg)


class RemoteExploit(Exploit):
    """Base class for remote exploits"""
    
    def __init__(self, info: ExploitInfo):
        super().__init__(info)
        
        # Common remote exploit options
        self.register_options([
            ExploitOption("RHOSTS", True, "Target host(s)", ""),
            ExploitOption("RPORT", True, "Target port", 80, int),
            ExploitOption("SSL", False, "Use SSL/TLS", False, bool),
            ExploitOption("TARGETURI", False, "Target URI path", "/", str),
            ExploitOption("ConnectTimeout", False, "Connection timeout", 10, int),
            ExploitOption("VERBOSE", False, "Enable verbose output", False, bool),
            ExploitOption("AUTO_CHECK", False, "Enable automatic target checking", True, bool)
        ])


class LocalExploit(Exploit):
    """Base class for local exploits"""
    
    def __init__(self, info: ExploitInfo):
        super().__init__(info)
        
        # Common local exploit options
        self.register_options([
            ExploitOption("SESSION", True, "Session to use", "", str),
            ExploitOption("VERBOSE", False, "Enable verbose output", False, bool),
            ExploitOption("AUTO_CHECK", False, "Enable automatic target checking", True, bool)
        ])