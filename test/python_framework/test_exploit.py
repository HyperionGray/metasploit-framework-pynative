#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Unit tests for the Exploit base classes.

This test module validates the Python implementation of exploit base classes,
ensuring proper functionality of the exploit framework foundation.
"""

import unittest
from unittest.mock import patch, MagicMock
from datetime import datetime

from python_framework.core.exploit import (
    ExploitRank,
    TargetArch,
    Platform,
    PayloadType,
    ExploitTarget,
    ExploitOption,
    ExploitInfo,
    ExploitResult,
    Exploit,
    RemoteExploit,
    LocalExploit,
)


class TestEnums(unittest.TestCase):
    """Test enum definitions"""

    def test_exploit_rank_values(self):
        """Test ExploitRank enum has correct values"""
        self.assertEqual(ExploitRank.MANUAL.value, "Manual")
        self.assertEqual(ExploitRank.LOW.value, "Low")
        self.assertEqual(ExploitRank.AVERAGE.value, "Average")
        self.assertEqual(ExploitRank.NORMAL.value, "Normal")
        self.assertEqual(ExploitRank.GOOD.value, "Good")
        self.assertEqual(ExploitRank.GREAT.value, "Great")
        self.assertEqual(ExploitRank.EXCELLENT.value, "Excellent")

    def test_target_arch_values(self):
        """Test TargetArch enum has correct architectures"""
        self.assertEqual(TargetArch.X86.value, "x86")
        self.assertEqual(TargetArch.X64.value, "x64")
        self.assertEqual(TargetArch.ARM.value, "arm")
        self.assertEqual(TargetArch.AARCH64.value, "aarch64")
        self.assertEqual(TargetArch.MIPS.value, "mips")
        self.assertEqual(TargetArch.PPC.value, "ppc")
        self.assertEqual(TargetArch.SPARC.value, "sparc")
        self.assertEqual(TargetArch.CMD.value, "cmd")

    def test_platform_values(self):
        """Test Platform enum has correct platforms"""
        self.assertEqual(Platform.WINDOWS.value, "windows")
        self.assertEqual(Platform.LINUX.value, "linux")
        self.assertEqual(Platform.UNIX.value, "unix")
        self.assertEqual(Platform.OSX.value, "osx")
        self.assertEqual(Platform.BSD.value, "bsd")
        self.assertEqual(Platform.ANDROID.value, "android")
        self.assertEqual(Platform.IOS.value, "ios")

    def test_payload_type_values(self):
        """Test PayloadType enum has correct types"""
        self.assertEqual(PayloadType.BIND_TCP.value, "bind_tcp")
        self.assertEqual(PayloadType.REVERSE_TCP.value, "reverse_tcp")
        self.assertEqual(PayloadType.REVERSE_HTTP.value, "reverse_http")
        self.assertEqual(PayloadType.REVERSE_HTTPS.value, "reverse_https")
        self.assertEqual(PayloadType.SSH_INTERACT.value, "ssh_interact")
        self.assertEqual(PayloadType.UNIX_CMD.value, "unix_cmd")
        self.assertEqual(PayloadType.WINDOWS_CMD.value, "windows_cmd")


class TestExploitTarget(unittest.TestCase):
    """Test ExploitTarget dataclass"""

    def test_exploit_target_creation(self):
        """Test basic ExploitTarget creation"""
        target = ExploitTarget(
            name="Linux x64",
            platform=[Platform.LINUX],
            arch=[TargetArch.X64],
            payload_type=PayloadType.REVERSE_TCP,
        )

        self.assertEqual(target.name, "Linux x64")
        self.assertEqual(target.platform, [Platform.LINUX])
        self.assertEqual(target.arch, [TargetArch.X64])
        self.assertEqual(target.payload_type, PayloadType.REVERSE_TCP)
        self.assertEqual(target.default_options, {})

    def test_exploit_target_with_options(self):
        """Test ExploitTarget with default options"""
        target = ExploitTarget(
            name="Windows x86",
            platform=[Platform.WINDOWS],
            arch=[TargetArch.X86],
            payload_type=PayloadType.BIND_TCP,
            default_options={"PrependMigrate": True, "PrependMigrateProc": "explorer.exe"},
        )

        self.assertEqual(target.default_options["PrependMigrate"], True)
        self.assertEqual(target.default_options["PrependMigrateProc"], "explorer.exe")


class TestExploitOption(unittest.TestCase):
    """Test ExploitOption dataclass"""

    def test_exploit_option_creation(self):
        """Test basic ExploitOption creation"""
        option = ExploitOption(name="RHOSTS", required=True, description="Target host(s)")

        self.assertEqual(option.name, "RHOSTS")
        self.assertTrue(option.required)
        self.assertEqual(option.description, "Target host(s)")
        self.assertIsNone(option.default_value)
        self.assertEqual(option.data_type, str)

    def test_exploit_option_with_defaults(self):
        """Test ExploitOption with default value and type"""
        option = ExploitOption(
            name="RPORT", required=True, description="Target port", default_value=443, data_type=int
        )

        self.assertEqual(option.name, "RPORT")
        self.assertEqual(option.default_value, 443)
        self.assertEqual(option.data_type, int)


class TestExploitInfo(unittest.TestCase):
    """Test ExploitInfo dataclass"""

    def test_exploit_info_minimal(self):
        """Test ExploitInfo with minimal required fields"""
        info = ExploitInfo(name="Test Exploit", description="Test Description", author=["Test Author"])

        self.assertEqual(info.name, "Test Exploit")
        self.assertEqual(info.description, "Test Description")
        self.assertEqual(info.author, ["Test Author"])
        self.assertEqual(info.references, [])
        self.assertIsNone(info.disclosure_date)
        self.assertEqual(info.rank, ExploitRank.NORMAL)
        self.assertEqual(info.targets, [])
        self.assertEqual(info.default_target, 0)

    def test_exploit_info_full(self):
        """Test ExploitInfo with all fields"""
        target = ExploitTarget(
            name="Linux", platform=[Platform.LINUX], arch=[TargetArch.X64], payload_type=PayloadType.REVERSE_TCP
        )

        info = ExploitInfo(
            name="Test Exploit",
            description="Test Description",
            author=["Test Author"],
            references=["CVE-2024-12345", "URL: http://example.com"],
            disclosure_date="2024-01-01",
            rank=ExploitRank.EXCELLENT,
            targets=[target],
            default_target=0,
            platform=[Platform.LINUX],
            arch=[TargetArch.X64],
            privileged=True,
            license="BSD",
            notes={"Stability": ["CRASH_SAFE"], "SideEffects": ["IOC_IN_LOGS"]},
        )

        self.assertEqual(info.name, "Test Exploit")
        self.assertEqual(info.rank, ExploitRank.EXCELLENT)
        self.assertEqual(len(info.references), 2)
        self.assertTrue(info.privileged)
        self.assertEqual(info.license, "BSD")
        self.assertIn("Stability", info.notes)


class TestExploitResult(unittest.TestCase):
    """Test ExploitResult class"""

    def test_exploit_result_success(self):
        """Test successful ExploitResult"""
        result = ExploitResult(True, "Exploit successful")

        self.assertTrue(result.success)
        self.assertEqual(result.message, "Exploit successful")
        self.assertEqual(result.data, {})
        self.assertIsInstance(result.timestamp, datetime)

    def test_exploit_result_failure(self):
        """Test failed ExploitResult"""
        result = ExploitResult(False, "Target not vulnerable")

        self.assertFalse(result.success)
        self.assertEqual(result.message, "Target not vulnerable")

    def test_exploit_result_with_data(self):
        """Test ExploitResult with additional data"""
        data = {"session_id": 123, "shell_type": "cmd"}
        result = ExploitResult(True, "Session opened", data)

        self.assertTrue(result.success)
        self.assertEqual(result.data["session_id"], 123)
        self.assertEqual(result.data["shell_type"], "cmd")


class TestExploit(unittest.TestCase):
    """Test Exploit base class"""

    def setUp(self):
        """Set up test fixtures"""
        # Create a concrete implementation for testing
        class TestExploit(Exploit):
            def check(self):
                return ExploitResult(True, "Target is vulnerable")

            def exploit(self):
                return ExploitResult(True, "Exploit successful")

        self.exploit_class = TestExploit

    def test_exploit_initialization(self):
        """Test exploit initialization"""
        info = ExploitInfo(name="Test", description="Test Exploit", author=["Tester"])
        exploit = self.exploit_class(info)

        self.assertEqual(exploit.info, info)
        self.assertEqual(len(exploit.options), 0)
        self.assertEqual(len(exploit.datastore), 0)
        self.assertIsNone(exploit.current_target)

    def test_exploit_with_targets(self):
        """Test exploit initialization with targets"""
        target = ExploitTarget(
            name="Linux", platform=[Platform.LINUX], arch=[TargetArch.X64], payload_type=PayloadType.REVERSE_TCP
        )
        info = ExploitInfo(name="Test", description="Test", author=["Tester"], targets=[target], default_target=0)
        exploit = self.exploit_class(info)

        self.assertIsNotNone(exploit.current_target)
        self.assertEqual(exploit.current_target.name, "Linux")

    def test_register_option(self):
        """Test registering single option"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        option = ExploitOption("RHOSTS", True, "Target hosts", "127.0.0.1")
        exploit.register_option(option)

        self.assertIn("RHOSTS", exploit.options)
        self.assertEqual(exploit.datastore["RHOSTS"], "127.0.0.1")

    def test_register_options(self):
        """Test registering multiple options"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        options = [
            ExploitOption("RHOSTS", True, "Target hosts", "127.0.0.1"),
            ExploitOption("RPORT", True, "Target port", 80, int),
        ]
        exploit.register_options(options)

        self.assertEqual(len(exploit.options), 2)
        self.assertIn("RHOSTS", exploit.options)
        self.assertIn("RPORT", exploit.options)

    def test_set_option(self):
        """Test setting option value"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        option = ExploitOption("RHOSTS", True, "Target hosts")
        exploit.register_option(option)
        exploit.set_option("RHOSTS", "192.168.1.100")

        self.assertEqual(exploit.datastore["RHOSTS"], "192.168.1.100")

    def test_set_invalid_option(self):
        """Test setting invalid option raises error"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        with self.assertRaises(ValueError) as context:
            exploit.set_option("INVALID", "value")

        self.assertIn("Unknown option", str(context.exception))

    def test_get_option(self):
        """Test getting option value"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        option = ExploitOption("RHOSTS", True, "Target hosts", "127.0.0.1")
        exploit.register_option(option)

        value = exploit.get_option("RHOSTS")
        self.assertEqual(value, "127.0.0.1")

    def test_get_option_with_default(self):
        """Test getting non-existent option with default"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        value = exploit.get_option("NONEXISTENT", "default_value")
        self.assertEqual(value, "default_value")

    def test_set_target(self):
        """Test setting target by index"""
        target1 = ExploitTarget(
            name="Linux", platform=[Platform.LINUX], arch=[TargetArch.X64], payload_type=PayloadType.REVERSE_TCP
        )
        target2 = ExploitTarget(
            name="Windows", platform=[Platform.WINDOWS], arch=[TargetArch.X86], payload_type=PayloadType.BIND_TCP
        )

        info = ExploitInfo(name="Test", description="Test", author=["Tester"], targets=[target1, target2])
        exploit = self.exploit_class(info)

        exploit.set_target(1)
        self.assertEqual(exploit.current_target.name, "Windows")

    def test_set_invalid_target(self):
        """Test setting invalid target index"""
        target = ExploitTarget(
            name="Linux", platform=[Platform.LINUX], arch=[TargetArch.X64], payload_type=PayloadType.REVERSE_TCP
        )
        info = ExploitInfo(name="Test", description="Test", author=["Tester"], targets=[target])
        exploit = self.exploit_class(info)

        with self.assertRaises(ValueError):
            exploit.set_target(5)

    @patch("builtins.print")
    def test_print_status(self, mock_print):
        """Test status message printing"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        exploit.print_status("Test status")
        mock_print.assert_called_with("[*] Test status")

    @patch("builtins.print")
    def test_print_good(self, mock_print):
        """Test success message printing"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        exploit.print_good("Test success")
        mock_print.assert_called_with("[+] Test success")

    @patch("builtins.print")
    def test_print_error(self, mock_print):
        """Test error message printing"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        exploit.print_error("Test error")
        mock_print.assert_called_with("[-] Test error")

    @patch("builtins.print")
    def test_print_warning(self, mock_print):
        """Test warning message printing"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        exploit.print_warning("Test warning")
        mock_print.assert_called_with("[!] Test warning")

    @patch("builtins.print")
    def test_vprint_status_verbose_on(self, mock_print):
        """Test verbose status printing when VERBOSE is True"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        option = ExploitOption("VERBOSE", False, "Verbose output", True, bool)
        exploit.register_option(option)

        exploit.vprint_status("Verbose message")
        mock_print.assert_called_with("[*] Verbose message")

    @patch("builtins.print")
    def test_vprint_status_verbose_off(self, mock_print):
        """Test verbose status not printing when VERBOSE is False"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        exploit.vprint_status("Verbose message")
        mock_print.assert_not_called()

    def test_run_successful_exploit(self):
        """Test successful exploit run"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        # Disable auto-check for simpler test
        option = ExploitOption("AUTO_CHECK", False, "Auto check", False, bool)
        exploit.register_option(option)

        result = exploit.run()

        self.assertTrue(result.success)
        self.assertEqual(result.message, "Exploit successful")

    def test_run_with_missing_required_option(self):
        """Test run fails with missing required option"""
        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = self.exploit_class(info)

        # Add required option but don't set value
        option = ExploitOption("RHOSTS", True, "Target hosts")
        exploit.register_option(option)

        result = exploit.run()

        self.assertFalse(result.success)
        self.assertIn("Required option", result.message)

    def test_run_with_auto_check(self):
        """Test run with automatic target checking"""
        # Create exploit that fails check
        class CheckFailExploit(Exploit):
            def check(self):
                return ExploitResult(False, "Not vulnerable")

            def exploit(self):
                return ExploitResult(True, "Exploit successful")

        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = CheckFailExploit(info)

        option = ExploitOption("AUTO_CHECK", False, "Auto check", True, bool)
        exploit.register_option(option)

        result = exploit.run()

        self.assertFalse(result.success)
        self.assertEqual(result.message, "Not vulnerable")

    def test_run_with_exception(self):
        """Test run handles exceptions gracefully"""

        class FailingExploit(Exploit):
            def check(self):
                return ExploitResult(True, "Vulnerable")

            def exploit(self):
                raise RuntimeError("Simulated exploit failure")

        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = FailingExploit(info)

        result = exploit.run()

        self.assertFalse(result.success)
        self.assertIn("exception", result.message.lower())


class TestRemoteExploit(unittest.TestCase):
    """Test RemoteExploit class"""

    def test_remote_exploit_initialization(self):
        """Test RemoteExploit registers standard remote options"""

        class TestRemoteExploit(RemoteExploit):
            def check(self):
                return ExploitResult(True, "Vulnerable")

            def exploit(self):
                return ExploitResult(True, "Success")

        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = TestRemoteExploit(info)

        # Check that standard remote options are registered
        self.assertIn("RHOSTS", exploit.options)
        self.assertIn("RPORT", exploit.options)
        self.assertIn("SSL", exploit.options)
        self.assertIn("TARGETURI", exploit.options)
        self.assertIn("ConnectTimeout", exploit.options)
        self.assertIn("VERBOSE", exploit.options)
        self.assertIn("AUTO_CHECK", exploit.options)

    def test_remote_exploit_default_values(self):
        """Test RemoteExploit default option values"""

        class TestRemoteExploit(RemoteExploit):
            def check(self):
                return ExploitResult(True, "Vulnerable")

            def exploit(self):
                return ExploitResult(True, "Success")

        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = TestRemoteExploit(info)

        self.assertEqual(exploit.get_option("RPORT"), 80)
        self.assertEqual(exploit.get_option("SSL"), False)
        self.assertEqual(exploit.get_option("TARGETURI"), "/")
        self.assertEqual(exploit.get_option("ConnectTimeout"), 10)


class TestLocalExploit(unittest.TestCase):
    """Test LocalExploit class"""

    def test_local_exploit_initialization(self):
        """Test LocalExploit registers standard local options"""

        class TestLocalExploit(LocalExploit):
            def check(self):
                return ExploitResult(True, "Vulnerable")

            def exploit(self):
                return ExploitResult(True, "Success")

        info = ExploitInfo(name="Test", description="Test", author=["Tester"])
        exploit = TestLocalExploit(info)

        # Check that standard local options are registered
        self.assertIn("SESSION", exploit.options)
        self.assertIn("VERBOSE", exploit.options)
        self.assertIn("AUTO_CHECK", exploit.options)


class TestExploitIntegration(unittest.TestCase):
    """Integration tests for exploit workflow"""

    def test_complete_exploit_workflow(self):
        """Test complete exploit workflow from initialization to execution"""

        class RealWorldExploit(RemoteExploit):
            def check(self):
                rhost = self.get_option("RHOSTS")
                rport = self.get_option("RPORT")
                self.vprint_status(f"Checking {rhost}:{rport}")
                return ExploitResult(True, "Target appears vulnerable")

            def exploit(self):
                rhost = self.get_option("RHOSTS")
                self.vprint_status(f"Exploiting {rhost}")
                return ExploitResult(True, "Shell obtained", {"session_id": 1})

        info = ExploitInfo(
            name="Test RCE Exploit",
            description="Remote code execution test",
            author=["Test Author"],
            rank=ExploitRank.EXCELLENT,
        )

        exploit = RealWorldExploit(info)

        # Configure exploit
        exploit.set_option("RHOSTS", "192.168.1.100")
        exploit.set_option("RPORT", 8080)
        exploit.set_option("VERBOSE", True)

        # Run exploit
        result = exploit.run()

        # Verify results
        self.assertTrue(result.success)
        self.assertIn("session_id", result.data)


if __name__ == "__main__":
    unittest.main()
