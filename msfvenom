#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
MsfVenom - Python implementation of Metasploit's standalone payload generator.
A replacement for msfpayload and msfencode.
"""

import argparse
import sys
import os
import signal
import time
import struct
import base64
import binascii
from pathlib import Path

class MsfVenomError(Exception):
    """Base exception for MsfVenom errors"""
    pass

class HelpError(MsfVenomError):
    """Exception for help display"""
    pass

class UsageError(MsfVenomError):
    """Exception for usage errors"""
    pass

class MsfVenom:
    """Python implementation of MsfVenom payload generator"""
    
    def __init__(self):
        self.framework_loaded = False
        self.framework = None
        
    def require_deps(self):
        """Load framework dependencies (placeholder)"""
        # Framework loading will be implemented when full Python MSF framework is available
        self.framework_loaded = True
        
    def init_framework(self, create_opts=None):
        """Initialize the framework (placeholder)"""
        if create_opts is None:
            create_opts = {}
            
        if not self.framework_loaded:
            self.require_deps()
            
        # Framework initialization pending full Python MSF framework
        # create_opts.setdefault('module_types', ['payload', 'encoder', 'nop'])
        self.framework = "placeholder_framework"
        
    def get_framework(self):
        """Get cached framework object"""
        if not self.framework:
            self.init_framework()
        return self.framework
        
    def parse_args(self, args):
        """Parse command line arguments"""
        parser = argparse.ArgumentParser(
            prog='msfvenom.py',
            description='MsfVenom - a Metasploit standalone payload generator (Python version).\n'
                       'Also a replacement for msfpayload and msfencode.',
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog='Example: %(prog)s -p windows/meterpreter/reverse_tcp LHOST=<IP> -f exe -o payload.exe'
        )
        
        parser.add_argument('-l', '--list', nargs='*', 
                          help='List all modules for [type]. Types are: payloads, encoders, nops, platforms, archs, encrypt, formats, all')
        
        parser.add_argument('-p', '--payload', 
                          help="Payload to use (--list payloads to list, --list-options for arguments). Specify '-' or STDIN for custom")
        
        parser.add_argument('--list-options', action='store_true',
                          help="List --payload <value>'s standard, advanced and evasion options")
        
        parser.add_argument('-f', '--format', 
                          help='Output format (use --list formats to list)')
        
        parser.add_argument('-e', '--encoder',
                          help='The encoder to use (use --list encoders to list)')
        
        parser.add_argument('--service-name',
                          help='The service name to use when generating a service binary')
        
        parser.add_argument('--sec-name',
                          help='The new section name to use when generating large Windows binaries. Default: random 4-character alpha string')
        
        parser.add_argument('--smallest', action='store_true',
                          help='Generate the smallest possible payload using all available encoders')
        
        parser.add_argument('--encrypt',
                          help='The type of encryption or encoding to apply to the shellcode (use --list encrypt to list)')
        
        parser.add_argument('--encrypt-key',
                          help='A key to be used for --encrypt')
        
        parser.add_argument('--encrypt-iv',
                          help='An initialization vector for --encrypt')
        
        parser.add_argument('-a', '--arch',
                          help='The architecture to use for --payload and --encoders (use --list archs to list)')
        
        parser.add_argument('--platform',
                          help='The platform for --payload (use --list platforms to list)')
        
        parser.add_argument('-o', '--out',
                          help='Save the payload to a file')
        
        parser.add_argument('-b', '--bad-chars',
                          help='Characters to avoid example: \'\\x00\\xff\'')
        
        parser.add_argument('-n', '--nopsled', type=int,
                          help='Prepend a nopsled of [length] size on to the payload')
        
        parser.add_argument('--pad-nops', action='store_true',
                          help='Use nopsled size specified by -n <length> as the total payload size, auto-prepending a nopsled of quantity (nops minus payload length)')
        
        parser.add_argument('-s', '--space', type=int,
                          help='The maximum size of the resulting payload')
        
        parser.add_argument('--encoder-space', type=int,
                          help='The maximum size of the encoded payload (defaults to the -s value)')
        
        parser.add_argument('-i', '--iterations', type=int,
                          help='The number of times to encode the payload')
        
        parser.add_argument('-c', '--add-code',
                          help='Specify an additional win32 shellcode file to include')
        
        parser.add_argument('-x', '--template',
                          help='Specify a custom executable file to use as a template')
        
        parser.add_argument('-k', '--keep', action='store_true',
                          help='Preserve the --template behaviour and inject the payload as a new thread')
        
        parser.add_argument('-v', '--var-name',
                          help='Specify a custom variable name to use for certain output formats')
        
        parser.add_argument('-t', '--timeout', type=int, default=30,
                          help='The number of seconds to wait when reading the payload from STDIN (default 30, 0 to disable)')
        
        parser.add_argument('datastore', nargs='*',
                          help='Datastore options in KEY=VALUE format')
        
        try:
            opts = parser.parse_args(args)
        except SystemExit:
            raise UsageError("Invalid arguments")
            
        # Process datastore options
        datastore = {}
        if opts.datastore:
            for item in opts.datastore:
                if '=' in item:
                    key, value = item.split('=', 1)
                    datastore[key.upper()] = value
                    
        # Handle STDIN payload
        if opts.payload == '-':
            opts.payload = 'stdin'
            
        if not opts.payload and not opts.list:
            opts.payload = 'stdin'
            
        if opts.payload == 'stdin' and not opts.list:
            print("Attempting to read payload from STDIN...", file=sys.stderr)
            try:
                if opts.timeout > 0:
                    signal.alarm(opts.timeout)
                opts.stdin = sys.stdin.buffer.read()
                signal.alarm(0)
            except:
                opts.stdin = b''
                
        # Set default LHOST for reverse payloads
        if (opts.payload and 'reverse' in opts.payload.lower() and 
            'LHOST' not in datastore):
            datastore['LHOST'] = '127.0.0.1'  # Default fallback
            
        opts.datastore = datastore
        return opts
        
    def dump_platforms(self):
        """List supported platforms"""
        platforms = [
            'aix', 'android', 'apple_ios', 'bsd', 'bsdi', 'cisco', 'firefox',
            'freebsd', 'hardware', 'hpux', 'irix', 'java', 'javascript', 'linux',
            'mainframe', 'multi', 'netbsd', 'netware', 'nodejs', 'openbsd',
            'osx', 'php', 'python', 'r', 'ruby', 'solaris', 'unix', 'windows'
        ]
        
        output = "\n    Framework Platforms [--platform <value>]\n"
        output += "    " + "=" * 50 + "\n\n"
        for platform in sorted(platforms):
            output += f"    {platform}\n"
        output += "\n"
        return output
        
    def dump_archs(self):
        """List supported architectures"""
        archs = [
            'aarch64', 'armbe', 'armle', 'cbea', 'cbea64', 'cmd', 'dalvik',
            'firefox', 'java', 'mips', 'mips64', 'mips64le', 'mipsbe', 'mipsle',
            'nodejs', 'php', 'ppc', 'ppc64', 'ppc64le', 'ppce500v2', 'python',
            'r', 'ruby', 'sparc', 'sparc64', 'tty', 'x64', 'x86', 'x86_64', 'zarch'
        ]
        
        output = "\n    Framework Architectures [--arch <value>]\n"
        output += "    " + "=" * 50 + "\n\n"
        for arch in sorted(archs):
            output += f"    {arch}\n"
        output += "\n"
        return output
        
    def dump_encrypt(self):
        """List encryption formats"""
        encrypts = [
            'aes256', 'base64', 'blowfish', 'des', 'rc4', 'xor'
        ]
        
        output = "\n    Framework Encryption Formats [--encrypt <value>]\n"
        output += "    " + "=" * 50 + "\n\n"
        for encrypt in sorted(encrypts):
            output += f"    {encrypt}\n"
        output += "\n"
        return output
        
    def dump_formats(self):
        """List output formats"""
        executable_formats = [
            'asp', 'aspx', 'aspx-exe', 'axis2', 'dll', 'elf', 'elf-so', 'exe',
            'exe-only', 'exe-service', 'exe-small', 'hta-psh', 'jar', 'jsp',
            'loop-vbs', 'macho', 'msi', 'msi-nouac', 'osx-app', 'psh', 'psh-cmd',
            'psh-net', 'psh-reflection', 'vba', 'vba-exe', 'vba-psh', 'vbs', 'war'
        ]
        
        transform_formats = [
            'bash', 'c', 'csharp', 'dw', 'dword', 'hex', 'java', 'js_be', 'js_le',
            'num', 'perl', 'pl', 'powershell', 'ps1', 'py', 'python', 'raw', 'rb',
            'ruby', 'sh', 'vbapplication', 'vbscript'
        ]
        
        output = "\n    Framework Executable Formats [--format <value>]\n"
        output += "    " + "=" * 50 + "\n\n"
        
        for fmt in sorted(executable_formats):
            output += f"    {fmt}\n"
        
        output += "\n    Framework Transform Formats [--format <value>]\n"
        output += "    " + "=" * 50 + "\n\n"
        
        for fmt in sorted(transform_formats):
            output += f"    {fmt}\n"
        output += "\n"
        return output
        
    def dump_payloads(self):
        """List available payloads"""
        # Sample payloads for demonstration
        payloads = [
            'android/meterpreter/reverse_http',
            'android/meterpreter/reverse_https',
            'android/meterpreter/reverse_tcp',
            'cmd/unix/bind_netcat',
            'cmd/unix/bind_perl',
            'cmd/unix/reverse_bash',
            'cmd/unix/reverse_netcat',
            'cmd/unix/reverse_perl',
            'cmd/windows/adduser',
            'cmd/windows/bind_perl',
            'cmd/windows/download_exec',
            'cmd/windows/powershell_bind_tcp',
            'cmd/windows/powershell_reverse_tcp',
            'generic/custom',
            'generic/shell_bind_tcp',
            'generic/shell_reverse_tcp',
            'linux/x64/exec',
            'linux/x64/meterpreter/bind_tcp',
            'linux/x64/meterpreter/reverse_tcp',
            'linux/x64/shell/bind_tcp',
            'linux/x64/shell/reverse_tcp',
            'linux/x86/exec',
            'linux/x86/meterpreter/bind_tcp',
            'linux/x86/meterpreter/reverse_tcp',
            'linux/x86/shell/bind_tcp',
            'linux/x86/shell/reverse_tcp',
            'osx/x64/exec',
            'osx/x64/meterpreter/bind_tcp',
            'osx/x64/meterpreter/reverse_tcp',
            'osx/x64/shell_bind_tcp',
            'osx/x64/shell_reverse_tcp',
            'windows/x64/exec',
            'windows/x64/meterpreter/bind_tcp',
            'windows/x64/meterpreter/reverse_http',
            'windows/x64/meterpreter/reverse_https',
            'windows/x64/meterpreter/reverse_tcp',
            'windows/x64/shell/bind_tcp',
            'windows/x64/shell/reverse_tcp',
            'windows/meterpreter/bind_tcp',
            'windows/meterpreter/reverse_http',
            'windows/meterpreter/reverse_https',
            'windows/meterpreter/reverse_tcp',
            'windows/shell/bind_tcp',
            'windows/shell/reverse_tcp'
        ]
        
        output = "\n    Framework Payloads (--payload <value>)\n"
        output += "    " + "=" * 50 + "\n\n"
        for payload in sorted(payloads):
            output += f"    {payload}\n"
        output += "\n"
        return output
        
    def dump_encoders(self):
        """List available encoders"""
        encoders = [
            'cmd/echo',
            'cmd/ifs',
            'cmd/perl',
            'cmd/powershell_base64',
            'cmd/printf_php_mq',
            'generic/eicar',
            'generic/none',
            'mipsbe/byte_xori',
            'mipsbe/longxor',
            'mipsle/byte_xori',
            'mipsle/longxor',
            'php/base64',
            'ppc/longxor',
            'ppc/longxor_tag',
            'sparc/longxor_tag',
            'x64/xor',
            'x64/xor_dynamic',
            'x86/add_sub',
            'x86/alpha_mixed',
            'x86/alpha_upper',
            'x86/avoid_underscore_tolower',
            'x86/avoid_utf8_tolower',
            'x86/bloxor',
            'x86/bmp_polyglot',
            'x86/call4_dword_xor',
            'x86/context_cpuid',
            'x86/context_stat',
            'x86/context_time',
            'x86/countdown',
            'x86/fnstenv_mov',
            'x86/jmp_call_additive',
            'x86/nonalpha',
            'x86/nonupper',
            'x86/opt_sub',
            'x86/service',
            'x86/shikata_ga_nai',
            'x86/single_static_bit',
            'x86/unicode_mixed',
            'x86/unicode_upper'
        ]
        
        output = "\n    Framework Encoders (--encoder <value>)\n"
        output += "    " + "=" * 50 + "\n\n"
        for encoder in sorted(encoders):
            output += f"    {encoder}\n"
        output += "\n"
        return output
        
    def dump_nops(self):
        """List available NOPs"""
        nops = [
            'aarch64/simple',
            'armle/simple',
            'mipsbe/better',
            'php/generic',
            'ppc/simple',
            'sparc/random',
            'tty/generic',
            'x64/simple',
            'x86/opty2',
            'x86/single_byte'
        ]
        
        output = "\n    Framework NOPs (--nopsled <length>)\n"
        output += "    " + "=" * 50 + "\n\n"
        for nop in sorted(nops):
            output += f"    {nop}\n"
        output += "\n"
        return output
        
    def dump_all(self):
        """List all available modules"""
        output = self.dump_payloads()
        output += self.dump_encoders()
        output += self.dump_nops()
        output += self.dump_platforms()
        output += self.dump_archs()
        output += self.dump_formats()
        output += self.dump_encrypt()
        return output
        
    def list_modules(self, module_types):
        """List modules based on type"""
        if not module_types:
            return self.dump_all()
            
        output = ""
        for module_type in module_types:
            if module_type.lower() in ['payloads', 'payload']:
                output += self.dump_payloads()
            elif module_type.lower() in ['encoders', 'encoder']:
                output += self.dump_encoders()
            elif module_type.lower() in ['nops', 'nop']:
                output += self.dump_nops()
            elif module_type.lower() in ['platforms', 'platform']:
                output += self.dump_platforms()
            elif module_type.lower() in ['archs', 'arch']:
                output += self.dump_archs()
            elif module_type.lower() in ['formats', 'format']:
                output += self.dump_formats()
            elif module_type.lower() in ['encrypt', 'encryption']:
                output += self.dump_encrypt()
            elif module_type.lower() == 'all':
                output += self.dump_all()
            else:
                output += f"\nUnknown module type: {module_type}\n"
                output += "Valid types: payloads, encoders, nops, platforms, archs, formats, encrypt, all\n"
        
        return output
        
    def generate_payload(self, opts):
        """Generate payload (placeholder implementation)"""
        if not opts.payload or opts.payload == 'stdin':
            return b"# Placeholder payload - framework not fully implemented\n"
            
        # Basic payload generation simulation
        payload_data = f"# Generated payload: {opts.payload}\n"
        
        if opts.datastore:
            payload_data += "# Configuration:\n"
            for key, value in opts.datastore.items():
                payload_data += f"# {key} = {value}\n"
                
        if opts.format:
            payload_data += f"# Format: {opts.format}\n"
            
        if opts.encoder:
            payload_data += f"# Encoder: {opts.encoder}\n"
            
        payload_data += "# This is a placeholder - full implementation pending\n"
        payload_data += "print('Hello from MSF PyNative payload!')\n"
        
        return payload_data.encode('utf-8')
        
    def run(self, args=None):
        """Main execution method"""
        if args is None:
            args = sys.argv[1:]
            
        try:
            opts = self.parse_args(args)
            
            # Handle list operations
            if opts.list is not None:
                output = self.list_modules(opts.list)
                print(output)
                return 0
                
            # Handle list-options
            if opts.list_options:
                if not opts.payload:
                    print("Error: --list-options requires --payload to be specified")
                    return 1
                print(f"\nOptions for payload {opts.payload}:")
                print("=" * 50)
                print("Standard options:")
                print("  LHOST  <string>  The listen address")
                print("  LPORT  <int>     The listen port")
                print("\nAdvanced options:")
                print("  PrependMigrate  <bool>  Spawns and runs shellcode in new process")
                print("  VERBOSE         <bool>  Enable detailed status messages")
                print("\nEvasion options:")
                print("  RC4PASSWORD     <string>  Password to derive RC4 key from")
                print("  ITERATIONS      <int>     Number of iterations for encoding")
                print()
                return 0
                
            # Generate payload
            payload = self.generate_payload(opts)
            
            # Output payload
            if opts.out:
                with open(opts.out, 'wb') as f:
                    f.write(payload)
                print(f"Payload written to {opts.out}")
            else:
                if isinstance(payload, bytes):
                    sys.stdout.buffer.write(payload)
                else:
                    print(payload)
                    
            return 0
            
        except (HelpError, UsageError) as e:
            print(f"Error: {e}", file=sys.stderr)
            return 1
        except KeyboardInterrupt:
            print("\nAborted by user", file=sys.stderr)
            return 1
        except Exception as e:
            print(f"Unexpected error: {e}", file=sys.stderr)
            return 1


def main():
    """Main entry point"""
    venom = MsfVenom()
    return venom.run()


if __name__ == "__main__":
    sys.exit(main())


