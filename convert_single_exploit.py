#!/usr/bin/env python3
"""
Enhanced Ruby to Python converter for Metasploit exploit modules
"""

import os
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional

class MetasploitRubyToPythonConverter:
    """Enhanced converter specifically for Metasploit Ruby exploit modules"""
    
    def __init__(self):
        self.ruby_to_python_mappings = {
            # Metasploit specific mappings
            'Msf::Exploit::Remote': 'RemoteExploit',
            'Msf::Exploit::Remote::HttpClient': 'HttpExploitMixin',
            'Msf::Exploit::Remote::AutoCheck': 'AutoCheckMixin',
            'MetasploitModule': 'MetasploitModule',
            'ExcellentRanking': 'ExploitRank.EXCELLENT',
            'GreatRanking': 'ExploitRank.GREAT',
            'GoodRanking': 'ExploitRank.GOOD',
            'NormalRanking': 'ExploitRank.NORMAL',
            'AverageRanking': 'ExploitRank.AVERAGE',
            'LowRanking': 'ExploitRank.LOW',
            'ManualRanking': 'ExploitRank.MANUAL',
            
            # Common Ruby patterns
            'nil': 'None',
            'true': 'True',
            'false': 'False',
            'puts': 'print',
            'print_status': 'self.print_status',
            'print_good': 'self.print_good',
            'print_error': 'self.print_error',
            'vprint_status': 'self.vprint_status',
            'vprint_good': 'self.vprint_good',
            'vprint_error': 'self.vprint_error',
        }
    
    def convert_ruby_file_to_python(self, ruby_file_path: str) -> str:
        """Convert a Ruby exploit file to Python"""
        
        with open(ruby_file_path, 'r', encoding='utf-8', errors='ignore') as f:
            ruby_content = f.read()
        
        python_lines = []
        
        # Add Python header
        python_lines.extend([
            "#!/usr/bin/env python3",
            "# -*- coding: utf-8 -*-",
            '"""',
            f"Converted from Ruby: {Path(ruby_file_path).name}",
            "",
            "This module was automatically converted from Ruby to Python",
            "as part of the post-2020 Python migration initiative.",
            '"""',
            "",
            "import sys",
            "import os",
            "import re",
            "import json",
            "import time",
            "import logging",
            "from typing import Dict, List, Optional, Any, Union",
            "",
            "# Framework imports",
            "sys.path.insert(0, os.path.join(os.path.dirname(__file__), '../../../python_framework'))",
            "from core.exploit import RemoteExploit, ExploitInfo, ExploitResult, ExploitRank",
            "from helpers.http_client import HttpExploitMixin",
            "from helpers.mixins import AutoCheckMixin",
            "",
        ])
        
        # Process Ruby content
        ruby_lines = ruby_content.split('\n')
        in_class = False
        in_method = False
        indent_level = 0
        
        for line_num, line in enumerate(ruby_lines):
            stripped = line.strip()
            
            # Skip comments and empty lines initially
            if not stripped or stripped.startswith('#'):
                if stripped.startswith('##') or 'This module requires Metasploit' in stripped:
                    continue  # Skip Metasploit headers
                elif stripped.startswith('#'):
                    python_lines.append(line.replace('#', '#', 1))
                else:
                    python_lines.append("")
                continue
            
            # Convert class definition
            if stripped.startswith('class MetasploitModule'):
                python_lines.append("class MetasploitModule(RemoteExploit, HttpExploitMixin, AutoCheckMixin):")
                python_lines.append('    """Converted Metasploit exploit module"""')
                python_lines.append("")
                in_class = True
                indent_level = 1
                continue
            
            # Convert Rank assignment
            if 'Rank =' in stripped:
                rank_value = stripped.split('=')[1].strip()
                mapped_rank = self.ruby_to_python_mappings.get(rank_value, rank_value)
                python_lines.append(f"    rank = {mapped_rank}")
                continue
            
            # Convert include statements
            if stripped.startswith('include '):
                include_module = stripped.replace('include ', '').strip()
                python_lines.append(f"    # TODO: Handle include {include_module}")
                continue
            
            # Convert prepend statements  
            if stripped.startswith('prepend '):
                prepend_module = stripped.replace('prepend ', '').strip()
                python_lines.append(f"    # TODO: Handle prepend {prepend_module}")
                continue
            
            # Convert method definitions
            if stripped.startswith('def '):
                method_match = re.match(r'def\s+(\w+)(\([^)]*\))?', stripped)
                if method_match:
                    method_name = method_match.group(1)
                    args = method_match.group(2) or "()"
                    
                    # Add self parameter
                    if args == "()":
                        args = "(self)"
                    elif not args.startswith('(self'):
                        args = f"(self, {args[1:]}"
                    
                    python_lines.append("    " * indent_level + f"def {method_name}{args}:")
                    in_method = True
                    continue
            
            # Convert common patterns
            converted_line = self.convert_ruby_patterns(line)
            python_lines.append(converted_line)
        
        return '\n'.join(python_lines)
    
    def convert_ruby_patterns(self, line: str) -> str:
        """Convert common Ruby patterns to Python"""
        # Preserve indentation
        indent = len(line) - len(line.lstrip())
        stripped = line.strip()
        
        if not stripped:
            return line
        
        # Apply mappings
        for ruby_pattern, python_pattern in self.ruby_to_python_mappings.items():
            stripped = stripped.replace(ruby_pattern, python_pattern)
        
        # String interpolation: "#{var}" -> f"{var}"
        stripped = re.sub(r'"([^"]*?)#\{([^}]+)\}([^"]*?)"', r'f"\1{\2}\3"', stripped)
        
        # Hash rockets: => -> :
        stripped = re.sub(r'\s*=>\s*', ': ', stripped)
        
        # Symbols: :symbol -> "symbol"
        stripped = re.sub(r':(\w+)', r'"\1"', stripped)
        
        # Instance variables: @var -> self._var
        stripped = re.sub(r'@(\w+)', r'self._\1', stripped)
        
        # Ruby end -> pass
        if stripped == 'end':
            stripped = 'pass'
        
        return ' ' * indent + stripped


def main():
    """Convert a single Ruby exploit to Python"""
    if len(sys.argv) != 2:
        print("Usage: python3 convert_single_exploit.py <ruby_file_path>")
        sys.exit(1)
    
    ruby_file = sys.argv[1]
    if not os.path.exists(ruby_file):
        print(f"Error: File {ruby_file} not found")
        sys.exit(1)
    
    converter = MetasploitRubyToPythonConverter()
    python_content = converter.convert_ruby_file_to_python(ruby_file)
    
    # Write to Python file
    python_file = ruby_file.replace('.rb', '.py')
    with open(python_file, 'w', encoding='utf-8') as f:
        f.write(python_content)
    
    print(f"Converted {ruby_file} -> {python_file}")


if __name__ == '__main__':
    main()