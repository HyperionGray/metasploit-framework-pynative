#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Exploit module base class
"""

from typing import Dict, Any, Optional, Tuple
from .module import Module


class CheckCode:
    """
    Check code results for exploit modules
    
    These indicate the confidence level that a target is vulnerable.
    """
    
    def __init__(self, code: str, message: str = '', reason: str = '', details: Optional[Dict] = None):
        """
        Initialize CheckCode
        
        Args:
            code: Check code string (unknown, safe, detected, appears, vulnerable, unsupported)
            message: Optional message
            reason: Optional reason
            details: Optional details dictionary
        """
        self.code = code
        self.reason = reason or message
        self.details = details or {}
        
        # Generate standard message
        msg_map = {
            'unknown': 'Cannot reliably check exploitability.',
            'safe': 'The target is not exploitable.',
            'detected': 'The service is running, but could not be validated.',
            'appears': 'The target appears to be vulnerable.',
            'vulnerable': 'The target is vulnerable.',
            'unsupported': 'This module does not support check.'
        }
        base_msg = msg_map.get(code, '')
        self.message = f"{base_msg} {self.reason}".strip()
        
    def __eq__(self, other):
        """Check equality based on code"""
        if isinstance(other, CheckCode):
            return self.code == other.code
        return False
        
    def __str__(self):
        """String representation"""
        return self.message
        
    def __repr__(self):
        """Debug representation"""
        return f"CheckCode('{self.code}', '{self.message}')"
        
    @classmethod
    def Unknown(cls, reason: str = '', details: Optional[Dict] = None):
        """Cannot tell if the target is exploitable"""
        return cls('unknown', reason=reason, details=details)
        
    @classmethod
    def Safe(cls, reason: str = '', details: Optional[Dict] = None):
        """Target is not exploitable"""
        return cls('safe', reason=reason, details=details)
        
    @classmethod
    def Detected(cls, reason: str = '', details: Optional[Dict] = None):
        """Service detected but vulnerability status unclear"""
        return cls('detected', reason=reason, details=details)
        
    @classmethod
    def Appears(cls, reason: str = '', details: Optional[Dict] = None):
        """Target appears to be vulnerable (passive detection)"""
        return cls('appears', reason=reason, details=details)
        
    @classmethod
    def Vulnerable(cls, reason: str = '', details: Optional[Dict] = None):
        """Target is confirmed vulnerable (active verification)"""
        return cls('vulnerable', reason=reason, details=details)
        
    @classmethod
    def Unsupported(cls, reason: str = '', details: Optional[Dict] = None):
        """Module doesn't support check method"""
        return cls('unsupported', reason=reason, details=details)


# Create module-level singleton instances for common check codes
# These are provided for convenience and backward compatibility
_CHECK_UNKNOWN = CheckCode.Unknown()
_CHECK_SAFE = CheckCode.Safe()
_CHECK_DETECTED = CheckCode.Detected()
_CHECK_APPEARS = CheckCode.Appears()
_CHECK_VULNERABLE = CheckCode.Vulnerable()
_CHECK_UNSUPPORTED = CheckCode.Unsupported()

# Attach as class attributes (but don't override the factory methods)
CheckCode.UNKNOWN = _CHECK_UNKNOWN
CheckCode.SAFE = _CHECK_SAFE
CheckCode.DETECTED = _CHECK_DETECTED
CheckCode.APPEARS = _CHECK_APPEARS
CheckCode.VULNERABLE = _CHECK_VULNERABLE
CheckCode.UNSUPPORTED = _CHECK_UNSUPPORTED


class Failure:
    """Failure reasons for fail_with()"""
    Unknown = 'unknown-failure'
    Unreachable = 'unreachable'
    BadConfig = 'bad-config'
    Disconnected = 'disconnected'
    NotFound = 'not-found'
    UnexpectedReply = 'unexpected-reply'
    TimeoutExpired = 'timeout-expired'
    UserInterrupt = 'user-interrupt'
    NoAccess = 'no-access'
    NoTarget = 'no-target'
    NotVulnerable = 'not-vulnerable'
    PayloadFailed = 'payload-failed'


class Exploit(Module):
    """
    Base class for all exploit modules
    
    Provides common interface for exploit operations including:
    - Target selection
    - Payload integration
    - Check methods
    - Exploit execution
    """
    
    class Complete(Exception):
        """Exception to signal exploit completion"""
        pass
        
    class Failed(Exception):
        """Exception to signal exploit failure"""
        pass
    
    def __init__(self, info: Optional[Dict[str, Any]] = None):
        """
        Initialize exploit module
        
        Args:
            info: Module metadata
        """
        super().__init__(info)
        self.target = None
        self.payload = None
        self.handler = None
        self.session = None
        
    def check(self) -> CheckCode:
        """
        Check if target is vulnerable
        
        Returns:
            CheckCode instance indicating vulnerability status
        """
        return CheckCode.Unsupported
        
    def exploit(self):
        """
        Main exploit method - must be implemented by subclasses
        """
        raise NotImplementedError("Exploit method must be implemented")
        
    def run(self):
        """
        Run the exploit (calls exploit method)
        """
        try:
            self.exploit()
        except self.Complete:
            self.print_good("Exploit completed successfully")
        except self.Failed as e:
            self.print_error(f"Exploit failed: {e}")
            
    def handler_enabled(self) -> bool:
        """Check if payload handler is enabled"""
        return self.handler is not None
        
    def session_created(self) -> bool:
        """Check if a session was created"""
        return self.session is not None
        
    def report_vuln(self, info: Dict[str, Any]):
        """
        Report vulnerability to framework database
        
        Args:
            info: Vulnerability information dictionary
        """
        # Stub - would connect to framework DB
        pass
        
    def cleanup(self):
        """
        Cleanup after exploit execution
        """
        pass
        
    def cleanup_service(self):
        """
        Cleanup service-related resources
        """
        pass


class Remote:
    """
    Namespace for Remote exploit mixins and classes
    """
    
    class HttpClient:
        """
        HTTP client mixin for exploits
        
        Provides HTTP request functionality
        """
        
        def send_request_cgi(self, opts: Dict[str, Any]) -> Optional[Any]:
            """
            Send HTTP request
            
            Args:
                opts: Request options (uri, method, data, ctype, vars_get, vars_post, etc.)
                
            Returns:
                Response object or None
            """
            # Stub - would use Rex::Proto::Http or similar
            pass
            
        def send_request_raw(self, opts: Dict[str, Any]) -> Optional[Any]:
            """
            Send raw HTTP request
            
            Args:
                opts: Request options
                
            Returns:
                Response object or None
            """
            # Stub
            pass
            
    class HttpServer:
        """
        HTTP server mixin for exploits
        
        Provides HTTP server functionality for client-side exploits
        """
        
        def start_service(self):
            """Start HTTP service"""
            # Stub
            pass
            
        def on_request_uri(self, cli, request):
            """
            Handle HTTP request
            
            Args:
                cli: Client connection
                request: HTTP request
            """
            # Stub
            pass
            
    class JndiInjection:
        """
        JNDI injection mixin
        
        Provides JNDI/LDAP injection capabilities
        """
        
        @property
        def jndi_string(self) -> str:
            """Get JNDI connection string"""
            return f"ldap://{self.datastore.get('SRVHOST')}:{self.datastore.get('SRVPORT')}/obj"
            
        def build_ldap_search_response_payload_inline(self, gadget: str) -> bytes:
            """
            Build LDAP search response payload
            
            Args:
                gadget: Gadget chain to use
                
            Returns:
                Serialized payload bytes
            """
            # Stub - would use ysoserial or similar
            return b''
            
    class AutoCheck:
        """
        Automatic check execution before exploit
        """
        pass
        
    class Tcp:
        """TCP connection mixin"""
        
        def connect(self):
            """Establish TCP connection"""
            pass
            
        def disconnect(self):
            """Close TCP connection"""
            pass
            
    class Smb:
        """SMB protocol mixin"""
        
        class Client:
            """SMB client functionality"""
            pass
            
    class Ftp:
        """FTP protocol mixin"""
        pass
        
    class Ssh:
        """SSH protocol mixin"""
        pass


class Retry:
    """
    Retry mixin for exploits
    
    Provides retry_until_truthy and related methods
    """
    
    def retry_until_truthy(self, timeout: int = 30, delay: float = 0.5, **kwargs):
        """
        Retry a block until it returns truthy or timeout
        
        Args:
            timeout: Maximum time to retry in seconds
            delay: Delay between retries
            **kwargs: Additional options
        """
        import time
        start = time.time()
        while time.time() - start < timeout:
            if kwargs.get('condition', lambda: False)():
                return True
            time.sleep(delay)
        return False


# Failure constants at module level
Exploit.Failure = Failure
