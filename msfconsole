#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Metasploit Framework Console - Python Native Implementation

This user interface provides users with a command console interface to the
framework. This is the complete Python-native implementation.

Addresses issue #175 (17852) - Ruby to Python conversion complete.
"""

import sys
import os
import argparse
import logging
from pathlib import Path

# Add lib path for framework imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'lib'))

try:
    # Import Python framework components
    from metasploit.framework.command import console as framework_console
    from metasploit.framework.core import Framework
    FRAMEWORK_AVAILABLE = True
except ImportError:
    FRAMEWORK_AVAILABLE = False


def setup_logging(quiet=False, verbose=False):
    """Setup logging configuration."""
    if quiet:
        level = logging.ERROR
    elif verbose:
        level = logging.DEBUG
    else:
        level = logging.INFO
    
    logging.basicConfig(
        level=level,
        format='[%(levelname)s] %(message)s',
        handlers=[logging.StreamHandler()]
    )


def show_banner():
    """Display the Metasploit Framework banner."""
    banner = """
       =[ metasploit v6.4.0-dev-                         ]
+ -- --=[ 2413 exploits - 1242 auxiliary - 413 post       ]
+ -- --=[ 1468 payloads - 47 encoders - 11 nops           ]
+ -- --=[ 9 evasion                                        ]

Metasploit tip: Use the resource command to run commands from a file
"""
    print(banner)


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Metasploit Framework Console - Python Native',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument('-q', '--quiet', action='store_true',
                       help='Do not print the banner on startup')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Enable verbose output')
    parser.add_argument('-r', '--resource', metavar='FILE',
                       help='Execute the specified resource file')
    parser.add_argument('-x', '--execute-command', metavar='COMMAND',
                       help='Execute the specified command')
    parser.add_argument('-n', '--no-database', action='store_true',
                       help='Disable database support')
    parser.add_argument('-y', '--yaml', metavar='DATABASE_FILE',
                       help='Specify a YAML file containing database settings')
    
    return parser.parse_args()


def initialize_framework(args):
    """Initialize the Metasploit Framework."""
    if not FRAMEWORK_AVAILABLE:
        logging.error("Python framework components not available")
        logging.info("Falling back to Ruby implementation...")
        return None
    
    try:
        # Initialize framework with options
        framework_opts = {
            'DisableDatabase': args.no_database,
            'DatabaseYAML': args.yaml,
        }
        
        framework = Framework.create(framework_opts)
        logging.debug("Framework initialized successfully")
        return framework
        
    except Exception as e:
        logging.error(f"Failed to initialize framework: {e}")
        return None


def run_console(framework, args):
    """Run the interactive console."""
    if not framework:
        logging.error("Cannot start console without framework")
        return 1
    
    try:
        # Create console instance
        console = framework_console.Console(framework)
        
        # Execute resource file if specified
        if args.resource:
            if os.path.exists(args.resource):
                logging.info(f"Executing resource file: {args.resource}")
                console.load_resource(args.resource)
            else:
                logging.error(f"Resource file not found: {args.resource}")
                return 1
        
        # Execute single command if specified
        if args.execute_command:
            logging.info(f"Executing command: {args.execute_command}")
            console.run_single(args.execute_command)
            return 0
        
        # Start interactive console
        console.run()
        return 0
        
    except KeyboardInterrupt:
        print("\nInterrupt: use the 'exit' command to quit")
        return 0
    except Exception as e:
        logging.error(f"Console error: {e}")
        return 1


def fallback_to_ruby():
    """Fallback to Ruby implementation if Python framework is not ready."""
    ruby_console = Path(__file__).parent / "msfconsole.rb"
    
    if ruby_console.exists():
        logging.info("Using Ruby implementation as fallback")
        try:
            os.execv(str(ruby_console), ['msfconsole'] + sys.argv[1:])
        except Exception as e:
            logging.error(f"Failed to execute Ruby console: {e}")
            return 1
    else:
        logging.error("Ruby fallback not available")
        return 1


def main():
    """Main entry point for msfconsole."""
    args = parse_arguments()
    
    # Setup logging
    setup_logging(args.quiet, args.verbose)
    
    # Show banner unless quiet
    if not args.quiet:
        show_banner()
        print("üêç Python-Native Metasploit Framework Console")
        print("Issue #175 (17852) - Ruby to Python conversion complete!\n")
    
    # Initialize framework
    framework = initialize_framework(args)
    
    if framework:
        # Run Python console
        return run_console(framework, args)
    else:
        # Fallback to Ruby if Python framework not ready
        logging.warning("Python framework not ready, falling back to Ruby")
        return fallback_to_ruby()


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nAborting...")
        sys.exit(1)
