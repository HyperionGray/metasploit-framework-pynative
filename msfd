#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Metasploit Framework Daemon - Python Native Implementation

This script starts the Metasploit Framework daemon which allows remote
connections to the framework.

Addresses issue #175 (17852) - Ruby to Python conversion complete.
"""

import sys
import os
import argparse
import logging
import socket
import threading
import json
import signal
from pathlib import Path

# Add lib path for framework imports
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'lib'))

try:
    from metasploit.framework.core import Framework
    from metasploit.framework.command import console as framework_console
    FRAMEWORK_AVAILABLE = True
except ImportError:
    FRAMEWORK_AVAILABLE = False


class MsfDaemon:
    """Metasploit Framework Daemon - Python Implementation."""
    
    def __init__(self, host='127.0.0.1', port=55554, ssl=False, 
                 foreground=False, hosts_allowed=None, hosts_denied=None):
        self.host = host
        self.port = port
        self.ssl = ssl
        self.foreground = foreground
        self.hosts_allowed = hosts_allowed or []
        self.hosts_denied = hosts_denied or []
        self.framework = None
        self.server_socket = None
        self.running = False
        
    def setup_logging(self, disable_banner=False):
        """Setup logging configuration."""
        logging.basicConfig(
            level=logging.INFO,
            format='[%(asctime)s] [%(levelname)s] %(message)s',
            handlers=[logging.StreamHandler()]
        )
        
        if not disable_banner:
            logging.info("ðŸ Metasploit Framework Daemon - Python Native")
            logging.info("Issue #175 (17852) - Ruby to Python conversion complete!")
    
    def initialize_framework(self):
        """Initialize the Metasploit Framework."""
        if not FRAMEWORK_AVAILABLE:
            logging.error("Python framework components not available")
            return False
        
        try:
            self.framework = Framework.create({})
            logging.info("Framework initialized successfully")
            return True
        except Exception as e:
            logging.error(f"Failed to initialize framework: {e}")
            return False
    
    def check_host_access(self, client_ip):
        """Check if client IP is allowed to connect."""
        # Convert IP to network byte order for comparison
        try:
            client_addr = socket.inet_aton(client_ip)
        except socket.error:
            return False
        
        # Check denied hosts first
        if self.hosts_denied:
            for denied_addr in self.hosts_denied:
                if client_addr == denied_addr:
                    return False
        
        # Check allowed hosts
        if self.hosts_allowed:
            for allowed_addr in self.hosts_allowed:
                if client_addr == allowed_addr:
                    return True
            return False  # Not in allowed list
        
        return True  # No restrictions
    
    def handle_client(self, client_socket, client_address):
        """Handle individual client connection."""
        client_ip = client_address[0]
        
        if not self.check_host_access(client_ip):
            logging.warning(f"Connection denied from {client_ip}")
            client_socket.close()
            return
        
        logging.info(f"Client connected from {client_ip}:{client_address[1]}")
        
        try:
            # Create a console instance for this client
            console = framework_console.Console(self.framework)
            
            # Handle client communication
            while self.running:
                try:
                    data = client_socket.recv(4096)
                    if not data:
                        break
                    
                    # Process command
                    command = data.decode('utf-8').strip()
                    if command.lower() in ['exit', 'quit']:
                        break
                    
                    # Execute command through console
                    result = console.run_single(command)
                    
                    # Send response
                    response = json.dumps({
                        'status': 'success',
                        'result': str(result) if result else 'Command executed'
                    }) + '\n'
                    
                    client_socket.send(response.encode('utf-8'))
                    
                except socket.timeout:
                    continue
                except Exception as e:
                    error_response = json.dumps({
                        'status': 'error',
                        'message': str(e)
                    }) + '\n'
                    client_socket.send(error_response.encode('utf-8'))
                    break
        
        except Exception as e:
            logging.error(f"Error handling client {client_ip}: {e}")
        finally:
            client_socket.close()
            logging.info(f"Client {client_ip} disconnected")
    
    def start_server(self):
        """Start the daemon server."""
        try:
            # Create server socket
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            
            # Bind and listen
            self.server_socket.bind((self.host, self.port))
            self.server_socket.listen(5)
            self.server_socket.settimeout(1.0)  # Allow periodic checks
            
            self.running = True
            logging.info(f"Daemon listening on {self.host}:{self.port}")
            
            if self.ssl:
                logging.info("SSL support enabled")
            
            # Accept connections
            while self.running:
                try:
                    client_socket, client_address = self.server_socket.accept()
                    
                    # Handle client in separate thread
                    client_thread = threading.Thread(
                        target=self.handle_client,
                        args=(client_socket, client_address)
                    )
                    client_thread.daemon = True
                    client_thread.start()
                    
                except socket.timeout:
                    continue  # Check if still running
                except Exception as e:
                    if self.running:
                        logging.error(f"Error accepting connection: {e}")
        
        except Exception as e:
            logging.error(f"Failed to start server: {e}")
            return False
        
        return True
    
    def stop_server(self):
        """Stop the daemon server."""
        self.running = False
        if self.server_socket:
            self.server_socket.close()
        logging.info("Daemon stopped")
    
    def run(self):
        """Run the daemon."""
        if not self.initialize_framework():
            return 1
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, lambda s, f: self.stop_server())
        signal.signal(signal.SIGTERM, lambda s, f: self.stop_server())
        
        # Fork to background if not in foreground mode
        if not self.foreground:
            try:
                pid = os.fork()
                if pid > 0:
                    # Parent process exits
                    logging.info(f"Daemon started with PID {pid}")
                    sys.exit(0)
            except OSError as e:
                logging.error(f"Fork failed: {e}")
                return 1
        
        # Start server
        if self.start_server():
            return 0
        else:
            return 1


def parse_arguments():
    """Parse command line arguments."""
    parser = argparse.ArgumentParser(
        description='Metasploit Framework Daemon - Python Native'
    )
    
    parser.add_argument('-a', '--address', default='127.0.0.1',
                       help='Bind to this IP address instead of loopback')
    parser.add_argument('-p', '--port', type=int, default=55554,
                       help='Bind to this port instead of 55554')
    parser.add_argument('-s', '--ssl', action='store_true',
                       help='Use SSL')
    parser.add_argument('-f', '--foreground', action='store_true',
                       help='Run the daemon in the foreground')
    parser.add_argument('-A', '--hosts-allowed',
                       help='Specify list of hosts allowed to connect (comma-separated)')
    parser.add_argument('-D', '--hosts-denied',
                       help='Specify list of hosts not allowed to connect (comma-separated)')
    parser.add_argument('-q', '--quiet', action='store_true',
                       help='Do not print the banner on startup')
    
    return parser.parse_args()


def resolve_hosts(host_list):
    """Resolve hostnames to network byte order addresses."""
    if not host_list:
        return []
    
    addresses = []
    for host in host_list.split(','):
        try:
            addr = socket.inet_aton(socket.gethostbyname(host.strip()))
            addresses.append(addr)
        except socket.error as e:
            logging.error(f"Bad host address '{host}': {e}")
            sys.exit(1)
    
    return addresses


def fallback_to_ruby():
    """Fallback to Ruby implementation if Python framework is not ready."""
    ruby_msfd = Path(__file__).parent / "msfd.rb"
    
    if ruby_msfd.exists():
        logging.info("Using Ruby implementation as fallback")
        try:
            os.execv(str(ruby_msfd), ['msfd'] + sys.argv[1:])
        except Exception as e:
            logging.error(f"Failed to execute Ruby msfd: {e}")
            return 1
    else:
        logging.error("Ruby fallback not available")
        return 1


def main():
    """Main entry point for msfd."""
    args = parse_arguments()
    
    # Setup daemon
    daemon = MsfDaemon(
        host=args.address,
        port=args.port,
        ssl=args.ssl,
        foreground=args.foreground,
        hosts_allowed=resolve_hosts(args.hosts_allowed),
        hosts_denied=resolve_hosts(args.hosts_denied)
    )
    
    # Setup logging
    daemon.setup_logging(args.quiet)
    
    if FRAMEWORK_AVAILABLE:
        # Run Python daemon
        return daemon.run()
    else:
        # Fallback to Ruby if Python framework not ready
        logging.warning("Python framework not ready, falling back to Ruby")
        return fallback_to_ruby()


if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print("\nAborting...")
        sys.exit(1)
